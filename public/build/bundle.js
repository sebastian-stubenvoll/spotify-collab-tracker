/**
 * ---------------------------------------------
 *
 * Bundle of spotify-collab-tracker
 * Generated: 2021-12-16
 *
 * ---------------------------------------------
 *
 * Licenses:
 *
 * ---------------------------------------------
 *
 *
 * svelte
 * Version: 3.37.0
 * Description: Cybernetically enhanced web apps
 * URL: https://github.com/sveltejs/svelte.git
 * Author: Rich Harris
 *
 * License:
 * Copyright (c) 2016-21 [these people](https://github.com/sveltejs/svelte/graphs/contributors)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * 
 *
 * svelte-infinite-loading
 * Version: 1.3.6
 * Description: An infinite scroll component for Svelte apps
 * URL: git+https://github.com/Skayo/svelte-infinite-loading.git
 * Author: Skayo
 *
 * License:
 * MIT License
 *
 * Copyright (c) 2020 Skayo
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * 
 *
 * jsstore
 * Version: 4.2.6
 * Description: A complete IndexedDB wrapper with SQL like syntax.
 * URL: git+https://github.com/ujjwalguptaofficial/JsStore.git
 * Author: Ujjwal Gupta
 *
 * License:
 * The MIT License (MIT)
 *
 * Copyright (c) Ujjwal Gupta
 *
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * 
 *
 * @zerodevx/svelte-toast
 * Version: 0.3.0
 * Description: Simple elegant toast notifications
 * URL: https://github.com/zerodevx/svelte-toast.git
 * Author: Jason Lee
 *
 * License:
 * ISC License
 *
 * Copyright (c) 2021, Jason Lee <jason@zerodevx.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * 
 *
 * fuzzy
 * Version: 0.1.3
 * Description: small, standalone fuzzy search / fuzzy filter. browser or node
 * URL: git://github.com/mattyork/fuzzy.git
 * Author: Matt York
 *
 * License:
 * Copyright (c) 2012 Matt York
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * 
 *
 * svelte-search
 * Version: 1.1.0
 * Description: Customizable search input component for Svelte
 * URL: https://github.com/metonym/svelte-search.git
 * Author: Eric Liu
 *
 * License:
 * MIT License
 *
 * Copyright (c) 2020-present Eric Liu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * 
 *
 * svelte-typeahead
 * Version: 3.0.0
 * Description: Accessible, fuzzy search typeahead component
 * URL: https://github.com/metonym/svelte-typeahead.git
 * Author: Eric Liu
 *
 * License:
 * MIT License
 *
 * Copyright (c) 2020-present Eric Liu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * 
 *
 * date-fns
 * Version: 2.21.3
 * Description: Modern JavaScript date utility library
 * URL:
 * Author:
 *
 * License:
 * Copyright (C) 2020 Sasha Koss and Lesha Koss
 *
 * # License
 *
 * date-fns is licensed under the [MIT license](http://kossnocorp.mit-license.org).
 * Read more about MIT at [TLDRLegal](https://tldrlegal.com/license/mit-license).
 *
 * 
 *
 * strict-uri-encode
 * Version: 2.0.0
 * Description: A stricter URI encode adhering to RFC 3986
 * URL:
 * Author: Kevin MÃ¥rtensson
 *
 * License:
 * The MIT License (MIT)
 *
 * Copyright (c) Kevin Martensson <kevinmartensson@gmail.com> (github.com/kevva)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * 
 *
 * decode-uri-component
 * Version: 0.2.0
 * Description: A better decodeURIComponent
 * URL:
 * Author: Sam Verschueren
 *
 * License:
 * The MIT License (MIT)
 *
 * Copyright (c) Sam Verschueren <sam.verschueren@gmail.com> (github.com/SamVerschueren)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * 
 *
 * split-on-first
 * Version: 1.1.0
 * Description: Split a string on the first occurance of a given separator
 * URL:
 * Author: Sindre Sorhus
 *
 * License:
 * MIT License
 *
 * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * 
 *
 * filter-obj
 * Version: 1.1.0
 * Description: Filter object keys and values into a new object
 * URL:
 * Author: Sindre Sorhus
 *
 * License:
 * The MIT License (MIT)
 *
 * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * 
 *
 * query-string
 * Version: 7.0.0
 * Description: Parse and stringify URL query strings
 * URL:
 * Author: Sindre Sorhus
 *
 * License:
 * MIT License
 *
 * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (http://sindresorhus.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * 
 *
 *
 * ---------------------------------------------
 */


(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign$1(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign$1($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(anchor = null) {
            this.a = anchor;
            this.e = this.n = null;
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.h(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    function create_animation(node, from, fn, params) {
        if (!from)
            return noop;
        const to = node.getBoundingClientRect();
        if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
            return noop;
        const { delay = 0, duration = 300, easing = identity, 
        // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
        start: start_time = now() + delay, 
        // @ts-ignore todo:
        end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
        let running = true;
        let started = false;
        let name;
        function start() {
            if (css) {
                name = create_rule(node, 0, 1, duration, delay, easing, css);
            }
            if (!delay) {
                started = true;
            }
        }
        function stop() {
            if (css)
                delete_rule(node, name);
            running = false;
        }
        loop(now => {
            if (!started && now >= start_time) {
                started = true;
            }
            if (started && now >= end) {
                tick(1, 0);
                stop();
            }
            if (!running) {
                return false;
            }
            if (started) {
                const p = now - start_time;
                const t = 0 + 1 * easing(p / duration);
                tick(t, 1 - t);
            }
            return true;
        });
        start();
        tick(0, 1);
        return stop;
    }
    function fix_position(node) {
        const style = getComputedStyle(node);
        if (style.position !== 'absolute' && style.position !== 'fixed') {
            const { width, height } = style;
            const a = node.getBoundingClientRect();
            node.style.position = 'absolute';
            node.style.width = width;
            node.style.height = height;
            add_transform(node, a);
        }
    }
    function add_transform(node, a) {
        const b = node.getBoundingClientRect();
        if (a.left !== b.left || a.top !== b.top) {
            const style = getComputedStyle(node);
            const transform = style.transform === 'none' ? '' : style.transform;
            node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    function hasContext(key) {
        return get_current_component().$$.context.has(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro â we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro â needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                if (info.blocks[i] === block) {
                                    info.blocks[i] = null;
                                }
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function fix_and_outro_and_destroy_block(block, lookup) {
        block.f();
        outro_and_destroy_block(block, lookup);
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind$1(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.37.0' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }
    /**
     * Base class to create strongly typed Svelte components.
     * This only exists for typing purposes and should be used in `.d.ts` files.
     *
     * ### Example:
     *
     * You have component library on npm called `component-library`, from which
     * you export a component called `MyComponent`. For Svelte+TypeScript users,
     * you want to provide typings. Therefore you create a `index.d.ts`:
     * ```ts
     * import { SvelteComponentTyped } from "svelte";
     * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}
     * ```
     * Typing this makes it possible for IDEs like VS Code with the Svelte extension
     * to provide intellisense and to use the component like this in a Svelte file
     * with TypeScript:
     * ```svelte
     * <script lang="ts">
     * 	import { MyComponent } from "component-library";
     * </script>
     * <MyComponent foo={'bar'} />
     * ```
     *
     * #### Why not make this part of `SvelteComponent(Dev)`?
     * Because
     * ```ts
     * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}
     * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;
     * ```
     * will throw a type error, so we need to seperate the more strictly typed class.
     */
    class SvelteComponentTyped extends SvelteComponentDev {
        constructor(options) {
            super(options);
        }
    }

    var svelte = /*#__PURE__*/Object.freeze({
        __proto__: null,
        SvelteComponent: SvelteComponentDev,
        SvelteComponentTyped: SvelteComponentTyped,
        afterUpdate: afterUpdate,
        beforeUpdate: beforeUpdate,
        createEventDispatcher: createEventDispatcher,
        getContext: getContext,
        hasContext: hasContext,
        onDestroy: onDestroy,
        onMount: onMount,
        setContext: setContext,
        tick: tick
    });

    /* node_modules/svelte-infinite-loading/src/Spinner.svelte generated by Svelte v3.37.0 */

    const file$f = "node_modules/svelte-infinite-loading/src/Spinner.svelte";

    // (49:0) {:else}
    function create_else_block$2(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "loading-default svelte-10h86fq");
    			add_location(i, file$f, 51, 1, 1184);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(49:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (38:33) 
    function create_if_block_3$1(ctx) {
    	let span5;
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let span2;
    	let t2;
    	let span3;
    	let t3;
    	let span4;

    	const block = {
    		c: function create() {
    			span5 = element("span");
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			t1 = space();
    			span2 = element("span");
    			t2 = space();
    			span3 = element("span");
    			t3 = space();
    			span4 = element("span");
    			attr_dev(span0, "class", "wave-item svelte-10h86fq");
    			add_location(span0, file$f, 41, 2, 978);
    			attr_dev(span1, "class", "wave-item svelte-10h86fq");
    			add_location(span1, file$f, 42, 2, 1012);
    			attr_dev(span2, "class", "wave-item svelte-10h86fq");
    			add_location(span2, file$f, 43, 2, 1046);
    			attr_dev(span3, "class", "wave-item svelte-10h86fq");
    			add_location(span3, file$f, 44, 2, 1080);
    			attr_dev(span4, "class", "wave-item svelte-10h86fq");
    			add_location(span4, file$f, 45, 2, 1114);
    			attr_dev(span5, "class", "loading-wave-dots svelte-10h86fq");
    			add_location(span5, file$f, 40, 1, 943);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span5, anchor);
    			append_dev(span5, span0);
    			append_dev(span5, t0);
    			append_dev(span5, span1);
    			append_dev(span5, t1);
    			append_dev(span5, span2);
    			append_dev(span5, t2);
    			append_dev(span5, span3);
    			append_dev(span5, t3);
    			append_dev(span5, span4);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(38:33) ",
    		ctx
    	});

    	return block;
    }

    // (33:31) 
    function create_if_block_2$2(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "loading-spiral svelte-10h86fq");
    			add_location(i, file$f, 35, 1, 856);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(33:31) ",
    		ctx
    	});

    	return block;
    }

    // (19:32) 
    function create_if_block_1$2(ctx) {
    	let span8;
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let span2;
    	let t2;
    	let span3;
    	let t3;
    	let span4;
    	let t4;
    	let span5;
    	let t5;
    	let span6;
    	let t6;
    	let span7;

    	const block = {
    		c: function create() {
    			span8 = element("span");
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			t1 = space();
    			span2 = element("span");
    			t2 = space();
    			span3 = element("span");
    			t3 = space();
    			span4 = element("span");
    			t4 = space();
    			span5 = element("span");
    			t5 = space();
    			span6 = element("span");
    			t6 = space();
    			span7 = element("span");
    			attr_dev(span0, "class", "circle-item svelte-10h86fq");
    			add_location(span0, file$f, 22, 2, 509);
    			attr_dev(span1, "class", "circle-item svelte-10h86fq");
    			add_location(span1, file$f, 23, 2, 545);
    			attr_dev(span2, "class", "circle-item svelte-10h86fq");
    			add_location(span2, file$f, 24, 2, 581);
    			attr_dev(span3, "class", "circle-item svelte-10h86fq");
    			add_location(span3, file$f, 25, 2, 617);
    			attr_dev(span4, "class", "circle-item svelte-10h86fq");
    			add_location(span4, file$f, 26, 2, 653);
    			attr_dev(span5, "class", "circle-item svelte-10h86fq");
    			add_location(span5, file$f, 27, 2, 689);
    			attr_dev(span6, "class", "circle-item svelte-10h86fq");
    			add_location(span6, file$f, 28, 2, 725);
    			attr_dev(span7, "class", "circle-item svelte-10h86fq");
    			add_location(span7, file$f, 29, 2, 761);
    			attr_dev(span8, "class", "loading-circles svelte-10h86fq");
    			add_location(span8, file$f, 21, 1, 476);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span8, anchor);
    			append_dev(span8, span0);
    			append_dev(span8, t0);
    			append_dev(span8, span1);
    			append_dev(span8, t1);
    			append_dev(span8, span2);
    			append_dev(span8, t2);
    			append_dev(span8, span3);
    			append_dev(span8, t3);
    			append_dev(span8, span4);
    			append_dev(span8, t4);
    			append_dev(span8, span5);
    			append_dev(span8, t5);
    			append_dev(span8, span6);
    			append_dev(span8, t6);
    			append_dev(span8, span7);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span8);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(19:32) ",
    		ctx
    	});

    	return block;
    }

    // (5:0) {#if spinner === 'bubbles'}
    function create_if_block$5(ctx) {
    	let span8;
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let span2;
    	let t2;
    	let span3;
    	let t3;
    	let span4;
    	let t4;
    	let span5;
    	let t5;
    	let span6;
    	let t6;
    	let span7;

    	const block = {
    		c: function create() {
    			span8 = element("span");
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			t1 = space();
    			span2 = element("span");
    			t2 = space();
    			span3 = element("span");
    			t3 = space();
    			span4 = element("span");
    			t4 = space();
    			span5 = element("span");
    			t5 = space();
    			span6 = element("span");
    			t6 = space();
    			span7 = element("span");
    			attr_dev(span0, "class", "bubble-item svelte-10h86fq");
    			add_location(span0, file$f, 8, 2, 127);
    			attr_dev(span1, "class", "bubble-item svelte-10h86fq");
    			add_location(span1, file$f, 9, 2, 163);
    			attr_dev(span2, "class", "bubble-item svelte-10h86fq");
    			add_location(span2, file$f, 10, 2, 199);
    			attr_dev(span3, "class", "bubble-item svelte-10h86fq");
    			add_location(span3, file$f, 11, 2, 235);
    			attr_dev(span4, "class", "bubble-item svelte-10h86fq");
    			add_location(span4, file$f, 12, 2, 271);
    			attr_dev(span5, "class", "bubble-item svelte-10h86fq");
    			add_location(span5, file$f, 13, 2, 307);
    			attr_dev(span6, "class", "bubble-item svelte-10h86fq");
    			add_location(span6, file$f, 14, 2, 343);
    			attr_dev(span7, "class", "bubble-item svelte-10h86fq");
    			add_location(span7, file$f, 15, 2, 379);
    			attr_dev(span8, "class", "loading-bubbles svelte-10h86fq");
    			add_location(span8, file$f, 7, 1, 94);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span8, anchor);
    			append_dev(span8, span0);
    			append_dev(span8, t0);
    			append_dev(span8, span1);
    			append_dev(span8, t1);
    			append_dev(span8, span2);
    			append_dev(span8, t2);
    			append_dev(span8, span3);
    			append_dev(span8, t3);
    			append_dev(span8, span4);
    			append_dev(span8, t4);
    			append_dev(span8, span5);
    			append_dev(span8, t5);
    			append_dev(span8, span6);
    			append_dev(span8, t6);
    			append_dev(span8, span7);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span8);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(5:0) {#if spinner === 'bubbles'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*spinner*/ ctx[0] === "bubbles") return create_if_block$5;
    		if (/*spinner*/ ctx[0] === "circles") return create_if_block_1$2;
    		if (/*spinner*/ ctx[0] === "spiral") return create_if_block_2$2;
    		if (/*spinner*/ ctx[0] === "wavedots") return create_if_block_3$1;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Spinner", slots, []);
    	let { spinner = "" } = $$props;
    	const writable_props = ["spinner"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Spinner> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("spinner" in $$props) $$invalidate(0, spinner = $$props.spinner);
    	};

    	$$self.$capture_state = () => ({ spinner });

    	$$self.$inject_state = $$props => {
    		if ("spinner" in $$props) $$invalidate(0, spinner = $$props.spinner);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [spinner];
    }

    class Spinner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { spinner: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spinner",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get spinner() {
    		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set spinner(value) {
    		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-infinite-loading/src/InfiniteLoading.svelte generated by Svelte v3.37.0 */

    const { Object: Object_1$2, console: console_1$1 } = globals;
    const file$e = "node_modules/svelte-infinite-loading/src/InfiniteLoading.svelte";
    const get_error_slot_changes = dirty => ({});
    const get_error_slot_context = ctx => ({ attemptLoad: /*attemptLoad*/ ctx[7] });
    const get_noMore_slot_changes = dirty => ({});
    const get_noMore_slot_context = ctx => ({});
    const get_noResults_slot_changes = dirty => ({});
    const get_noResults_slot_context = ctx => ({});
    const get_spinner_slot_changes = dirty => ({ isFirstLoad: dirty & /*isFirstLoad*/ 2 });
    const get_spinner_slot_context = ctx => ({ isFirstLoad: /*isFirstLoad*/ ctx[1] });

    // (325:1) {#if showSpinner}
    function create_if_block_3(ctx) {
    	let div;
    	let current;
    	const spinner_slot_template = /*#slots*/ ctx[15].spinner;
    	const spinner_slot = create_slot(spinner_slot_template, ctx, /*$$scope*/ ctx[14], get_spinner_slot_context);
    	const spinner_slot_or_fallback = spinner_slot || fallback_block_3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (spinner_slot_or_fallback) spinner_slot_or_fallback.c();
    			attr_dev(div, "class", "infinite-status-prompt");
    			add_location(div, file$e, 325, 2, 8091);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (spinner_slot_or_fallback) {
    				spinner_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (spinner_slot) {
    				if (spinner_slot.p && dirty & /*$$scope, isFirstLoad*/ 16386) {
    					update_slot(spinner_slot, spinner_slot_template, ctx, /*$$scope*/ ctx[14], dirty, get_spinner_slot_changes, get_spinner_slot_context);
    				}
    			} else {
    				if (spinner_slot_or_fallback && spinner_slot_or_fallback.p && dirty & /*spinner*/ 1) {
    					spinner_slot_or_fallback.p(ctx, dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spinner_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spinner_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (spinner_slot_or_fallback) spinner_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(325:1) {#if showSpinner}",
    		ctx
    	});

    	return block;
    }

    // (327:38)      
    function fallback_block_3(ctx) {
    	let spinner_1;
    	let current;

    	spinner_1 = new Spinner({
    			props: { spinner: /*spinner*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(spinner_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(spinner_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const spinner_1_changes = {};
    			if (dirty & /*spinner*/ 1) spinner_1_changes.spinner = /*spinner*/ ctx[0];
    			spinner_1.$set(spinner_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spinner_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spinner_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(spinner_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_3.name,
    		type: "fallback",
    		source: "(327:38)      ",
    		ctx
    	});

    	return block;
    }

    // (333:1) {#if showNoResults}
    function create_if_block_2$1(ctx) {
    	let div;
    	let current;
    	const noResults_slot_template = /*#slots*/ ctx[15].noResults;
    	const noResults_slot = create_slot(noResults_slot_template, ctx, /*$$scope*/ ctx[14], get_noResults_slot_context);
    	const noResults_slot_or_fallback = noResults_slot || fallback_block_2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (noResults_slot_or_fallback) noResults_slot_or_fallback.c();
    			attr_dev(div, "class", "infinite-status-prompt");
    			add_location(div, file$e, 333, 2, 8244);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (noResults_slot_or_fallback) {
    				noResults_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (noResults_slot) {
    				if (noResults_slot.p && dirty & /*$$scope*/ 16384) {
    					update_slot(noResults_slot, noResults_slot_template, ctx, /*$$scope*/ ctx[14], dirty, get_noResults_slot_changes, get_noResults_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(noResults_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(noResults_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (noResults_slot_or_fallback) noResults_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(333:1) {#if showNoResults}",
    		ctx
    	});

    	return block;
    }

    // (335:26)      No results :(    
    function fallback_block_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No results :(");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_2.name,
    		type: "fallback",
    		source: "(335:26)      No results :(    ",
    		ctx
    	});

    	return block;
    }

    // (341:1) {#if showNoMore}
    function create_if_block_1$1(ctx) {
    	let div;
    	let current;
    	const noMore_slot_template = /*#slots*/ ctx[15].noMore;
    	const noMore_slot = create_slot(noMore_slot_template, ctx, /*$$scope*/ ctx[14], get_noMore_slot_context);
    	const noMore_slot_or_fallback = noMore_slot || fallback_block_1(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (noMore_slot_or_fallback) noMore_slot_or_fallback.c();
    			attr_dev(div, "class", "infinite-status-prompt");
    			add_location(div, file$e, 341, 2, 8374);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (noMore_slot_or_fallback) {
    				noMore_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (noMore_slot) {
    				if (noMore_slot.p && dirty & /*$$scope*/ 16384) {
    					update_slot(noMore_slot, noMore_slot_template, ctx, /*$$scope*/ ctx[14], dirty, get_noMore_slot_changes, get_noMore_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(noMore_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(noMore_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (noMore_slot_or_fallback) noMore_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(341:1) {#if showNoMore}",
    		ctx
    	});

    	return block;
    }

    // (343:23)      No more data :)    
    function fallback_block_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No more data :)");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(343:23)      No more data :)    ",
    		ctx
    	});

    	return block;
    }

    // (349:1) {#if showError}
    function create_if_block$4(ctx) {
    	let div;
    	let current;
    	const error_slot_template = /*#slots*/ ctx[15].error;
    	const error_slot = create_slot(error_slot_template, ctx, /*$$scope*/ ctx[14], get_error_slot_context);
    	const error_slot_or_fallback = error_slot || fallback_block$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (error_slot_or_fallback) error_slot_or_fallback.c();
    			attr_dev(div, "class", "infinite-status-prompt");
    			add_location(div, file$e, 349, 2, 8502);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (error_slot_or_fallback) {
    				error_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (error_slot) {
    				if (error_slot.p && dirty & /*$$scope*/ 16384) {
    					update_slot(error_slot, error_slot_template, ctx, /*$$scope*/ ctx[14], dirty, get_error_slot_changes, get_error_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(error_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(error_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (error_slot_or_fallback) error_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(349:1) {#if showError}",
    		ctx
    	});

    	return block;
    }

    // (351:36)      Oops, something went wrong :(     
    function fallback_block$2(ctx) {
    	let t0;
    	let br;
    	let t1;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			t0 = text("Oops, something went wrong :(\n\t\t\t\t");
    			br = element("br");
    			t1 = space();
    			button = element("button");
    			button.textContent = "Retry";
    			add_location(br, file$e, 352, 4, 8614);
    			attr_dev(button, "class", "btn-try-infinite svelte-o3w4bf");
    			add_location(button, file$e, 353, 4, 8623);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*attemptLoad*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$2.name,
    		type: "fallback",
    		source: "(351:36)      Oops, something went wrong :(     ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let current;
    	let if_block0 = /*showSpinner*/ ctx[3] && create_if_block_3(ctx);
    	let if_block1 = /*showNoResults*/ ctx[5] && create_if_block_2$1(ctx);
    	let if_block2 = /*showNoMore*/ ctx[6] && create_if_block_1$1(ctx);
    	let if_block3 = /*showError*/ ctx[4] && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			attr_dev(div, "class", "infinite-loading-container svelte-o3w4bf");
    			add_location(div, file$e, 323, 0, 8005);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			/*div_binding*/ ctx[16](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*showSpinner*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*showSpinner*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*showNoResults*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*showNoResults*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*showNoMore*/ ctx[6]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*showNoMore*/ 64) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*showError*/ ctx[4]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*showError*/ 16) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$4(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			/*div_binding*/ ctx[16](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const THROTTLE_LIMIT = 50;
    const LOOP_CHECK_TIMEOUT = 1000;
    const LOOP_CHECK_MAX_CALLS = 10;

    const ERROR_INFINITE_LOOP = [
    	`executed the callback function more than ${LOOP_CHECK_MAX_CALLS} times for a short time, it looks like searched a wrong scroll wrapper that doest not has fixed height or maximum height, please check it. If you want to force to set a element as scroll wrapper rather than automatic searching, you can do this:`,
    	"<!-- add a special attribute for the real scroll wrapper (can also be data-infinite-wrapper) -->",
    	"<div infinite-wrapper>",
    	"  ...",
    	"  <!-- set forceUseInfiniteWrapper -->",
    	"  <InfiniteLoading forceUseInfiniteWrapper>",
    	"</div>",
    	"or",
    	"<div class=\"infinite-wrapper\">",
    	"  ...",
    	"  <!-- set forceUseInfiniteWrapper as css selector of the real scroll wrapper -->",
    	"  <InfiniteLoading forceUseInfiniteWrapper=\".infinite-wrapper\" />",
    	"</div>"
    ].join("\n");

    /**
     * the third argument for event bundler
     * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
     */
    const thirdEventArg = (() => {
    	let result = false;

    	try {
    		const arg = Object.defineProperty({}, "passive", {
    			get() {
    				result = { passive: true };
    				return true;
    			}
    		});

    		window.addEventListener("testpassive", arg, arg);
    		window.remove("testpassive", arg, arg);
    	} catch(e) {
    		
    	} /* */

    	return result;
    })();

    const throttler = {
    	timers: [],
    	caches: [],
    	throttle(fn) {
    		if (this.caches.indexOf(fn) === -1) {
    			// cache current handler
    			this.caches.push(fn);

    			// save timer for current handler
    			this.timers.push(setTimeout(
    				() => {
    					fn();

    					// empty cache and timer
    					this.caches.splice(this.caches.indexOf(fn), 1);

    					this.timers.shift();
    				},
    				THROTTLE_LIMIT
    			));
    		}
    	},
    	reset() {
    		// reset all timers
    		this.timers.forEach(timer => {
    			clearTimeout(timer);
    		});

    		this.timers.length = 0;

    		// empty caches
    		this.caches = [];
    	}
    };

    const loopTracker = {
    	isChecked: false,
    	timer: null,
    	times: 0,
    	track() {
    		// record track times
    		this.times += 1;

    		// try to mark check status
    		clearTimeout(this.timer);

    		this.timer = setTimeout(
    			() => {
    				this.isChecked = true;
    			},
    			LOOP_CHECK_TIMEOUT
    		);

    		// throw warning if the times of continuous calls large than the maximum times
    		if (this.times > LOOP_CHECK_MAX_CALLS) {
    			console.error(ERROR_INFINITE_LOOP);
    			this.isChecked = true;
    		}
    	}
    };

    const scrollBarStorage = {
    	key: "_infiniteScrollHeight",
    	getScrollElement(element) {
    		return element === window ? document.documentElement : element;
    	},
    	save(element) {
    		const target = this.getScrollElement(element);

    		// save scroll height on the scroll parent
    		target[this.key] = target.scrollHeight;
    	},
    	restore(element) {
    		const target = this.getScrollElement(element);

    		/* istanbul ignore else */
    		if (typeof target[this.key] === "number") {
    			target.scrollTop = target.scrollHeight - target[this.key] + target.scrollTop;
    		}

    		this.remove(target);
    	},
    	remove(element) {
    		if (element[this.key] !== undefined) {
    			// remove scroll height
    			delete element[this.key]; // eslint-disable-line no-param-reassign
    		}
    	}
    };

    function isVisible(element) {
    	return element.offsetWidth + element.offsetHeight > 0;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let showSpinner;
    	let showError;
    	let showNoResults;
    	let showNoMore;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("InfiniteLoading", slots, ['spinner','noResults','noMore','error']);
    	const dispatch = createEventDispatcher();

    	const STATUS = {
    		READY: 0,
    		LOADING: 1,
    		COMPLETE: 2,
    		ERROR: 3
    	};

    	let { distance = 100 } = $$props;
    	let { spinner = "default" } = $$props;
    	let { direction = "bottom" } = $$props;
    	let { forceUseInfiniteWrapper = false } = $$props;
    	let { identifier = +new Date() } = $$props;
    	let isFirstLoad = true; // save the current loading whether it is the first loading
    	let status = STATUS.READY;
    	let mounted = false;
    	let thisElement;
    	let scrollParent;

    	const stateChanger = {
    		loaded: async () => {
    			$$invalidate(1, isFirstLoad = false);

    			if (direction === "top") {
    				// wait for DOM updated
    				await tick();

    				scrollBarStorage.restore(scrollParent);
    			}

    			if (status === STATUS.LOADING) {
    				await tick();
    				await attemptLoad(true);
    			}
    		},
    		complete: async () => {
    			$$invalidate(12, status = STATUS.COMPLETE);

    			// force re-complation computed properties to fix the problem of get slot text delay
    			await tick();

    			scrollParent.removeEventListener("scroll", scrollHandler, thirdEventArg);
    		},
    		reset: async () => {
    			$$invalidate(12, status = STATUS.READY);
    			$$invalidate(1, isFirstLoad = true);
    			scrollBarStorage.remove(scrollParent);
    			scrollParent.addEventListener("scroll", scrollHandler, thirdEventArg);

    			// wait for list to be empty and the empty action may trigger a scroll event
    			setTimeout(
    				() => {
    					throttler.reset();
    					scrollHandler();
    				},
    				1
    			);
    		},
    		error: () => {
    			$$invalidate(12, status = STATUS.ERROR);
    			throttler.reset();
    		}
    	};

    	function scrollHandler(event) {
    		if (status === STATUS.READY) {
    			if (event && event.constructor === Event && isVisible(thisElement)) {
    				throttler.throttle(attemptLoad);
    			} else {
    				attemptLoad();
    			}
    		}
    	}

    	// Attempt to trigger load
    	async function attemptLoad(isContinuousCall) {
    		if (status !== STATUS.COMPLETE && isVisible(thisElement) && getCurrentDistance() <= distance) {
    			$$invalidate(12, status = STATUS.LOADING);

    			if (direction === "top") {
    				// wait for spinner display
    				await tick();

    				scrollBarStorage.save(scrollParent);
    			}

    			dispatch("infinite", stateChanger);

    			if (isContinuousCall && !forceUseInfiniteWrapper && !loopTracker.isChecked) {
    				// check this component whether be in an infinite loop if it is not checked
    				loopTracker.track();
    			}
    		} else if (status === STATUS.LOADING) {
    			$$invalidate(12, status = STATUS.READY);
    		}
    	}

    	// Get current distance from the specified direction
    	function getCurrentDistance() {
    		let distance;

    		if (direction === "top") {
    			distance = typeof scrollParent.scrollTop === "number"
    			? scrollParent.scrollTop
    			: scrollParent.pageYOffset;
    		} else {
    			const infiniteElementOffsetTopFromBottom = thisElement.getBoundingClientRect().top;

    			const scrollElementOffsetTopFromBottom = scrollParent === window
    			? window.innerHeight
    			: scrollParent.getBoundingClientRect().bottom;

    			distance = infiniteElementOffsetTopFromBottom - scrollElementOffsetTopFromBottom;
    		}

    		return distance;
    	}

    	// Get the first scroll parent of an element
    	function getScrollParent(element = thisElement) {
    		let result;

    		if (typeof forceUseInfiniteWrapper === "string") {
    			result = document.querySelector(forceUseInfiniteWrapper);
    		}

    		if (!result) {
    			if (element.tagName === "BODY") {
    				result = window;
    			} else if (!forceUseInfiniteWrapper && ["scroll", "auto"].indexOf(getComputedStyle(element).overflowY) > -1) {
    				result = element;
    			} else if (element.hasAttribute("infinite-wrapper") || element.hasAttribute("data-infinite-wrapper")) {
    				result = element;
    			}
    		}

    		return result || getScrollParent(element.parentNode);
    	}

    	function updateScrollParent() {
    		if (mounted) scrollParent = getScrollParent();
    	}

    	function identifierUpdated() {
    		if (mounted) stateChanger.reset();
    	}

    	onMount(async () => {
    		$$invalidate(13, mounted = true);

    		setTimeout(
    			() => {
    				scrollHandler();
    				scrollParent.addEventListener("scroll", scrollHandler, thirdEventArg);
    			},
    			1
    		);
    	});

    	onDestroy(() => {
    		if (mounted && status !== STATUS.COMPLETE) {
    			throttler.reset();
    			scrollBarStorage.remove(scrollParent);
    			scrollParent.removeEventListener("scroll", scrollHandler, thirdEventArg);
    		}
    	});

    	const writable_props = ["distance", "spinner", "direction", "forceUseInfiniteWrapper", "identifier"];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<InfiniteLoading> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			thisElement = $$value;
    			$$invalidate(2, thisElement);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("distance" in $$props) $$invalidate(8, distance = $$props.distance);
    		if ("spinner" in $$props) $$invalidate(0, spinner = $$props.spinner);
    		if ("direction" in $$props) $$invalidate(9, direction = $$props.direction);
    		if ("forceUseInfiniteWrapper" in $$props) $$invalidate(10, forceUseInfiniteWrapper = $$props.forceUseInfiniteWrapper);
    		if ("identifier" in $$props) $$invalidate(11, identifier = $$props.identifier);
    		if ("$$scope" in $$props) $$invalidate(14, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		THROTTLE_LIMIT,
    		LOOP_CHECK_TIMEOUT,
    		LOOP_CHECK_MAX_CALLS,
    		ERROR_INFINITE_LOOP,
    		thirdEventArg,
    		throttler,
    		loopTracker,
    		scrollBarStorage,
    		isVisible,
    		onMount,
    		onDestroy,
    		tick,
    		createEventDispatcher,
    		Spinner,
    		dispatch,
    		STATUS,
    		distance,
    		spinner,
    		direction,
    		forceUseInfiniteWrapper,
    		identifier,
    		isFirstLoad,
    		status,
    		mounted,
    		thisElement,
    		scrollParent,
    		stateChanger,
    		scrollHandler,
    		attemptLoad,
    		getCurrentDistance,
    		getScrollParent,
    		updateScrollParent,
    		identifierUpdated,
    		showSpinner,
    		showError,
    		showNoResults,
    		showNoMore
    	});

    	$$self.$inject_state = $$props => {
    		if ("distance" in $$props) $$invalidate(8, distance = $$props.distance);
    		if ("spinner" in $$props) $$invalidate(0, spinner = $$props.spinner);
    		if ("direction" in $$props) $$invalidate(9, direction = $$props.direction);
    		if ("forceUseInfiniteWrapper" in $$props) $$invalidate(10, forceUseInfiniteWrapper = $$props.forceUseInfiniteWrapper);
    		if ("identifier" in $$props) $$invalidate(11, identifier = $$props.identifier);
    		if ("isFirstLoad" in $$props) $$invalidate(1, isFirstLoad = $$props.isFirstLoad);
    		if ("status" in $$props) $$invalidate(12, status = $$props.status);
    		if ("mounted" in $$props) $$invalidate(13, mounted = $$props.mounted);
    		if ("thisElement" in $$props) $$invalidate(2, thisElement = $$props.thisElement);
    		if ("scrollParent" in $$props) scrollParent = $$props.scrollParent;
    		if ("showSpinner" in $$props) $$invalidate(3, showSpinner = $$props.showSpinner);
    		if ("showError" in $$props) $$invalidate(4, showError = $$props.showError);
    		if ("showNoResults" in $$props) $$invalidate(5, showNoResults = $$props.showNoResults);
    		if ("showNoMore" in $$props) $$invalidate(6, showNoMore = $$props.showNoMore);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*status*/ 4096) {
    			$$invalidate(3, showSpinner = status === STATUS.LOADING);
    		}

    		if ($$self.$$.dirty & /*status*/ 4096) {
    			$$invalidate(4, showError = status === STATUS.ERROR);
    		}

    		if ($$self.$$.dirty & /*status, isFirstLoad*/ 4098) {
    			$$invalidate(5, showNoResults = status === STATUS.COMPLETE && isFirstLoad);
    		}

    		if ($$self.$$.dirty & /*status, isFirstLoad*/ 4098) {
    			$$invalidate(6, showNoMore = status === STATUS.COMPLETE && !isFirstLoad);
    		}

    		if ($$self.$$.dirty & /*forceUseInfiniteWrapper, mounted*/ 9216) {
    			// Watch forceUseInfiniteWrapper and mounted
    			(updateScrollParent());
    		}

    		if ($$self.$$.dirty & /*identifier, mounted*/ 10240) {
    			// Watch identifier and mounted
    			(identifierUpdated());
    		}
    	};

    	return [
    		spinner,
    		isFirstLoad,
    		thisElement,
    		showSpinner,
    		showError,
    		showNoResults,
    		showNoMore,
    		attemptLoad,
    		distance,
    		direction,
    		forceUseInfiniteWrapper,
    		identifier,
    		status,
    		mounted,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class InfiniteLoading extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
    			distance: 8,
    			spinner: 0,
    			direction: 9,
    			forceUseInfiniteWrapper: 10,
    			identifier: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InfiniteLoading",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get distance() {
    		throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set distance(value) {
    		throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get spinner() {
    		throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set spinner(value) {
    		throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get direction() {
    		throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direction(value) {
    		throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get forceUseInfiniteWrapper() {
    		throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set forceUseInfiniteWrapper(value) {
    		throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get identifier() {
    		throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set identifier(value) {
    		throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function dec2hex(dec) {
      return ('0' + dec.toString(16)).substr(-2)
    }

    function generateRandomString() {
      const array = new Uint32Array(56/2);
      window.crypto.getRandomValues(array);
      return Array.from(array, dec2hex).join('');
    }

    function sha256(plain) { // returns promise ArrayBuffer
      const encoder = new TextEncoder();
      const data = encoder.encode(plain);
      return window.crypto.subtle.digest('SHA-256', data);
    }

    function base64urlencode(a) {
        // Convert the ArrayBuffer to string using Uint8 array.
        // btoa takes chars from 0-255 and base64 encodes.
        // Then convert the base64 encoded to base64url encoded.
        // (replace + with -, replace / with _, trim trailing =)
        return btoa(String.fromCharCode.apply(null, new Uint8Array(a)))
            .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    async function challenge_from_verifier(v) {
      const hashed = await sha256(v);
      const base64encoded = base64urlencode(hashed);
      return base64encoded;
    }

    function to_unix(ts) {
      const unix = Date.parse(ts);
      return unix
    }

    const clientID = '0a004f36100a460ca97d2d99f485af2f';
    //export const redirect_uri = 'https://sebastian-stubenvoll.github.io/spotify-collab-tracker';
    //export const pushURL = '/spotify-collab-tracker';
    const redirect_uri = 'http://localhost:5000';
    const pushURL = '/';

    //******************************
    //*******AUTHENTIFICATION*******
    //******************************

    let token$1;
    let refresh;
    let expires_in;
    let refresh_interval;

    function createVerifier() {
        const v = generateRandomString();
        localStorage.setItem('verifier', v);
        return v
    }
    async function createChallenge(v) {
        const c = await challenge_from_verifier(v);
        return 'code_challenge=' + c
    }
    async function createAuthURL () {
        const prefix = 'https://accounts.spotify.com/authorize?';
        const cID = 'client_id=' + clientID;
        const response_type = 'response_type=' + 'code';
        const callback = 'redirect_uri=' + encodeURIComponent(redirect_uri);
        const code_challenge_method = 'code_challenge_method=' + 'S256';
        const s = generateRandomString();
        localStorage.setItem('state', s);
        const ps = 'state=' + s;
        const scope = 'scope=' + encodeURIComponent('playlist-read-private playlist-read-collaborative');
        const c = await createChallenge(createVerifier());
        const params = [cID, response_type, callback, c, code_challenge_method, ps, scope].join('&');
        const url = prefix + params;
        return url;
    }


    async function getAccessToken(params) {
        if (params.state != localStorage.getItem('state')) {
            return false
        } else {
            let postBody = [];
            const details = {
                'client_id' : clientID,
                'grant_type' : 'authorization_code',
                'code' : params.code,
                'redirect_uri' : redirect_uri,
                'code_verifier' : localStorage.getItem('verifier')
            };
            for (let property in details) {
                const encodedKey = encodeURIComponent(property);
                const encodedValue = encodeURIComponent(details[property]);
                postBody.push(encodedKey + '=' + encodedValue);
            }
            postBody = postBody.join('&'); 
            const endpoint = 'https://accounts.spotify.com/api/token';
            const res = await fetch(endpoint, {
                method: 'POST',
                headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                body: postBody
            });
            if (res.status != 200) {
                return false
            } else {
                const json = await res.json();
                token$1 = json.access_token;
                refresh = json.refresh_token;
                expires_in = json.expires_in*1000;
                localStorage.removeItem('verifier');
                refresh_interval = setInterval(refreshAccessToken, expires_in - (expires_in*0.1));
                return true
            }
        }
    }

    const refreshAccessToken = async function () {
        clearInterval(refresh_interval);
        console.log('Refreshing access token...');
        const endpoint = 'https://accounts.spotify.com/api/token';
        let postBody = [];
        const details = {
            'grant_type' : 'refresh_token',
            'refresh_token' : refresh,
            'client_id' : clientID
        };
        for (let property in details) {
            const encodedKey = encodeURIComponent(property);
            const encodedValue = encodeURIComponent(details[property]);
            postBody.push(encodedKey + '=' + encodedValue);
        }
        postBody = postBody.join('&');
        const res =  await fetch(endpoint, {
            method: 'POST',
            headers: {'Content-Type': 'application/x-www-form-urlencoded'},
            body: postBody
        });
        const json = await res.json();
        token$1 = json.access_token;
        refresh = json.refresh_token;
        expires_in = json.expires_in*1000;
        refresh_interval = setInterval(refreshAccessToken, expires_in - (expires_in*0.1));
    };


    //******************************
    //*********API FUNCTIONS********
    //******************************
    function authHeader (auth) {
        const header = {'Authorization' : 'Bearer ' + auth};
        return header
    }

    async function playlistRequests (auth, playlists_input) {
        let endpoint = 'https://api.spotify.com/v1/me/playlists?limit=20';
        let send = true;
        let playlists = playlists_input;
        let delta = {'update' : {}, 'remove' : {}};

        while (send) {
            const res = await fetch(endpoint, {
                method: 'GET',
                headers : authHeader(auth)
            });
            const json = await res.json();
            for (let pl of json.items) {
                const pid = pl.id;
                const psn = pl.snapshot_id;
                const pco = pl.collaborative;
                if (pco) {
                    if (!playlists.hasOwnProperty(pid)) {
                        delta.update[pid] = psn; 
                    } else {
                        if (playlists[pid] != psn) {
                            delta['update'][pid] = psn;
                        }
                        delete playlists[pid];
                    }
                }
                if (json.next != null) {
                    endpoint = json.next;
                } else {
                    send = false;
                }    
            }
        }
        delta.remove = playlists; 
        return delta
    }

    async function songRequests (auth, playlists_input) {
        let endpoint = 'https://api.spotify.com/v1/playlists/';
        const playlists = playlists_input;    
        const params = {
            market: 'from_token',
            limit : '100',
            fields : 'name,id,external_urls,tracks.items(is_local,track(duration_ms,external_urls,name,popularity,id),added_at,added_by(id,external_urls,href),track.album(external_urls,name),track.artists(external_urls,name)),tracks(limit,next,offset)'
        };
        const altparams = {
            market: 'from_token',
            limit : '100',
            fields : 'items(is_local,track(duration_ms,external_urls,name,popularity,id),added_at,added_by(id,external_urls,href),track.album(external_urls,name),track.artists(external_urls,name)),limit,next,offset'
        };

        let usernames = {};
        let results = [];

        for (let pl in playlists) {
            let send = true;
            let url = new URL(endpoint + pl);
            let current_params = params;
            let container = undefined;
            url.search = new URLSearchParams(current_params).toString();

            while (send) {
                const res = await fetch(url, {
                    method: 'GET',
                    headers : authHeader(auth)
                });
                let json = await res.json();
                if (container != undefined) {
                    container.tracks.items = json.items;
                    container.tracks.next = json.next; 
                    json = container;
                }
                for (let track of json.tracks.items) {
                    try {
                        const unix = to_unix(track.added_at);

                        const subm_id = track.added_by.id;
                        const subm_link = track.added_by.external_urls.spotify;

                        const tr_title = track.track.name;
                        const tr_link = track.track.external_urls.spotify;
                        const tr_popularity = track.track.popularity;
                        const tr_islocal = track.is_local;
                        const tr_id = track.track.id;
                        const tr_duration = track.track.duration_ms;

                        const alb_name = track.track.album.name;
                        const alb_link = track.track.album.external_urls.spotify;

                        const pl_name = json.name;
                        const pl_link = json.external_urls.spotify;
                        const pl_id = json.id;

                        let artists = [];
                        for (let artist of track.track.artists) {
                            artists.push({name : artist.name, link : artist.external_urls.spotify});
                        } 

                        if (!usernames.hasOwnProperty(subm_id)) {
                            usernames[subm_id] = await getUsername(auth, subm_id);
                        }
                        const subm_name = usernames[subm_id][0];
                        let subm_images;
                        try {
                            subm_images = usernames[subm_id][1][0];
                        } catch {
                            subm_images = null;
                        }

                        const identifier = `${unix} ${pl_id} ${tr_id}`;

                        const result = {
                            uid : identifier,
                            unix : unix,
                            subm_name : subm_name,
                            subm_id : subm_id,
                            subm_link : subm_link,
                            subm_images : subm_images,
                            song_title : tr_title,
                            song_link : tr_link,
                            song_popularity : tr_popularity,
                            song_duration : tr_duration,
                            song_islocal : tr_islocal,
                            song_id : tr_id,
                            album_name : alb_name,
                            album_link : alb_link,
                            artists : artists,
                            playlist_name : pl_name,
                            playlist_link : pl_link,
                            playlist_id : pl_id
                        };

                        results.push(result);
                    } catch {
                        //pass
                    }

                }   
                if (json.tracks.next != null) {
                    url = new URL(json.tracks.next);
                    container = json;
                    current_params = altparams;
                } else {
                    send = false;
                }
            }
        }
        return { songs : results }
    }


    async function getUsername (auth, subm_id) {
        const url = 'https://api.spotify.com/v1/users/' + subm_id;
        const res = await fetch(url, {
            method: 'GET',
            headers: authHeader(auth)
        });
        const json = await res.json();
        const output = [json.display_name, json.images];
        return output
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /*!
     * @license :jsstore - V4.2.6 - 21/06/2021
     * https://github.com/ujjwalguptaofficial/JsStore
     * Copyright (c) 2021 @Ujjwal Gupta; Licensed MIT
     */

    var jsstore_commonjs2 = createCommonjsModule(function (module) {
    module.exports =
    /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/
    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId]) {
    /******/ 			return installedModules[moduleId].exports;
    /******/ 		}
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			i: moduleId,
    /******/ 			l: false,
    /******/ 			exports: {}
    /******/ 		};
    /******/
    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ 		// Flag the module as loaded
    /******/ 		module.l = true;
    /******/
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/
    /******/
    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;
    /******/
    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;
    /******/
    /******/ 	// define getter function for harmony exports
    /******/ 	__webpack_require__.d = function(exports, name, getter) {
    /******/ 		if(!__webpack_require__.o(exports, name)) {
    /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
    /******/ 		}
    /******/ 	};
    /******/
    /******/ 	// define __esModule on exports
    /******/ 	__webpack_require__.r = function(exports) {
    /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    /******/ 		}
    /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
    /******/ 	};
    /******/
    /******/ 	// create a fake namespace object
    /******/ 	// mode & 1: value is a module id, require it
    /******/ 	// mode & 2: merge all properties of value into the ns
    /******/ 	// mode & 4: return value when already ns object
    /******/ 	// mode & 8|1: behave like require
    /******/ 	__webpack_require__.t = function(value, mode) {
    /******/ 		if(mode & 1) value = __webpack_require__(value);
    /******/ 		if(mode & 8) return value;
    /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
    /******/ 		var ns = Object.create(null);
    /******/ 		__webpack_require__.r(ns);
    /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
    /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
    /******/ 		return ns;
    /******/ 	};
    /******/
    /******/ 	// getDefaultExport function for compatibility with non-harmony modules
    /******/ 	__webpack_require__.n = function(module) {
    /******/ 		var getter = module && module.__esModule ?
    /******/ 			function getDefault() { return module['default']; } :
    /******/ 			function getModuleExports() { return module; };
    /******/ 		__webpack_require__.d(getter, 'a', getter);
    /******/ 		return getter;
    /******/ 	};
    /******/
    /******/ 	// Object.prototype.hasOwnProperty.call
    /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /******/
    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "";
    /******/
    /******/
    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(__webpack_require__.s = 2);
    /******/ })
    /************************************************************************/
    /******/ ({

    /***/ 2:
    /***/ (function(module, __webpack_exports__, __webpack_require__) {
    // ESM COMPAT FLAG
    __webpack_require__.r(__webpack_exports__);

    // EXPORTS
    __webpack_require__.d(__webpack_exports__, "Connection", function() { return /* reexport */ connection_Connection; });
    __webpack_require__.d(__webpack_exports__, "ERROR_TYPE", function() { return /* reexport */ ERROR_TYPE; });
    __webpack_require__.d(__webpack_exports__, "WORKER_STATUS", function() { return /* reexport */ WORKER_STATUS; });
    __webpack_require__.d(__webpack_exports__, "DATA_TYPE", function() { return /* reexport */ DATA_TYPE; });
    __webpack_require__.d(__webpack_exports__, "API", function() { return /* reexport */ API; });
    __webpack_require__.d(__webpack_exports__, "EVENT", function() { return /* reexport */ EVENT; });
    __webpack_require__.d(__webpack_exports__, "QUERY_OPTION", function() { return /* reexport */ QUERY_OPTION; });
    __webpack_require__.d(__webpack_exports__, "IDB_MODE", function() { return /* reexport */ IDB_MODE; });
    __webpack_require__.d(__webpack_exports__, "OCCURENCE", function() { return /* reexport */ OCCURENCE; });
    __webpack_require__.d(__webpack_exports__, "CONNECTION_STATUS", function() { return /* reexport */ CONNECTION_STATUS; });
    __webpack_require__.d(__webpack_exports__, "promise", function() { return /* reexport */ promise; });
    __webpack_require__.d(__webpack_exports__, "promiseAll", function() { return /* reexport */ promiseAll; });
    __webpack_require__.d(__webpack_exports__, "promiseResolve", function() { return /* reexport */ promiseResolve; });
    __webpack_require__.d(__webpack_exports__, "forObj", function() { return /* reexport */ forObj; });

    // CONCATENATED MODULE: ./src/main/log_helper.ts
    var LogHelper = /** @class */ (function () {
        function LogHelper(type, info) {
            this.type = type;
            this._info = info;
            this.message = this.getMsg();
        }
        LogHelper.prototype.throw = function () {
            throw this.get();
        };
        LogHelper.prototype.log = function (msg) {
            if (this.status) {
                console.log(msg);
            }
        };
        LogHelper.prototype.logError = function () {
            console.error(this.get());
        };
        LogHelper.prototype.logWarning = function () {
            console.warn(this.get());
        };
        LogHelper.prototype.get = function () {
            return {
                message: this.message,
                type: this.type
            };
        };
        LogHelper.prototype.getMsg = function () {
            var errMsg;
            switch (this.type) {
                default:
                    errMsg = this.message;
                    break;
            }
            return errMsg;
        };
        return LogHelper;
    }());


    // CONCATENATED MODULE: ./src/common/enums.ts
    var ERROR_TYPE;
    (function (ERROR_TYPE) {
        ERROR_TYPE["UndefinedColumn"] = "undefined_column";
        ERROR_TYPE["UndefinedValue"] = "undefined_value";
        ERROR_TYPE["UndefinedColumnName"] = "undefined_column_name";
        ERROR_TYPE["UndefinedDbName"] = "undefined_database_name";
        ERROR_TYPE["UndefinedColumnValue"] = "undefined_column_value";
        ERROR_TYPE["NotArray"] = "not_array";
        ERROR_TYPE["NoValueSupplied"] = "no_value_supplied";
        ERROR_TYPE["ColumnNotExist"] = "column_not_exist";
        ERROR_TYPE["EnableSearchOff"] = "enable_search_off";
        ERROR_TYPE["InvalidOp"] = "invalid_operator";
        ERROR_TYPE["NullValue"] = "null_value";
        ERROR_TYPE["WrongDataType"] = "wrong_data_type";
        ERROR_TYPE["TableNotExist"] = "table_not_exist";
        ERROR_TYPE["DbNotExist"] = "db_not_exist";
        ERROR_TYPE["ConnectionAborted"] = "connection_aborted";
        ERROR_TYPE["ConnectionClosed"] = "connection_closed";
        ERROR_TYPE["NotObject"] = "not_object";
        ERROR_TYPE["InvalidConfig"] = "invalid_config";
        ERROR_TYPE["DbBlocked"] = "Db_blocked";
        ERROR_TYPE["IndexedDbNotSupported"] = "indexeddb_not_supported";
        ERROR_TYPE["NullValueInWhere"] = "null_value_in_where";
        ERROR_TYPE["InvalidJoinQuery"] = "invalid_join_query";
        ERROR_TYPE["InvalidOrderQuery"] = "invalid_order_query";
        ERROR_TYPE["InvalidQuery"] = "invalid_query";
        ERROR_TYPE["InvalidGroupQuery"] = "invalid_group_query";
        ERROR_TYPE["ImportScriptsFailed"] = "import_scripts_failed";
        ERROR_TYPE["MethodNotExist"] = "method_not_exist";
        ERROR_TYPE["Unknown"] = "unknown";
        ERROR_TYPE["InvalidMiddleware"] = "invalid_middleware";
    })(ERROR_TYPE || (ERROR_TYPE = {}));
    var WORKER_STATUS;
    (function (WORKER_STATUS) {
        WORKER_STATUS["Registered"] = "registerd";
        WORKER_STATUS["Failed"] = "failed";
        WORKER_STATUS["NotStarted"] = "not_started";
    })(WORKER_STATUS || (WORKER_STATUS = {}));
    var DATA_TYPE;
    (function (DATA_TYPE) {
        DATA_TYPE["String"] = "string";
        DATA_TYPE["Object"] = "object";
        DATA_TYPE["Array"] = "array";
        DATA_TYPE["Number"] = "number";
        DATA_TYPE["Boolean"] = "boolean";
        DATA_TYPE["Null"] = "null";
        DATA_TYPE["DateTime"] = "date_time";
    })(DATA_TYPE || (DATA_TYPE = {}));
    var API;
    (function (API) {
        API["InitDb"] = "init_db";
        API["Get"] = "get";
        API["Set"] = "set";
        API["Select"] = "select";
        API["Insert"] = "insert";
        API["Update"] = "update";
        API["Remove"] = "remove";
        API["OpenDb"] = "open_db";
        API["Clear"] = "clear";
        API["DropDb"] = "drop_db";
        API["Count"] = "count";
        API["ChangeLogStatus"] = "change_log_status";
        API["Terminate"] = "terminate";
        API["Transaction"] = "transaction";
        API["CloseDb"] = "close_db";
        API["Union"] = "union";
        API["Intersect"] = "intersect";
        API["ImportScripts"] = "import_scripts";
        API["Middleware"] = "middleware";
    })(API || (API = {}));
    var EVENT;
    (function (EVENT) {
        EVENT["RequestQueueEmpty"] = "requestQueueEmpty";
        EVENT["RequestQueueFilled"] = "requestQueueFilled";
        EVENT["Upgrade"] = "upgrade";
        EVENT["Create"] = "create";
        EVENT["Open"] = "open";
    })(EVENT || (EVENT = {}));
    var QUERY_OPTION;
    (function (QUERY_OPTION) {
        QUERY_OPTION["Where"] = "where";
        QUERY_OPTION["Like"] = "like";
        QUERY_OPTION["Regex"] = "regex";
        QUERY_OPTION["In"] = "in";
        QUERY_OPTION["Equal"] = "=";
        QUERY_OPTION["Between"] = "-";
        QUERY_OPTION["GreaterThan"] = ">";
        QUERY_OPTION["LessThan"] = "<";
        QUERY_OPTION["GreaterThanEqualTo"] = ">=";
        QUERY_OPTION["LessThanEqualTo"] = "<=";
        QUERY_OPTION["NotEqualTo"] = "!=";
        QUERY_OPTION["Aggregate"] = "aggregate";
        QUERY_OPTION["Max"] = "max";
        QUERY_OPTION["Min"] = "min";
        QUERY_OPTION["Avg"] = "avg";
        QUERY_OPTION["Count"] = "count";
        QUERY_OPTION["Sum"] = "sum";
        QUERY_OPTION["Or"] = "or";
        QUERY_OPTION["Skip"] = "skip";
        QUERY_OPTION["Limit"] = "limit";
        QUERY_OPTION["And"] = "and";
        QUERY_OPTION["IgnoreCase"] = "ignoreCase";
        QUERY_OPTION["Then"] = "then";
    })(QUERY_OPTION || (QUERY_OPTION = {}));
    var IDB_MODE;
    (function (IDB_MODE) {
        IDB_MODE["ReadOnly"] = "readonly";
        IDB_MODE["ReadWrite"] = "readwrite";
    })(IDB_MODE || (IDB_MODE = {}));
    var OCCURENCE;
    (function (OCCURENCE) {
        OCCURENCE["First"] = "f";
        OCCURENCE["Last"] = "l";
        OCCURENCE["Any"] = "a";
    })(OCCURENCE || (OCCURENCE = {}));
    var CONNECTION_STATUS;
    (function (CONNECTION_STATUS) {
        CONNECTION_STATUS["Connected"] = "connected";
        CONNECTION_STATUS["Closed"] = "closed";
        CONNECTION_STATUS["NotStarted"] = "not_started";
        CONNECTION_STATUS["UnableToStart"] = "unable_to_start";
        CONNECTION_STATUS["ClosedByJsStore"] = "closed_by_jsstore";
    })(CONNECTION_STATUS || (CONNECTION_STATUS = {}));

    // CONCATENATED MODULE: ./src/common/utils/promise.ts
    var promise = function (cb) {
        return new Promise(cb);
    };

    // CONCATENATED MODULE: ./src/common/utils/promise_resolve.ts
    var promiseResolve = function (value) {
        return Promise.resolve(value);
    };

    // CONCATENATED MODULE: ./src/main/event_bus.ts
    var __spreadArray = function (to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    };
    var EventBus = /** @class */ (function () {
        function EventBus(ctx) {
            this._events = {};
            this._ctx = ctx;
        }
        EventBus.prototype.on = function (event, cb) {
            if (this._events[event] == null) {
                this._events[event] = [];
            }
            this._events[event].push(cb);
            return this;
        };
        EventBus.prototype.off = function (event, cb) {
            if (this._events[event]) {
                if (cb) {
                    var index = this._events[event].indexOf(cb);
                    this._events[event].splice(index, 1);
                }
                else {
                    this._events[event] = [];
                }
            }
        };
        EventBus.prototype.emit = function (event) {
            var _this = this;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var events = this._events[event] || [];
            var index = 0;
            var length = events.length;
            var results = [];
            var callMethod = function () {
                var eventCb = events[index++];
                if (eventCb) {
                    var result = eventCb.call.apply(eventCb, __spreadArray([_this._ctx], args));
                    return result && result.then ? result : Promise.resolve(result);
                }
            };
            return new Promise(function (res) {
                var checkAndCall = function () {
                    if (index < length) {
                        callMethod().then(function (result) {
                            results.push(result);
                            checkAndCall();
                        });
                    }
                    else {
                        res(results);
                    }
                };
                checkAndCall();
            });
        };
        EventBus.prototype.destroy = function () {
            this._events = null;
            this._ctx = null;
        };
        return EventBus;
    }());


    // CONCATENATED MODULE: ./src/main/connection_helper.ts



    var connection_helper_ConnectionHelper = /** @class */ (function () {
        function ConnectionHelper(worker) {
            this.isConOpened_ = false;
            this.isDbIdle_ = true;
            this.requestQueue_ = [];
            this.isCodeExecuting_ = false;
            this.inactivityTimer_ = -1000;
            this.middlewares = [];
            this.eventBus_ = new EventBus(this);
            // these apis have special permissions. These apis dont wait for database open.
            this.whiteListApi_ = [
                API.InitDb,
                API.OpenDb,
                API.Get,
                API.Set,
                API.ChangeLogStatus,
                API.Terminate,
                API.DropDb
            ];
            this.isRuningInWorker = true;
            this.logger = new LogHelper(null);
            if (worker) {
                this.worker_ = worker;
                this.worker_.onmessage = this.onMessageFromWorker_.bind(this);
            }
            else {
                this.isRuningInWorker = false;
                this.initQueryManager_();
            }
        }
        Object.defineProperty(ConnectionHelper.prototype, "jsstoreWorker", {
            get: function () {
                return this.$worker || self['JsStoreWorker'];
            },
            enumerable: false,
            configurable: true
        });
        ConnectionHelper.prototype.initQueryManager_ = function () {
            var workerRef = this.jsstoreWorker;
            if (workerRef) {
                this.queryManager = new workerRef.QueryManager(this.processFinishedQuery_.bind(this));
            }
        };
        ConnectionHelper.prototype.onMessageFromWorker_ = function (msg) {
            this.processFinishedQuery_(msg.data);
        };
        ConnectionHelper.prototype.processFinishedQuery_ = function (message) {
            var finishedRequest = this.requestQueue_.shift();
            if (finishedRequest) {
                this.logger.log("request " + finishedRequest.name + " finished");
                if (message.error) {
                    finishedRequest.onError(message.error);
                }
                else {
                    switch (finishedRequest.name) {
                        case API.OpenDb:
                        case API.InitDb:
                            this.isConOpened_ = true;
                            break;
                        case API.Terminate:
                            this.isConOpened_ = false;
                            if (this.isRuningInWorker === true) {
                                this.worker_.terminate();
                            }
                        case API.DropDb:
                            this.isConOpened_ = false;
                            this.requestQueue_ = [];
                            this.isDbIdle_ = true;
                            break;
                        case API.CloseDb:
                            if (this.requestQueue_.length > 0) {
                                this.openDb_();
                            }
                            else {
                                this.isDbIdle_ = true;
                                this.eventBus_.emit(EVENT.RequestQueueEmpty, []);
                            }
                            break;
                    }
                    finishedRequest.onSuccess(message.result);
                }
                this.isCodeExecuting_ = false;
                this.executeQry_();
            }
        };
        ConnectionHelper.prototype.openDb_ = function () {
            this.prcoessExecutionOfQry_({
                name: API.OpenDb,
                query: {
                    name: this.database.name,
                    version: this.database.version
                },
                onSuccess: function () {
                },
                onError: function (err) {
                    console.error(err);
                }
            }, 0);
        };
        ConnectionHelper.prototype.executeMiddleware_ = function (input) {
            var _this = this;
            return promise(function (res) {
                var index = 0;
                var lastIndex = _this.middlewares.length - 1;
                var callNextMiddleware = function () {
                    if (index <= lastIndex) {
                        var promiseResult = _this.middlewares[index++](input);
                        if (!promiseResult || !promiseResult.then) {
                            promiseResult = promiseResolve(promiseResult);
                        }
                        promiseResult.then(function (_) {
                            callNextMiddleware();
                        });
                    }
                    else {
                        res();
                    }
                };
                callNextMiddleware();
            });
        };
        ConnectionHelper.prototype.callResultMiddleware = function (middlewares, result) {
            return promise(function (res) {
                var index = 0;
                var lastIndex = middlewares.length - 1;
                var callNextMiddleware = function () {
                    if (index <= lastIndex) {
                        var promiseResult = middlewares[index++](result);
                        if (!promiseResult.then) {
                            promiseResult = promiseResolve(promiseResult);
                        }
                        promiseResult.then(function (modifiedResult) {
                            result = modifiedResult;
                            callNextMiddleware();
                        });
                    }
                    else {
                        res(result);
                    }
                };
                callNextMiddleware();
            });
        };
        ConnectionHelper.prototype.pushApi = function (request) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var middlewares = [];
                request.onResult = function (cb) {
                    middlewares.push(function (result) {
                        return cb(result);
                    });
                };
                _this.executeMiddleware_(request).then(function () {
                    request.onSuccess = function (result) {
                        _this.callResultMiddleware(middlewares, result).then(function (modifiedResult) {
                            resolve(modifiedResult);
                        }).catch(function (err) {
                            request.onError(err);
                        });
                    };
                    request.onError = function (err) {
                        middlewares = [];
                        reject(err);
                    };
                    if (_this.requestQueue_.length === 0) {
                        _this.eventBus_.emit(EVENT.RequestQueueFilled, []);
                        var isConnectionApi = [API.CloseDb, API.DropDb, API.OpenDb, API.Terminate].indexOf(request.name) >= 0;
                        if (!isConnectionApi && _this.isDbIdle_ && _this.isConOpened_) {
                            _this.openDb_();
                        }
                        else {
                            clearTimeout(_this.inactivityTimer_);
                        }
                    }
                    _this.prcoessExecutionOfQry_(request);
                }).catch(reject);
            });
        };
        ConnectionHelper.prototype.prcoessExecutionOfQry_ = function (request, index) {
            this.isDbIdle_ = false;
            if (index != null) {
                this.requestQueue_.splice(index, 0, request);
            }
            else {
                this.requestQueue_.push(request);
            }
            this.logger.log("request pushed: " + request.name);
            this.executeQry_();
        };
        ConnectionHelper.prototype.executeQry_ = function () {
            var _this = this;
            var requestQueueLength = this.requestQueue_.length;
            if (!this.isCodeExecuting_ && requestQueueLength > 0) {
                if (this.isConOpened_ === true) {
                    this.sendRequestToWorker_(this.requestQueue_[0]);
                    return;
                }
                var allowedQueryIndex = this.requestQueue_.findIndex(function (item) { return _this.whiteListApi_.indexOf(item.name) >= 0; });
                // shift allowed query to zeroth index
                if (allowedQueryIndex >= 0) {
                    this.requestQueue_.splice(0, 0, this.requestQueue_.splice(allowedQueryIndex, 1)[0]);
                    this.sendRequestToWorker_(this.requestQueue_[0]);
                }
            }
            else if (requestQueueLength === 0 && this.isDbIdle_ === false && this.isConOpened_) {
                this.inactivityTimer_ = setTimeout(function () {
                    _this.prcoessExecutionOfQry_({
                        name: API.CloseDb,
                        onSuccess: function () {
                        },
                        onError: function (err) {
                            console.error(err);
                        }
                    });
                }, 100);
            }
        };
        ConnectionHelper.prototype.sendRequestToWorker_ = function (request) {
            this.isCodeExecuting_ = true;
            this.logger.log("request executing: " + request.name);
            var requestForWorker = {
                name: request.name,
                query: request.query
            };
            if (this.isRuningInWorker === true) {
                this.worker_.postMessage(requestForWorker);
            }
            else {
                this.queryManager.run(requestForWorker);
            }
        };
        return ConnectionHelper;
    }());


    // CONCATENATED MODULE: ./src/main/connection.ts
    var __extends = (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();


    var connection_Connection = /** @class */ (function (_super) {
        __extends(Connection, _super);
        function Connection(worker) {
            return _super.call(this, worker) || this;
        }
        /**
         * initiate DataBase
         *
         * @param {IDataBase} dataBase
         * @returns
         * @memberof Connection
         */
        Connection.prototype.initDb = function (dataBase) {
            var _this = this;
            this.database = dataBase;
            return this.pushApi({
                name: API.InitDb,
                query: dataBase
            }).then(function (result) {
                var promiseObj;
                var db = result.database;
                if (result.isCreated) {
                    if (result.oldVersion) {
                        promiseObj = _this.eventBus_.emit(EVENT.Upgrade, db, result.oldVersion, result.newVersion);
                    }
                    else {
                        promiseObj = _this.eventBus_.emit(EVENT.Create, db);
                    }
                }
                return (promiseObj || promiseResolve()).then(function (_) {
                    return _this.eventBus_.emit(EVENT.Open, db);
                }).then(function (_) {
                    return result.isCreated;
                });
            });
        };
        /**
         * drop dataBase
         *
         * @returns
         * @memberof Connection
         */
        Connection.prototype.dropDb = function () {
            return this.pushApi({
                name: API.DropDb
            });
        };
        /**
         * select data from table
         *
         * @template T
         * @param {ISelectQuery} query
         * @returns
         * @memberof Connection
         */
        Connection.prototype.select = function (query) {
            return this.pushApi({
                name: API.Select,
                query: query
            });
        };
        /**
         * get no of record from table
         *
         * @param {ICountQuery} query
         * @returns
         * @memberof Connection
         */
        Connection.prototype.count = function (query) {
            return this.pushApi({
                name: API.Count,
                query: query
            });
        };
        /**
         * insert data into table
         *
         * @template T
         * @param {IInsertQuery} query
         * @returns
         * @memberof Connection
         */
        Connection.prototype.insert = function (query) {
            return this.pushApi({
                name: API.Insert,
                query: query
            });
        };
        /**
         * update data into table
         *
         * @param {IUpdateQuery} query
         * @returns
         * @memberof Connection
         */
        Connection.prototype.update = function (query) {
            return this.pushApi({
                name: API.Update,
                query: query
            });
        };
        /**
         * remove data from table
         *
         * @param {IRemoveQuery} query
         * @returns
         * @memberof Connection
         */
        Connection.prototype.remove = function (query) {
            return this.pushApi({
                name: API.Remove,
                query: query
            });
        };
        /**
         * delete all data from table
         *
         * @param {string} tableName
         * @returns
         * @memberof Connection
         */
        Connection.prototype.clear = function (tableName) {
            return this.pushApi({
                name: API.Clear,
                query: tableName
            });
        };
        Object.defineProperty(Connection.prototype, "logStatus", {
            /**
             * set log status
             *
             * @param {boolean} status
             * @memberof Connection
             */
            set: function (status) {
                this.logger.status = status;
                this.pushApi({
                    name: API.ChangeLogStatus,
                    query: status
                });
            },
            enumerable: false,
            configurable: true
        });
        /**
         * open database
         *
         * @param {string} dbName
         * @returns
         * @memberof Connection
         */
        Connection.prototype.openDb = function (dbName, version) {
            var _this = this;
            return this.pushApi({
                name: API.OpenDb,
                query: {
                    version: version,
                    name: dbName
                }
            }).then(function (dataBase) {
                _this.database = dataBase;
                return dataBase;
            });
        };
        /**
         * returns list of database created
         *
         * @returns
         * @memberof Connection
         */
        Connection.prototype.getDbList = function () {
            console.warn("Api getDbList is recommended to use for debugging only. Do not use in code.");
            return indexedDB.databases();
        };
        /**
         * get the value from keystore table
         *
         * @template T
         * @param {string} key
         * @returns
         * @memberof Connection
         */
        Connection.prototype.get = function (key) {
            return this.pushApi({
                name: API.Get,
                query: key
            });
        };
        /**
         * set the value in keystore table
         *
         * @param {string} key
         * @param {*} value
         * @returns
         * @memberof Connection
         */
        Connection.prototype.set = function (key, value) {
            return this.pushApi({
                name: API.Set,
                query: {
                    key: key, value: value
                }
            });
        };
        /**
         * terminate the connection
         *
         * @returns
         * @memberof Connection
         */
        Connection.prototype.terminate = function () {
            return this.pushApi({
                name: API.Terminate
            });
        };
        /**
         * execute transaction
         *
         * @template T
         * @param {ITranscationQuery} query
         * @returns
         * @memberof Connection
         */
        Connection.prototype.transaction = function (query) {
            return this.pushApi({
                name: API.Transaction,
                query: query
            });
        };
        Connection.prototype.on = function (event, eventCallBack) {
            this.eventBus_.on(event, eventCallBack);
        };
        Connection.prototype.off = function (event, eventCallBack) {
            this.eventBus_.off(event, eventCallBack);
        };
        Connection.prototype.union = function (query) {
            return this.pushApi({
                name: API.Union,
                query: query
            });
        };
        Connection.prototype.intersect = function (query) {
            return this.pushApi({
                name: API.Intersect,
                query: query
            });
        };
        Connection.prototype.addPlugin = function (plugin, params) {
            return plugin.setup(this, params);
        };
        Connection.prototype.addMiddleware = function (middleware, forWorker) {
            if (forWorker) {
                return this.pushApi({
                    name: API.Middleware,
                    query: middleware
                });
            }
            this.middlewares.push(middleware);
            return Promise.resolve();
        };
        /**
         * import scripts in jsstore web worker.
         * Scripts method can be called using transaction api.
         *
         * @param {...string[]} urls
         * @returns
         * @memberof Connection
         */
        Connection.prototype.importScripts = function () {
            var urls = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                urls[_i] = arguments[_i];
            }
            return this.pushApi({
                name: API.ImportScripts,
                query: urls
            });
        };
        return Connection;
    }(connection_helper_ConnectionHelper));


    // CONCATENATED MODULE: ./src/common/utils/promise_all.ts
    var promiseAll = function (promises) {
        return Promise.all(promises);
    };

    // CONCATENATED MODULE: ./src/common/utils/for_obj.ts
    var forObj = function (obj, cb) {
        for (var key in obj) {
            cb(key, obj[key]);
        }
    };

    // CONCATENATED MODULE: ./src/common/utils/index.ts





    // CONCATENATED MODULE: ./src/common/index.ts





    // CONCATENATED MODULE: ./src/main/index.ts




    /***/ })

    /******/ });

    });

    var npm_export = createCommonjsModule(function (module) {
    {
        module.exports = jsstore_commonjs2;
    }
    });

    /*!
     * @license :jsstore - V4.2.6 - 21/06/2021
     * https://github.com/ujjwalguptaofficial/JsStore
     * Copyright (c) 2021 @Ujjwal Gupta; Licensed MIT
     */

    var jsstore_worker_commonjs2 = createCommonjsModule(function (module) {
    module.exports =
    /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/
    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId]) {
    /******/ 			return installedModules[moduleId].exports;
    /******/ 		}
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			i: moduleId,
    /******/ 			l: false,
    /******/ 			exports: {}
    /******/ 		};
    /******/
    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ 		// Flag the module as loaded
    /******/ 		module.l = true;
    /******/
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/
    /******/
    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;
    /******/
    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;
    /******/
    /******/ 	// define getter function for harmony exports
    /******/ 	__webpack_require__.d = function(exports, name, getter) {
    /******/ 		if(!__webpack_require__.o(exports, name)) {
    /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
    /******/ 		}
    /******/ 	};
    /******/
    /******/ 	// define __esModule on exports
    /******/ 	__webpack_require__.r = function(exports) {
    /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    /******/ 		}
    /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
    /******/ 	};
    /******/
    /******/ 	// create a fake namespace object
    /******/ 	// mode & 1: value is a module id, require it
    /******/ 	// mode & 2: merge all properties of value into the ns
    /******/ 	// mode & 4: return value when already ns object
    /******/ 	// mode & 8|1: behave like require
    /******/ 	__webpack_require__.t = function(value, mode) {
    /******/ 		if(mode & 1) value = __webpack_require__(value);
    /******/ 		if(mode & 8) return value;
    /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
    /******/ 		var ns = Object.create(null);
    /******/ 		__webpack_require__.r(ns);
    /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
    /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
    /******/ 		return ns;
    /******/ 	};
    /******/
    /******/ 	// getDefaultExport function for compatibility with non-harmony modules
    /******/ 	__webpack_require__.n = function(module) {
    /******/ 		var getter = module && module.__esModule ?
    /******/ 			function getDefault() { return module['default']; } :
    /******/ 			function getModuleExports() { return module; };
    /******/ 		__webpack_require__.d(getter, 'a', getter);
    /******/ 		return getter;
    /******/ 	};
    /******/
    /******/ 	// Object.prototype.hasOwnProperty.call
    /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /******/
    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "";
    /******/
    /******/
    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(__webpack_require__.s = 2);
    /******/ })
    /************************************************************************/
    /******/ ({

    /***/ 2:
    /***/ (function(module, __webpack_exports__, __webpack_require__) {
    // ESM COMPAT FLAG
    __webpack_require__.r(__webpack_exports__);

    // EXPORTS
    __webpack_require__.d(__webpack_exports__, "QueryManager", function() { return /* reexport */ query_manager_QueryManager; });

    // CONCATENATED MODULE: ./src/common/utils/promise_resolve.ts
    var promiseResolve = function (value) {
        return Promise.resolve(value);
    };

    // CONCATENATED MODULE: ./src/common/utils/promise.ts
    var promise = function (cb) {
        return new Promise(cb);
    };

    // CONCATENATED MODULE: ./src/common/enums.ts
    var ERROR_TYPE;
    (function (ERROR_TYPE) {
        ERROR_TYPE["UndefinedColumn"] = "undefined_column";
        ERROR_TYPE["UndefinedValue"] = "undefined_value";
        ERROR_TYPE["UndefinedColumnName"] = "undefined_column_name";
        ERROR_TYPE["UndefinedDbName"] = "undefined_database_name";
        ERROR_TYPE["UndefinedColumnValue"] = "undefined_column_value";
        ERROR_TYPE["NotArray"] = "not_array";
        ERROR_TYPE["NoValueSupplied"] = "no_value_supplied";
        ERROR_TYPE["ColumnNotExist"] = "column_not_exist";
        ERROR_TYPE["EnableSearchOff"] = "enable_search_off";
        ERROR_TYPE["InvalidOp"] = "invalid_operator";
        ERROR_TYPE["NullValue"] = "null_value";
        ERROR_TYPE["WrongDataType"] = "wrong_data_type";
        ERROR_TYPE["TableNotExist"] = "table_not_exist";
        ERROR_TYPE["DbNotExist"] = "db_not_exist";
        ERROR_TYPE["ConnectionAborted"] = "connection_aborted";
        ERROR_TYPE["ConnectionClosed"] = "connection_closed";
        ERROR_TYPE["NotObject"] = "not_object";
        ERROR_TYPE["InvalidConfig"] = "invalid_config";
        ERROR_TYPE["DbBlocked"] = "Db_blocked";
        ERROR_TYPE["IndexedDbNotSupported"] = "indexeddb_not_supported";
        ERROR_TYPE["NullValueInWhere"] = "null_value_in_where";
        ERROR_TYPE["InvalidJoinQuery"] = "invalid_join_query";
        ERROR_TYPE["InvalidOrderQuery"] = "invalid_order_query";
        ERROR_TYPE["InvalidQuery"] = "invalid_query";
        ERROR_TYPE["InvalidGroupQuery"] = "invalid_group_query";
        ERROR_TYPE["ImportScriptsFailed"] = "import_scripts_failed";
        ERROR_TYPE["MethodNotExist"] = "method_not_exist";
        ERROR_TYPE["Unknown"] = "unknown";
        ERROR_TYPE["InvalidMiddleware"] = "invalid_middleware";
    })(ERROR_TYPE || (ERROR_TYPE = {}));
    var WORKER_STATUS;
    (function (WORKER_STATUS) {
        WORKER_STATUS["Registered"] = "registerd";
        WORKER_STATUS["Failed"] = "failed";
        WORKER_STATUS["NotStarted"] = "not_started";
    })(WORKER_STATUS || (WORKER_STATUS = {}));
    var DATA_TYPE;
    (function (DATA_TYPE) {
        DATA_TYPE["String"] = "string";
        DATA_TYPE["Object"] = "object";
        DATA_TYPE["Array"] = "array";
        DATA_TYPE["Number"] = "number";
        DATA_TYPE["Boolean"] = "boolean";
        DATA_TYPE["Null"] = "null";
        DATA_TYPE["DateTime"] = "date_time";
    })(DATA_TYPE || (DATA_TYPE = {}));
    var API;
    (function (API) {
        API["InitDb"] = "init_db";
        API["Get"] = "get";
        API["Set"] = "set";
        API["Select"] = "select";
        API["Insert"] = "insert";
        API["Update"] = "update";
        API["Remove"] = "remove";
        API["OpenDb"] = "open_db";
        API["Clear"] = "clear";
        API["DropDb"] = "drop_db";
        API["Count"] = "count";
        API["ChangeLogStatus"] = "change_log_status";
        API["Terminate"] = "terminate";
        API["Transaction"] = "transaction";
        API["CloseDb"] = "close_db";
        API["Union"] = "union";
        API["Intersect"] = "intersect";
        API["ImportScripts"] = "import_scripts";
        API["Middleware"] = "middleware";
    })(API || (API = {}));
    var EVENT;
    (function (EVENT) {
        EVENT["RequestQueueEmpty"] = "requestQueueEmpty";
        EVENT["RequestQueueFilled"] = "requestQueueFilled";
        EVENT["Upgrade"] = "upgrade";
        EVENT["Create"] = "create";
        EVENT["Open"] = "open";
    })(EVENT || (EVENT = {}));
    var QUERY_OPTION;
    (function (QUERY_OPTION) {
        QUERY_OPTION["Where"] = "where";
        QUERY_OPTION["Like"] = "like";
        QUERY_OPTION["Regex"] = "regex";
        QUERY_OPTION["In"] = "in";
        QUERY_OPTION["Equal"] = "=";
        QUERY_OPTION["Between"] = "-";
        QUERY_OPTION["GreaterThan"] = ">";
        QUERY_OPTION["LessThan"] = "<";
        QUERY_OPTION["GreaterThanEqualTo"] = ">=";
        QUERY_OPTION["LessThanEqualTo"] = "<=";
        QUERY_OPTION["NotEqualTo"] = "!=";
        QUERY_OPTION["Aggregate"] = "aggregate";
        QUERY_OPTION["Max"] = "max";
        QUERY_OPTION["Min"] = "min";
        QUERY_OPTION["Avg"] = "avg";
        QUERY_OPTION["Count"] = "count";
        QUERY_OPTION["Sum"] = "sum";
        QUERY_OPTION["Or"] = "or";
        QUERY_OPTION["Skip"] = "skip";
        QUERY_OPTION["Limit"] = "limit";
        QUERY_OPTION["And"] = "and";
        QUERY_OPTION["IgnoreCase"] = "ignoreCase";
        QUERY_OPTION["Then"] = "then";
    })(QUERY_OPTION || (QUERY_OPTION = {}));
    var IDB_MODE;
    (function (IDB_MODE) {
        IDB_MODE["ReadOnly"] = "readonly";
        IDB_MODE["ReadWrite"] = "readwrite";
    })(IDB_MODE || (IDB_MODE = {}));
    var OCCURENCE;
    (function (OCCURENCE) {
        OCCURENCE["First"] = "f";
        OCCURENCE["Last"] = "l";
        OCCURENCE["Any"] = "a";
    })(OCCURENCE || (OCCURENCE = {}));
    var CONNECTION_STATUS;
    (function (CONNECTION_STATUS) {
        CONNECTION_STATUS["Connected"] = "connected";
        CONNECTION_STATUS["Closed"] = "closed";
        CONNECTION_STATUS["NotStarted"] = "not_started";
        CONNECTION_STATUS["UnableToStart"] = "unable_to_start";
        CONNECTION_STATUS["ClosedByJsStore"] = "closed_by_jsstore";
    })(CONNECTION_STATUS || (CONNECTION_STATUS = {}));

    // CONCATENATED MODULE: ./src/worker/model/table_meta.ts
    var TableMeta = /** @class */ (function () {
        function TableMeta(table) {
            this.columns = [];
            this.autoIncColumnValue = {};
            this.columns = this.setColumn(table.columns);
            this.name = table.name;
            this.alter = table.alter || {};
        }
        TableMeta.prototype.setColumn = function (tableColumns) {
            var columns = [];
            var _loop_1 = function (columnName) {
                var column = tableColumns[columnName];
                column.name = columnName;
                if (column.autoIncrement) {
                    this_1.autoIncColumnValue[columnName] = 0;
                }
                if (column.primaryKey) {
                    this_1.primaryKey = columnName;
                }
                column.enableSearch = column.enableSearch == null ? true : column.enableSearch;
                var existingColumnIndex = this_1.columns.indexOf(function (q) { return q.name === columnName; });
                if (existingColumnIndex < 0) {
                    columns.push(column);
                }
                else {
                    var existingColumn = this_1.columns[existingColumnIndex];
                    Object.assign(existingColumn, column);
                }
            };
            var this_1 = this;
            for (var columnName in tableColumns) {
                _loop_1(columnName);
            }
            return columns;
        };
        return TableMeta;
    }());


    // CONCATENATED MODULE: ./src/worker/meta_helper.ts

    var meta_helper_MetaHelper = /** @class */ (function () {
        function MetaHelper() {
        }
        MetaHelper.autoIncrementKey = function (tableName, columnName) {
            return "JsStore_" + tableName + "_" + columnName + "_Value";
        };
        MetaHelper.set = function (key, value, util) {
            if (!util.tx) {
                util.createTransaction([MetaHelper.tableName]);
            }
            var store = util.objectStore(MetaHelper.tableName);
            return promise(function (res, rej) {
                var req = store.put({
                    key: key, value: value
                });
                req.onsuccess = function () {
                    res();
                };
                req.onerror = rej;
            });
        };
        MetaHelper.get = function (key, util) {
            if (!util.tx) {
                util.createTransaction([MetaHelper.tableName]);
            }
            var store = util.objectStore(MetaHelper.tableName);
            return promise(function (res, rej) {
                var req = store.get(util.keyRange(key));
                req.onsuccess = function () {
                    var result = req.result;
                    res(result && result.value);
                };
                req.onerror = rej;
            });
        };
        MetaHelper.remove = function (key, util) {
            if (!util.tx) {
                util.createTransaction([MetaHelper.tableName]);
            }
            var store = util.objectStore(MetaHelper.tableName);
            return promise(function (res, rej) {
                var req = store.delete(util.keyRange(key));
                req.onsuccess = res;
                req.onerror = rej;
            });
        };
        MetaHelper.tableName = "JsStore_Meta";
        MetaHelper.dbSchema = "JsStore_DbSchema";
        return MetaHelper;
    }());


    // CONCATENATED MODULE: ./src/worker/model/db_meta.ts


    var db_meta_DbMeta = /** @class */ (function () {
        function DbMeta(db) {
            this.name = db.name;
            this.version = db.version || 1;
            db.tables.push({
                name: meta_helper_MetaHelper.tableName,
                columns: {
                    key: {
                        primaryKey: true
                    },
                    value: {
                        enableSearch: false
                    }
                },
            });
            this.tables = db.tables.map(function (table) {
                return new TableMeta(table);
            });
        }
        return DbMeta;
    }());


    // CONCATENATED MODULE: ./src/common/utils/for_obj.ts
    var forObj = function (obj, cb) {
        for (var key in obj) {
            cb(key, obj[key]);
        }
    };

    // CONCATENATED MODULE: ./src/worker/utils/log_helper.ts

    var log_helper_LogHelper = /** @class */ (function () {
        function LogHelper(type, info) {
            this.type = type;
            this.info_ = info;
            this.message = this.getMsg_();
        }
        LogHelper.prototype.log = function (msg) {
            if (this.status) {
                console.log(msg);
            }
        };
        LogHelper.prototype.throw = function () {
            throw this.get();
        };
        LogHelper.prototype.logError = function () {
            console.error(this.get());
        };
        LogHelper.prototype.get = function () {
            return {
                message: this.message,
                type: this.type
            };
        };
        LogHelper.prototype.getMsg_ = function () {
            var errMsg;
            switch (this.type) {
                case ERROR_TYPE.NotArray:
                    errMsg = "Supplied value is not an array";
                    break;
                case ERROR_TYPE.UndefinedColumn:
                    errMsg = "Column is undefined in Where";
                    break;
                case ERROR_TYPE.UndefinedValue:
                    errMsg = "Value is undefined in Where";
                    break;
                case ERROR_TYPE.UndefinedColumnName:
                    errMsg = "Column name is undefined '" + this.info_['TableName'] + "'";
                    break;
                case ERROR_TYPE.UndefinedDbName:
                    errMsg = "Database name is not supplied";
                    break;
                case ERROR_TYPE.UndefinedColumnValue:
                    errMsg = "Column value is undefined";
                    break;
                case ERROR_TYPE.NoValueSupplied:
                    errMsg = "No value is supplied";
                    break;
                case ERROR_TYPE.InvalidOp:
                    errMsg = "Invalid Op Value '" + this.info_['Op'] + "'";
                    break;
                case ERROR_TYPE.ColumnNotExist:
                    errMsg = this.info_['isOrder'] ?
                        "Column '" + this.info_['column'] + "' in order query does not exist" :
                        "Column '" + this.info_['column'] + "' does not exist";
                    break;
                case ERROR_TYPE.EnableSearchOff:
                    errMsg = "Search is turned off for the Column '" + this.info_['column'] + "'";
                    break;
                case ERROR_TYPE.NullValue:
                    errMsg = "Null value is not allowed for column '" + this.info_['ColumnName'] + "'";
                    break;
                case ERROR_TYPE.WrongDataType:
                    errMsg = "Supplied value for column '" + this.info_['column'] +
                        "' have wrong data type";
                    break;
                case ERROR_TYPE.TableNotExist:
                    errMsg = "Table '" + this.info_['tableName'] + "' does not exist";
                    break;
                case ERROR_TYPE.DbNotExist:
                    errMsg = "Database with name " + this.info_['dbName'] + " does not exist";
                    break;
                case ERROR_TYPE.NotObject:
                    errMsg = "supplied value is not object";
                    break;
                case ERROR_TYPE.InvalidOp:
                    errMsg = "Invalid Config '" + this.info_['Config'] + " '";
                    break;
                case ERROR_TYPE.DbBlocked:
                    errMsg = "database is blocked, cant be deleted right now";
                    break;
                case ERROR_TYPE.NullValueInWhere:
                    errMsg = "Null/undefined is not allowed in where. Column '" + this.info_['column'] + "' has null";
                    break;
                case ERROR_TYPE.MethodNotExist:
                    errMsg = "method " + this.info_ + " does not exist.";
                    break;
                case ERROR_TYPE.IndexedDbNotSupported:
                    errMsg = "Browser does not support indexeddb";
                    break;
                case ERROR_TYPE.InvalidJoinQuery:
                case ERROR_TYPE.InvalidGroupQuery:
                case ERROR_TYPE.InvalidOrderQuery:
                case ERROR_TYPE.ImportScriptsFailed:
                    errMsg = this.info_;
                    break;
                case ERROR_TYPE.InvalidMiddleware:
                    errMsg = "No function " + this.info_ + " is found.";
                    break;
                default:
                    if (!this.type) {
                        this.type = ERROR_TYPE.Unknown;
                    }
                    errMsg = this.message;
                    break;
            }
            return errMsg;
        };
        return LogHelper;
    }());


    // CONCATENATED MODULE: ./src/worker/idbutil/index.ts


    var idbutil_IDBUtil = /** @class */ (function () {
        function IDBUtil() {
            this.logger = new log_helper_LogHelper(null);
        }
        IDBUtil.prototype.emptyTx = function () {
            if (!this.tx)
                return;
            this.tx.oncomplete = null;
            this.tx.onabort = null;
            this.tx.onerror = null;
            this.tx = null;
        };
        IDBUtil.prototype.createTransactionIfNotExist = function (tables, mode) {
            if (!this.tx) {
                this.createTransaction(tables, mode);
            }
        };
        IDBUtil.prototype.createTransaction = function (tables, mode) {
            var _this = this;
            if (mode === void 0) { mode = IDB_MODE.ReadWrite; }
            this.tx = this.con.transaction(tables, mode);
            return promise(function (res, rej) {
                _this.tx.oncomplete = res;
                _this.tx.onabort = res;
                _this.tx.onerror = rej;
            });
        };
        IDBUtil.prototype.keyRange = function (value, op) {
            var keyRange;
            switch (op) {
                case QUERY_OPTION.Between:
                    keyRange = IDBKeyRange.bound(value.low, value.high, false, false);
                    break;
                case QUERY_OPTION.GreaterThan:
                    keyRange = IDBKeyRange.lowerBound(value, true);
                    break;
                case QUERY_OPTION.GreaterThanEqualTo:
                    keyRange = IDBKeyRange.lowerBound(value);
                    break;
                case QUERY_OPTION.LessThan:
                    keyRange = IDBKeyRange.upperBound(value, true);
                    break;
                case QUERY_OPTION.LessThanEqualTo:
                    keyRange = IDBKeyRange.upperBound(value);
                    break;
                default:
                    keyRange = IDBKeyRange.only(value);
                    break;
            }
            return keyRange;
        };
        IDBUtil.prototype.objectStore = function (name) {
            return this.tx.objectStore(name);
        };
        IDBUtil.prototype.abortTransaction = function () {
            if (this.tx) {
                this.tx.abort();
            }
        };
        IDBUtil.prototype.close = function () {
            var _this = this;
            if (this.con) {
                this.con.close();
            }
            // wait for 100 ms before success
            return promise(function (res) {
                _this.con = null;
                setTimeout(res, 100);
            });
        };
        IDBUtil.prototype.initDb = function (db) {
            var _this = this;
            this.db = db;
            var isDbCreated = false;
            var dbVersion = db.version;
            var oldVersion;
            var initLogic = function (res, rej) {
                var dbOpenRequest = indexedDB.open(db.name, dbVersion);
                dbOpenRequest.onsuccess = function () {
                    _this.con = dbOpenRequest.result;
                    _this.con.onversionchange = function (e) {
                        // if (e.newVersion === null) { // An attempt is made to delete the db
                        e.target.close(); // Manually close our connection to the db
                        // }
                    };
                    res({
                        isCreated: isDbCreated,
                        oldVersion: oldVersion,
                        newVersion: dbVersion
                    });
                };
                dbOpenRequest.onerror = function (e) {
                    console.error("error", e);
                    rej(e);
                };
                dbOpenRequest.onupgradeneeded = function (e) {
                    oldVersion = e.oldVersion;
                    var target = e.target;
                    var upgradeConnection = target.result;
                    isDbCreated = true;
                    var transaction = target.transaction;
                    var storeNames = upgradeConnection.objectStoreNames;
                    var createObjectStore = function (table) {
                        var option = table.primaryKey ? {
                            keyPath: table.primaryKey
                        } : {
                            autoIncrement: true
                        };
                        var store = upgradeConnection.createObjectStore(table.name, option);
                        table.columns.forEach(function (column) {
                            addColumn(store, column);
                        });
                    };
                    var addColumn = function (store, column) {
                        if (column.enableSearch) {
                            var columnName = column.name;
                            var options = column.primaryKey ? { unique: true } : { unique: column.unique };
                            options['multiEntry'] = column.multiEntry;
                            var keyPath = column.keyPath == null ? columnName : column.keyPath;
                            store.createIndex(columnName, keyPath, options);
                        }
                    };
                    var deleteColumn = function (store, table, columnName) {
                        var index = table.columns.findIndex(function (q) { return q.name === columnName; });
                        if (index >= 0) {
                            table.columns.splice(index, 1);
                            store.deleteIndex(columnName);
                        }
                    };
                    db.tables.forEach(function (table) {
                        if (!storeNames.contains(table.name)) {
                            return createObjectStore(table);
                        }
                        var store = transaction.objectStore(table.name);
                        for (var i = oldVersion; i <= dbVersion; i++) {
                            var alterQuery = table.alter[i];
                            if (alterQuery) {
                                if (alterQuery.add) {
                                    var newColumns = table.setColumn(alterQuery.add);
                                    newColumns.forEach(function (column) {
                                        addColumn(store, column);
                                        table.columns.push(column);
                                    });
                                }
                                forObj(alterQuery.drop || {}, (function (columnName) {
                                    deleteColumn(store, table, columnName);
                                }));
                                forObj(alterQuery.modify || {}, (function (columnName, column) {
                                    var shouldDelete = column.multiEntry || column.keyPath || column.unique;
                                    var targetColumn = table.columns.find(function (q) { return q.name === columnName; });
                                    var newColumn = Object.assign(targetColumn, column);
                                    newColumn.name = columnName;
                                    if (shouldDelete) {
                                        deleteColumn(store, table, columnName);
                                        addColumn(store, newColumn);
                                        table.columns.push(newColumn);
                                    }
                                }));
                            }
                        }
                    });
                };
            };
            return promise(initLogic);
        };
        return IDBUtil;
    }());


    // CONCATENATED MODULE: ./src/common/utils/promise_all.ts
    var promiseAll = function (promises) {
        return Promise.all(promises);
    };

    // CONCATENATED MODULE: ./src/worker/utils/promise_reject.ts
    var promiseReject = function (value) {
        return Promise.reject(value);
    };

    // CONCATENATED MODULE: ./src/worker/utils/get_error.ts

    var getError = function (e) {
        var customError = e instanceof log_helper_LogHelper;
        if (customError) {
            e.logError();
            return e.get();
        }
        else {
            var error = void 0;
            if (e.name) {
                error = new log_helper_LogHelper(e.name);
                error.message = e.message;
            }
            else {
                error = new log_helper_LogHelper(e.target.error.name);
                error.message = e.target.error.message;
            }
            {
                error.logError();
            }
            return error.get();
        }
    };

    // CONCATENATED MODULE: ./src/worker/utils/get_error_from_exception.ts


    var getErrorFromException = function (ex, type) {
        if (type === void 0) { type = ERROR_TYPE.InvalidQuery; }
        ex.name = type;
        return getError(ex);
    };

    // CONCATENATED MODULE: ./src/worker/executors/base.ts

    var base_Base = /** @class */ (function () {
        function Base() {
            this.rowAffected = 0;
            this.isTxQuery = false;
            this.results = [];
        }
        // get tableName() {
        //     return (this.query as SelectQuery).from || (this.query as InsertQuery).into
        // }
        Base.prototype.table = function (name) {
            var tableName = name || this.tableName;
            return this.db.tables.find(function (q) { return q.name === tableName; });
        };
        Base.prototype.primaryKey = function (tableName) {
            return this.table(tableName).primaryKey;
        };
        Base.prototype.getColumnInfo = function (columnName, tableName) {
            return this.table(tableName).columns.find(function (column) { return column.name === columnName; });
        };
        Base.prototype.onException = function (ex, type) {
            console.error(ex);
            this.util.abortTransaction();
            return promiseReject(getErrorFromException(ex, type));
        };
        return Base;
    }());


    // CONCATENATED MODULE: ./src/worker/utils/get_data_type.ts

    var getDataType = function (value) {
        if (value == null) {
            return DATA_TYPE.Null;
        }
        var type = typeof value;
        switch (type) {
            case 'object':
                if (Array.isArray(value)) {
                    return DATA_TYPE.Array;
                }
                if (value instanceof Date) {
                    return DATA_TYPE.DateTime;
                }
        }
        return type;
    };

    // CONCATENATED MODULE: ./src/worker/utils/is_null.ts
    var isNull = function (value) {
        if (value == null) {
            return true;
        }
        else {
            switch (typeof value) {
                case 'string': return value.length === 0;
                case 'number': return isNaN(value);
            }
        }
        return false;
    };

    // CONCATENATED MODULE: ./src/worker/executors/insert/values_checker.ts


    var values_checker_ValuesChecker = /** @class */ (function () {
        function ValuesChecker(table, autoIncValues) {
            this.table = table;
            this.autoIncrementValue = autoIncValues;
        }
        ValuesChecker.prototype.checkAndModifyValues = function (query) {
            var _this = this;
            var err;
            this.query = query;
            var values = query.values;
            var ignoreIndexes = [];
            values.every(function (item, index) {
                err = _this.checkAndModifyValue(item);
                if (query.ignore && err) {
                    ignoreIndexes.push(index);
                    err = null;
                }
                return err ? false : true;
            });
            ignoreIndexes.forEach(function (index) {
                values.splice(index, 1);
            });
            return { err: err, values: values };
        };
        ValuesChecker.prototype.checkAndModifyValue = function (value) {
            var _this = this;
            var error;
            this.table.columns.every(function (column) {
                error = _this.checkAndModifyColumnValue_(column, value);
                return error ? false : true;
            });
            return error;
        };
        ValuesChecker.prototype.checkNotNullAndDataType_ = function (column, value) {
            // check not null schema
            if (column.notNull && isNull(value[column.name])) {
                return this.getError(ERROR_TYPE.NullValue, { ColumnName: column.name });
            }
            // check datatype
            else if (column.dataType && !isNull(value[column.name]) &&
                getDataType(value[column.name]) !== column.dataType) {
                return this.getError(ERROR_TYPE.WrongDataType, { column: column.name });
            }
        };
        ValuesChecker.prototype.checkAndModifyColumnValue_ = function (column, value) {
            var columnValue = value[column.name];
            // check auto increment scheme
            if (column.autoIncrement) {
                // if value is null, then create the autoincrement value
                if (isNull(columnValue)) {
                    value[column.name] = ++this.autoIncrementValue[column.name];
                }
                else {
                    if (getDataType(columnValue) === DATA_TYPE.Number) {
                        // if column value is greater than autoincrement value saved, then make the
                        // column value as autoIncrement value
                        if (columnValue > this.autoIncrementValue[column.name]) {
                            this.autoIncrementValue[column.name] = columnValue;
                        }
                    }
                }
            }
            // check Default Schema
            else if (column.default !== undefined && isNull(columnValue)) {
                value[column.name] = column.default;
            }
            var query = this.query;
            if (query.validation) {
                return this.checkNotNullAndDataType_(column, value);
            }
        };
        ValuesChecker.prototype.getError = function (error, details) {
            return new log_helper_LogHelper(error, details);
        };
        return ValuesChecker;
    }());


    // CONCATENATED MODULE: ./src/worker/executors/update/schema_checker.ts


    var schema_checker_SchemaChecker = /** @class */ (function () {
        function SchemaChecker(table) {
            this.table = table;
        }
        SchemaChecker.prototype.check = function (setValue, tblName) {
            var _this = this;
            var log;
            if (typeof setValue === DATA_TYPE.Object) {
                if (this.table) {
                    // loop through table column and find data is valid
                    this.table.columns.every(function (column) {
                        if (column.name in setValue) {
                            log = _this.checkByColumn_(column, setValue[column.name]);
                        }
                        return log ? false : true;
                    });
                }
                else {
                    log = new log_helper_LogHelper(ERROR_TYPE.TableNotExist, { tableName: tblName });
                }
            }
            else {
                log = new log_helper_LogHelper(ERROR_TYPE.NotObject);
            }
            return log;
        };
        SchemaChecker.prototype.checkByColumn_ = function (column, value) {
            // check not null schema
            if (column.notNull === true && isNull(value)) {
                return new log_helper_LogHelper(ERROR_TYPE.NullValue, { ColumnName: column.name });
            }
            // check datatype
            var type = getDataType(value);
            var checkFurther = value != null;
            if (column.dataType && checkFurther) {
                if (type !== column.dataType && type !== 'object') {
                    return new log_helper_LogHelper(ERROR_TYPE.WrongDataType, { column: column.name });
                }
            }
            // check allowed operators
            if (checkFurther && type === 'object') {
                var allowedOp = ['+', '-', '*', '/', '{push}'];
                for (var prop in value) {
                    if (allowedOp.indexOf(prop) < 0 && column.dataType && type !== column.dataType) {
                        return new log_helper_LogHelper(ERROR_TYPE.WrongDataType, { column: column.name });
                    }
                }
            }
        };
        return SchemaChecker;
    }());


    // CONCATENATED MODULE: ./src/worker/executors/query_helper.ts




    var query_helper_QueryHelper = /** @class */ (function () {
        function QueryHelper(dbSchema) {
            this.db = dbSchema;
        }
        QueryHelper.prototype.validate = function (api, query) {
            switch (api) {
                case API.Select:
                case API.Remove:
                case API.Count:
                    return this.checkSelect(query);
                case API.Insert:
                    return this.checkInsertQuery(query);
                case API.Update:
                    return this.checkUpdate(query);
            }
        };
        QueryHelper.prototype.getTable_ = function (tableName) {
            return this.db.tables.find(function (q) { return q.name === tableName; });
        };
        QueryHelper.prototype.isInsertQryValid = function (query) {
            var table = this.getTable_(query.into);
            var log;
            if (table) {
                switch (getDataType(query.values)) {
                    case DATA_TYPE.Array:
                        break;
                    case DATA_TYPE.Null:
                        log = new log_helper_LogHelper(ERROR_TYPE.NoValueSupplied);
                        break;
                    default:
                        log = new log_helper_LogHelper(ERROR_TYPE.NotArray);
                }
            }
            else {
                log = new log_helper_LogHelper(ERROR_TYPE.TableNotExist, { tableName: query.into });
            }
            return {
                table: table, log: log
            };
        };
        QueryHelper.prototype.checkUpdate = function (query) {
            var err = new schema_checker_SchemaChecker(this.getTable_(query.in)).
                check(query.set, query.in);
            if (err)
                return err;
            if (query.where != null) {
                err = this.checkForNullInWhere_(query);
                if (err)
                    return err;
                this.addGreatAndLessToNotOp_(query);
            }
        };
        QueryHelper.prototype.checkSelect = function (query) {
            var table = this.getTable_(query.from);
            if (!table) {
                return new log_helper_LogHelper(ERROR_TYPE.TableNotExist, { tableName: query.from });
            }
            if (query.where) {
                var err = this.checkForNullInWhere_(query);
                if (err)
                    return err;
                this.addGreatAndLessToNotOp_(query);
            }
        };
        QueryHelper.prototype.checkForNullInWhere_ = function (query) {
            for (var columnName in query.where) {
                if (query.where[columnName] == null) {
                    return new log_helper_LogHelper(ERROR_TYPE.NullValueInWhere, { column: columnName });
                }
            }
        };
        QueryHelper.prototype.addGreatAndLessToNotOp_ = function (query) {
            var whereQuery = query.where;
            var containsNot = function (qry, keys) {
                return keys.findIndex(function (key) { return qry[key][QUERY_OPTION.NotEqualTo] != null; }) >= 0;
            };
            var addToSingleQry = function (qry, keys) {
                var value;
                keys.forEach(function (prop) {
                    value = qry[prop];
                    if (value[QUERY_OPTION.NotEqualTo] != null) {
                        qry[prop][QUERY_OPTION.GreaterThan] = value[QUERY_OPTION.NotEqualTo];
                        if (qry[QUERY_OPTION.Or] === undefined) {
                            qry[QUERY_OPTION.Or] = {};
                            qry[QUERY_OPTION.Or][prop] = {};
                        }
                        else if (qry[QUERY_OPTION.Or][prop] === undefined) {
                            qry[QUERY_OPTION.Or][prop] = {};
                        }
                        qry[QUERY_OPTION.Or][prop][QUERY_OPTION.LessThan] = value[QUERY_OPTION.NotEqualTo];
                        delete qry[prop][QUERY_OPTION.NotEqualTo];
                    }
                });
                return qry;
            };
            switch (getDataType(whereQuery)) {
                case DATA_TYPE.Object:
                    var queryKeys = Object.keys(whereQuery);
                    if (containsNot(whereQuery, queryKeys)) {
                        if (queryKeys.length === 1) {
                            query.where = addToSingleQry(whereQuery, queryKeys);
                        }
                        else {
                            var whereTmpQry_1 = [];
                            queryKeys.forEach(function (prop) {
                                var _a;
                                whereTmpQry_1.push(addToSingleQry((_a = {}, _a[prop] = whereQuery[prop], _a), [prop]));
                            });
                            query.where = whereTmpQry_1;
                        }
                    }
                    break;
                default:
                    var whereTmp_1 = [];
                    whereQuery.forEach(function (qry) {
                        var qryKeys = Object.keys(qry);
                        if (containsNot(qry, qryKeys)) {
                            qry = addToSingleQry(qry, qryKeys);
                        }
                        whereTmp_1.push(qry);
                    });
                    query.where = whereTmp_1;
            }
        };
        QueryHelper.prototype.checkInsertQuery = function (query) {
            var validResult = this.isInsertQryValid(query);
            var table = validResult.table;
            var error = validResult.log;
            if (error)
                return error;
            if (query.skipDataCheck)
                return;
            var valueCheckerInstance = new values_checker_ValuesChecker(table, table.autoIncColumnValue);
            var _a = valueCheckerInstance.checkAndModifyValues(query), values = _a.values, err = _a.err;
            query.values = values;
            return err;
        };
        return QueryHelper;
    }());


    // CONCATENATED MODULE: ./src/worker/executors/insert/index.ts
    var __extends = (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();






    var insert_Insert = /** @class */ (function (_super) {
        __extends(Insert, _super);
        function Insert(query, util) {
            var _this = _super.call(this) || this;
            _this.valuesAffected_ = [];
            if (query.validation == null) {
                query.validation = true;
            }
            _this.query = query;
            _this.util = util;
            _this.tableName = query.into;
            return _this;
        }
        Insert.prototype.execute = function (db) {
            var _this = this;
            var err = new query_helper_QueryHelper(db).validate(API.Insert, this.query);
            if (err)
                return promiseReject(err);
            return this.insertData_(db).then(function (_) {
                return _this.query.return ? _this.valuesAffected_ : _this.rowAffected;
            }).catch(function (err) {
                _this.util.abortTransaction();
                return promiseReject(err);
            });
        };
        Insert.prototype.insertData_ = function (db) {
            var _this = this;
            var onInsertData;
            var addMethod;
            var query = this.query;
            if (query.return) {
                onInsertData = function (value) {
                    _this.valuesAffected_.push(value);
                };
            }
            else {
                onInsertData = function (value) {
                    ++_this.rowAffected;
                };
            }
            addMethod = (function () {
                var idbMethod = query.upsert ? "put" : "add";
                if (query.ignore && !_this.isTxQuery) {
                    return function (value) {
                        var tx = _this.util.con.transaction(query.into, IDB_MODE.ReadWrite);
                        var objectStore = tx.objectStore(query.into);
                        return objectStore[idbMethod](value);
                    };
                }
                if (!_this.isTxQuery) {
                    _this.util.createTransaction([query.into, meta_helper_MetaHelper.tableName]);
                }
                _this.objectStore = _this.util.objectStore(_this.tableName);
                return function (value) {
                    return _this.objectStore[idbMethod](value);
                };
            })();
            return promiseAll(query.values.map(function (value) {
                return promise(function (res, rej) {
                    var addResult = addMethod(value);
                    addResult.onerror = function (err) {
                        if (query.ignore) {
                            res();
                        }
                        else {
                            rej(err);
                        }
                    };
                    addResult.onsuccess = function () {
                        onInsertData(value);
                        res();
                    };
                });
            })).then(function () {
                meta_helper_MetaHelper.set(meta_helper_MetaHelper.dbSchema, db, _this.util);
            });
        };
        return Insert;
    }(base_Base));


    // CONCATENATED MODULE: ./src/worker/utils/set_cross_browser_idb.ts
    var setCrossBrowserIndexedDb = function () {
        try {
            if (!indexedDB) {
                indexedDB = self.mozIndexedDB ||
                    self.webkitIndexedDB || self.msIndexedDB;
            }
            if (indexedDB) {
                IDBTransaction = IDBTransaction ||
                    self.webkitIDBTransaction || self.msIDBTransaction;
                self.IDBKeyRange = self.IDBKeyRange ||
                    self.webkitIDBKeyRange || self.msIDBKeyRange;
            }
            else {
                return false;
            }
        }
        catch (ex) {
            return false;
        }
        return true;
    };

    // CONCATENATED MODULE: ./src/worker/constants/index.ts

    var IS_WORKER = typeof self.alert === 'undefined' && typeof ServiceWorkerGlobalScope === 'undefined';
    var IS_IDB_SUPPORTED = setCrossBrowserIndexedDb();

    // CONCATENATED MODULE: ./src/worker/utils/get_keys.ts
    var getKeys = function (value) {
        return Object.keys(value);
    };

    // CONCATENATED MODULE: ./src/worker/utils/is_array.ts
    var isArray = function (value) {
        return Array.isArray(value);
    };

    // CONCATENATED MODULE: ./src/worker/utils/is_object.ts
    var isObject = function (value) {
        return typeof value === 'object';
    };

    // CONCATENATED MODULE: ./src/worker/utils/get_length.ts

    var getLength = function (value) {
        return getKeys(value).length;
    };

    // CONCATENATED MODULE: ./src/worker/utils/get_object_first_key.ts
    var getObjectFirstKey = function (value) {
        for (var key in value) {
            return key;
        }
    };

    // CONCATENATED MODULE: ./src/worker/executors/select/base_select.ts
    var setPushResult = function () {
        var _this = this;
        if (this.query.case) {
            this.pushResult = function (value) {
                var columnName;
                _this.thenEvaluator.setCaseAndValue(_this.query.case, value);
                for (columnName in _this.query.case) {
                    value[columnName] = _this.thenEvaluator.setColumn(columnName).evaluate();
                }
                _this.results.push(value);
            };
        }
        else {
            this.pushResult = function (value) {
                _this.results.push(value);
            };
        }
    };
    var setLimitAndSkipEvaluationAtEnd = function () {
        if (this.query.limit) {
            this.shouldEvaluateLimitAtEnd = true;
        }
        if (this.query.skip) {
            this.shouldEvaluateSkipAtEnd = true;
        }
    };
    var removeDuplicates = function () {
        var datas = this.results;
        // free results memory
        this.results = null;
        var key = this.primaryKey();
        var lookupObject = {};
        for (var i = 0, len = datas.length; i < len; i++) {
            lookupObject[datas[i][key]] = datas[i];
        }
        datas = [];
        for (var i in lookupObject) {
            datas.push(lookupObject[i]);
        }
        this.results = datas;
    };

    // CONCATENATED MODULE: ./src/worker/executors/select/then_evaluator.ts

    var then_evaluator_ThenEvaluator = /** @class */ (function () {
        function ThenEvaluator() {
        }
        ThenEvaluator.prototype.setCaseAndValue = function (caseQuery, value) {
            this.caseQuery_ = caseQuery;
            this.setValue(value);
        };
        ThenEvaluator.prototype.setCaseAndColumn = function (caseQuery, columnName) {
            this.caseQuery_ = caseQuery;
            this.setColumn(columnName);
            return this;
        };
        ThenEvaluator.prototype.setColumn = function (columnName) {
            this.columnName_ = columnName;
            this.caseColumnQuery_ = this.caseQuery_[this.columnName_];
            this.length_ = this.caseColumnQuery_.length;
            return this;
        };
        ThenEvaluator.prototype.setValue = function (value) {
            this.value = value;
            return this;
        };
        ThenEvaluator.prototype.evaluate = function () {
            for (var i = 0; i < this.length_; i++) {
                if (this.checkCase_(this.caseColumnQuery_[i]) === true) {
                    return this.caseColumnQuery_[i].then;
                }
            }
            var lastThen = this.caseColumnQuery_[this.length_ - 1].then;
            return lastThen == null ? this.value[this.columnName_] : lastThen;
        };
        ThenEvaluator.prototype.checkCase_ = function (cond) {
            var queryOption;
            for (queryOption in cond) {
                switch (queryOption) {
                    case QUERY_OPTION.GreaterThan:
                        if (this.value[this.columnName_] > cond[queryOption]) {
                            return true;
                        }
                        break;
                    case QUERY_OPTION.Equal:
                        if (this.value[this.columnName_] === cond[queryOption]) {
                            return true;
                        }
                        break;
                    case QUERY_OPTION.LessThan:
                        if (this.value[this.columnName_] < cond[queryOption]) {
                            return true;
                        }
                        break;
                    case QUERY_OPTION.GreaterThanEqualTo:
                        if (this.value[this.columnName_] >= cond[queryOption]) {
                            return true;
                        }
                        break;
                    case QUERY_OPTION.LessThanEqualTo:
                        if (this.value[this.columnName_] <= cond[queryOption]) {
                            return true;
                        }
                        break;
                    case QUERY_OPTION.NotEqualTo:
                        if (this.value[this.columnName_] !== cond[queryOption]) {
                            return true;
                        }
                        break;
                    case QUERY_OPTION.Between:
                        if (this.value[this.columnName_] > cond[queryOption].low && this.value[this.columnName_] < cond[queryOption].high) {
                            return true;
                        }
                        break;
                }
                return false;
            }
        };
        return ThenEvaluator;
    }());


    // CONCATENATED MODULE: ./src/worker/executors/select/not_where.ts


    var executeWhereUndefinedLogic = function () {
        var _this = this;
        var cursorRequest;
        if (this.query.order && this.query.order.idbSorting !== false && this.query.order.by) {
            if (this.objectStore.indexNames.contains(this.query.order.by)) {
                var orderType = this.query.order.type &&
                    this.query.order.type.toLowerCase() === 'desc' ? 'prev' : 'next';
                this.sorted = true;
                cursorRequest = this.objectStore.index(this.query.order.by).
                    openCursor(null, orderType);
            }
            else {
                return promiseReject(new log_helper_LogHelper(ERROR_TYPE.ColumnNotExist, { column: this.query.order.by, isOrder: true }));
            }
        }
        else {
            cursorRequest = this.objectStore.openCursor();
        }
        var onSuccess = (function () {
            if (_this.shouldEvaluateLimitAtEnd === false && _this.shouldEvaluateSkipAtEnd === false) {
                if (_this.skipRecord && _this.limitRecord) {
                    return executeSkipAndLimit;
                }
                else if (_this.skipRecord) {
                    return executeSkip;
                }
                else if (_this.limitRecord) {
                    return executeLimit;
                }
            }
            return executeSimple;
        })();
        return promise(function (res, rej) {
            cursorRequest.onerror = rej;
            cursorRequest.onsuccess = onSuccess.call(_this, res);
        });
    };
    var executeSkipAndLimit = function (onFinished) {
        var _this = this;
        var recordSkipped = false, cursor;
        return function (e) {
            cursor = e.target.result;
            if (cursor) {
                if (recordSkipped && _this.results.length !== _this.limitRecord) {
                    _this.pushResult(cursor.value);
                    cursor.continue();
                }
                else {
                    recordSkipped = true;
                    cursor.advance(_this.skipRecord);
                }
            }
            else {
                onFinished();
            }
        };
    };
    var executeSkip = function (onFinished) {
        var _this = this;
        var recordSkipped = false, cursor;
        return function (e) {
            cursor = e.target.result;
            if (cursor) {
                if (recordSkipped) {
                    _this.pushResult(cursor.value);
                    cursor.continue();
                }
                else {
                    recordSkipped = true;
                    cursor.advance(_this.skipRecord);
                }
            }
            else {
                onFinished();
            }
        };
    };
    var executeSimple = function (onFinished) {
        var _this = this;
        var cursor;
        return function (e) {
            cursor = e.target.result;
            if (cursor) {
                _this.pushResult(cursor.value);
                cursor.continue();
            }
            else {
                onFinished();
            }
        };
    };
    var executeLimit = function (onFinished) {
        var _this = this;
        var cursor;
        return function (e) {
            cursor = e.target.result;
            if (cursor && _this.results.length !== _this.limitRecord) {
                _this.pushResult(cursor.value);
                cursor.continue();
            }
            else {
                onFinished();
            }
        };
    };

    // CONCATENATED MODULE: ./src/worker/utils/remove_space.ts
    var removeSpace = function (value) {
        return value.replace(/\s/g, '');
    };

    // CONCATENATED MODULE: ./src/worker/executors/select/order_by.ts


    var processGroupDistinctAggr = function () {
        if (this.query.distinct) {
            var groupBy = [];
            var result = this.results[0];
            for (var key in result) {
                groupBy.push(key);
            }
            var primaryKey = this.primaryKey(), index = groupBy.indexOf(primaryKey);
            groupBy.splice(index, 1);
            this.query.groupBy = groupBy.length > 0 ? groupBy : null;
        }
        if (this.query.groupBy) {
            if (this.query.aggregate) {
                this.executeAggregateGroupBy();
            }
            else {
                this.processGroupBy();
            }
        }
        else if (this.query.aggregate) {
            this.processAggregateQry();
        }
    };
    var getOrderColumnInfo = function (orderColumn) {
        var column;
        if (this.query.join == null) {
            column = this.getColumnInfo(orderColumn);
        }
        else {
            var splittedByDot = removeSpace(orderColumn).split(".");
            orderColumn = splittedByDot[1];
            column = this.getColumnInfo(orderColumn, splittedByDot[0]);
        }
        if (column == null) {
            var valueFromFirstColumn = this.results[0][orderColumn];
            if (valueFromFirstColumn) {
                return {
                    dataType: getDataType(valueFromFirstColumn),
                    name: orderColumn
                };
            }
            throw new log_helper_LogHelper(ERROR_TYPE.ColumnNotExist, { column: orderColumn, isOrder: true });
        }
        return column;
    };
    var compareStringInDesc_ = function (a, b) {
        return b.localeCompare(a);
    };
    var compareStringinAsc_ = function (a, b) {
        return a.localeCompare(b);
    };
    var compareDefaultInDesc_ = function (a, b) {
        return new String(b).localeCompare(a);
    };
    var compareDefaultinAsc_ = function (a, b) {
        return new String(a).localeCompare(b);
    };
    var compareNumberInDesc_ = function (a, b) {
        return b - a;
    };
    var compareNumberinAsc_ = function (a, b) {
        return a - b;
    };
    var compareDateInDesc_ = function (a, b) {
        return b.getTime() - a.getTime();
    };
    var compareDateInAsc_ = function (a, b) {
        return a.getTime() - b.getTime();
    };
    var getValInDesc_ = function (value1, value2, caseQuery) {
        for (var columnName in caseQuery) {
            this.thenEvaluator.setCaseAndValue(caseQuery, value1);
            var column1 = this.thenEvaluator.setColumn(columnName).evaluate();
            this.thenEvaluator.setCaseAndValue(caseQuery, value2);
            var column2 = this.thenEvaluator.setColumn(columnName).evaluate();
            switch (typeof value1[column1]) {
                case DATA_TYPE.String:
                    return compareStringInDesc_(value1[column1], value2[column2]);
                default:
                    return compareNumberInDesc_(value1[column1], value2[column2]);
            }
        }
    };
    var getValInAsc_ = function (value1, value2, caseQuery) {
        for (var columnName in caseQuery) {
            this.thenEvaluator.setCaseAndValue(caseQuery, value1);
            var column1 = this.thenEvaluator.setColumn(columnName).evaluate();
            this.thenEvaluator.setCaseAndValue(caseQuery, value2);
            var column2 = this.thenEvaluator.setColumn(columnName).evaluate();
            switch (typeof value1[column1]) {
                case DATA_TYPE.String:
                    return compareStringinAsc_(value1[column1], value2[column2]);
                default:
                    return compareNumberinAsc_(value1[column1], value2[column2]);
            }
        }
    };
    var getValueComparer_ = function (column, order) {
        switch (column.dataType) {
            case DATA_TYPE.String:
                return order.type === 'asc' ? compareStringinAsc_ : compareStringInDesc_;
            case DATA_TYPE.Number:
                return order.type === 'asc' ? compareNumberinAsc_ : compareNumberInDesc_;
            case DATA_TYPE.DateTime:
                return order.type === 'asc' ? compareDateInAsc_ : compareDateInDesc_;
            default:
                return order.type === 'asc' ? compareDefaultinAsc_ : compareDefaultInDesc_;
        }
    };
    var orderBy_ = function (order) {
        var _a;
        var _this = this;
        order.type = getOrderType_(order.type);
        var orderColumn = order.by;
        if (orderColumn != null && typeof orderColumn === DATA_TYPE.Object) {
            if (order.type === "asc") {
                this.results.sort(function (a, b) {
                    return getValInAsc_.call(_this, a, b, orderColumn);
                });
            }
            else {
                this.results.sort(function (a, b) {
                    return getValInDesc_.call(_this, a, b, orderColumn);
                });
            }
        }
        else {
            var columnInfo = getOrderColumnInfo.call(this, orderColumn);
            if (columnInfo != null) {
                var orderMethod_1 = getValueComparer_(columnInfo, order);
                orderColumn = columnInfo.name;
                if (order.case == null) {
                    this.results.sort(function (a, b) {
                        return orderMethod_1(a[orderColumn], b[orderColumn]);
                    });
                }
                else {
                    this.thenEvaluator.setCaseAndColumn((_a = {}, _a[orderColumn] = order.case, _a), orderColumn);
                    this.results.sort(function (a, b) {
                        return orderMethod_1(_this.thenEvaluator.setValue(a).evaluate(), _this.thenEvaluator.setValue(b).evaluate());
                    });
                }
            }
        }
    };
    var getOrderType_ = function (type) {
        return type == null ? 'asc' : type.toLowerCase();
    };
    var processOrderBy = function () {
        var order = this.query.order;
        if (order && this.results.length > 0 && !this.sorted) {
            var orderQueryType = getDataType(order);
            if (orderQueryType === DATA_TYPE.Object) {
                orderBy_.call(this, order);
            }
            else if (orderQueryType === DATA_TYPE.Array) {
                orderBy_.call(this, order[0]);
                var _loop_1 = function (i, length_1) {
                    // if (this.error == null) {
                    var prevOrderQueryBy = order[i - 1].by;
                    var currentOrderQuery = order[i];
                    var currentorderQueryBy = currentOrderQuery.by;
                    var orderColumnDetail = getOrderColumnInfo.call(this_1, currentorderQueryBy);
                    if (orderColumnDetail != null) {
                        currentorderQueryBy = orderColumnDetail.name;
                        currentOrderQuery.type = getOrderType_(currentOrderQuery.type);
                        var orderMethod_2 = getValueComparer_(orderColumnDetail, currentOrderQuery);
                        this_1.results.sort(function (a, b) {
                            if (a[prevOrderQueryBy] === b[prevOrderQueryBy]) {
                                return orderMethod_2(a[currentorderQueryBy], b[currentorderQueryBy]);
                            }
                            return 0;
                        });
                    }
                };
                var this_1 = this;
                for (var i = 1, length_1 = order.length; i < length_1; i++) {
                    _loop_1(i, length_1);
                }
            }
        }
    };
    var processAggregateQry = function () {
        var datas = this.results;
        var datasLength = datas.length;
        var results = {};
        var columnToAggregate;
        // free results memory
        this.results = undefined;
        var getCount = function () {
            var result = 0;
            for (var i in datas) {
                result += datas[i][columnToAggregate] ? 1 : 0;
            }
            return result;
        };
        var getMax = function () {
            var result = 0;
            for (var i in datas) {
                result = result > datas[i][columnToAggregate] ?
                    result : datas[i][columnToAggregate];
            }
            return result;
        };
        var getMin = function () {
            var result = Infinity, value = Infinity;
            for (var i in datas) {
                value = datas[i][columnToAggregate] ?
                    datas[i][columnToAggregate] : Infinity;
                result = result < value ? result : value;
            }
            return result;
        };
        var getSum = function () {
            var result = 0;
            for (var i in datas) {
                result += datas[i][columnToAggregate];
            }
            return result;
        };
        var getAvg = function () {
            var result = 0;
            for (var i in datas) {
                result += datas[i][columnToAggregate];
            }
            return result / datasLength;
        };
        for (var prop in this.query.aggregate) {
            var aggregateColumn = this.query.aggregate[prop];
            var aggregateValType = getDataType(aggregateColumn);
            var aggregateCalculator = void 0;
            switch (prop) {
                case 'count':
                    aggregateCalculator = getCount;
                    break;
                case 'max':
                    aggregateCalculator = getMax;
                    break;
                case 'min':
                    aggregateCalculator = getMin;
                    break;
                case 'sum':
                    aggregateCalculator = getSum;
                    break;
                case 'avg':
                    aggregateCalculator = getAvg;
                    break;
            }
            switch (aggregateValType) {
                case DATA_TYPE.String:
                    columnToAggregate = aggregateColumn;
                    results[prop + "(" + columnToAggregate + ")"] = aggregateCalculator();
                    break;
                case DATA_TYPE.Array:
                    for (var key in aggregateColumn) {
                        columnToAggregate = aggregateColumn[key];
                        results[prop + "(" + columnToAggregate + ")"] = aggregateCalculator();
                    }
            }
        }
        // add results to the first index of result
        for (var prop in results) {
            datas[0][prop] = results[prop];
        }
        this.results = [datas[0]];
    };

    // CONCATENATED MODULE: ./src/worker/executors/select/group_by.ts


    var processGroupBy = function () {
        var groupBy = this.query.groupBy;
        var datas = this.results;
        var lookUpObj = {};
        // free results memory
        this.results = this.query.groupBy = null;
        if (getDataType(groupBy) !== DATA_TYPE.Object) {
            if (getDataType(groupBy) === DATA_TYPE.String) {
                for (var i in datas) {
                    lookUpObj[datas[i][groupBy]] = datas[i];
                }
            }
            else {
                var objKey = void 0;
                for (var i in datas) {
                    objKey = "";
                    for (var column in groupBy) {
                        objKey += datas[i][groupBy[column]];
                    }
                    lookUpObj[objKey] = datas[i];
                }
            }
        }
        else {
            var caseQueryLength = Object.keys(groupBy).length;
            if (caseQueryLength === 1) {
                var groupByColumn = getObjectFirstKey(groupBy);
                this.thenEvaluator.setCaseAndColumn(groupBy, groupByColumn);
                for (var i in datas) {
                    lookUpObj[this.thenEvaluator.setValue(datas[i]).evaluate()] = datas[i];
                }
            }
            else {
                var objKey = void 0;
                for (var i in datas) {
                    objKey = "";
                    this.thenEvaluator.setCaseAndValue(groupBy, datas[i]);
                    for (var column in groupBy) {
                        objKey += this.thenEvaluator.setColumn(column).evaluate();
                    }
                    lookUpObj[objKey] = datas[i];
                }
            }
        }
        // free datas memory
        datas = [];
        for (var i in lookUpObj) {
            datas.push(lookUpObj[i]);
        }
        this.results = datas;
    };
    var executeAggregateGroupBy = function () {
        var grpQry = this.query.groupBy;
        var datas = this.results;
        // free results memory
        this.results = undefined;
        var lookUpObj = {};
        // assign aggregate
        var aggregateQry = this.query.aggregate;
        var index;
        var objKey;
        var value;
        var columnToAggregate;
        var calculateAggregate = function () {
            var getCount = function () {
                value = lookUpObj[objKey];
                // get old value
                value = value ? value["count(" + columnToAggregate + ")"] : 0;
                // add with old value if data exist
                value += datas[index][columnToAggregate] ? 1 : 0;
                return value;
            };
            var getMax = function () {
                value = lookUpObj[objKey];
                // get old value
                value = value ? value["max(" + columnToAggregate + ")"] : 0;
                datas[index][columnToAggregate] = datas[index][columnToAggregate] ?
                    datas[index][columnToAggregate] : 0;
                // compare between old value and new value
                return value > datas[index][columnToAggregate] ? value : datas[index][columnToAggregate];
            };
            var getMin = function () {
                value = lookUpObj[objKey];
                // get old value
                value = value ? value["min(" + columnToAggregate + ")"] : Infinity;
                datas[index][columnToAggregate] = datas[index][columnToAggregate] ?
                    datas[index][columnToAggregate] : Infinity;
                // compare between old value and new value
                return value < datas[index][columnToAggregate] ? value : datas[index][columnToAggregate];
            };
            var getSum = function () {
                value = lookUpObj[objKey];
                // get old value
                value = value ? value["sum(" + columnToAggregate + ")"] : 0;
                // add with old value if data exist
                value += datas[index][columnToAggregate] ? datas[index][columnToAggregate] : 0;
                return value;
            };
            var getAvg = function () {
                value = lookUpObj[objKey];
                // get old sum value
                var sumOfColumn = value ? value["sum(" + columnToAggregate + ")"] : 0;
                // add with old value if data exist
                sumOfColumn += datas[index][columnToAggregate] ? datas[index][columnToAggregate] : 0;
                datas[index]["sum(" + columnToAggregate + ")"] = sumOfColumn;
                // get old count value
                value = value ? value["count(" + columnToAggregate + ")"] : 0;
                // add with old value if data exist
                value += datas[index][columnToAggregate] ? 1 : 0;
                datas[index]["count(" + columnToAggregate + ")"] = value;
            };
            for (var prop in aggregateQry) {
                var aggregateColumn = aggregateQry[prop];
                var aggregateValType = getDataType(aggregateColumn);
                var aggregateCalculator = void 0;
                switch (prop) {
                    case QUERY_OPTION.Count:
                        aggregateCalculator = getCount;
                        break;
                    case QUERY_OPTION.Max:
                        aggregateCalculator = getMax;
                        break;
                    case QUERY_OPTION.Min:
                        aggregateCalculator = getMin;
                        break;
                    case QUERY_OPTION.Sum:
                        aggregateCalculator = getSum;
                        break;
                    case QUERY_OPTION.Avg:
                        aggregateCalculator = getAvg;
                        break;
                }
                switch (aggregateValType) {
                    case DATA_TYPE.String:
                        columnToAggregate = aggregateColumn;
                        datas[index][prop + "(" + columnToAggregate + ")"] = aggregateCalculator();
                        break;
                    case DATA_TYPE.Array:
                        for (var item in aggregateColumn) {
                            columnToAggregate = aggregateColumn[item];
                            datas[index][prop + "(" + columnToAggregate + ")"] = aggregateCalculator();
                        }
                }
            }
        };
        if (getDataType(grpQry) === DATA_TYPE.String) {
            for (index in datas) {
                objKey = datas[index][grpQry];
                calculateAggregate();
                lookUpObj[objKey] = datas[index];
            }
        }
        else {
            for (index in datas) {
                objKey = "";
                for (var column in grpQry) {
                    objKey += datas[index][grpQry[column]];
                }
                calculateAggregate();
                lookUpObj[objKey] = datas[index];
            }
        }
        // free datas memory
        datas = [];
        for (var i in lookUpObj) {
            datas.push(lookUpObj[i]);
        }
        // Checking for avg and if exist then fill the datas;
        if (aggregateQry.avg) {
            if (getDataType(aggregateQry.avg) === DATA_TYPE.String) {
                for (index in datas) {
                    var sumForAvg = datas[index]["sum(" + aggregateQry.avg + ")"], countForAvg = datas[index]["count(" + aggregateQry.avg + ")"];
                    datas[index]["avg(" + aggregateQry.avg + ")"] = sumForAvg / countForAvg;
                    if (aggregateQry.count !== aggregateQry.avg) {
                        delete datas[index]["count(" + aggregateQry.avg + ")"];
                    }
                    if (aggregateQry.sum !== aggregateQry.avg) {
                        delete datas[index]["sum(" + aggregateQry.avg + ")"];
                    }
                }
            }
            else {
                var isCountTypeString = getDataType(aggregateQry.count) === DATA_TYPE.String;
                var isSumTypeString = getDataType(aggregateQry.sum) === DATA_TYPE.String;
                for (index in datas) {
                    for (var column in aggregateQry.avg) {
                        var avgColumn = aggregateQry.avg[column], sum = datas[index]["sum(" + avgColumn + ")"], count = datas[index]["count(" + avgColumn + ")"];
                        datas[index]["avg(" + avgColumn + ")"] = sum / count;
                        if (isCountTypeString) {
                            if (aggregateQry.count !== avgColumn) {
                                delete datas[index]["count(" + avgColumn + ")"];
                            }
                            else if (aggregateQry.count.indexOf(avgColumn) === -1) {
                                delete datas[index]["count(" + avgColumn + ")"];
                            }
                        }
                        if (isSumTypeString) {
                            if (aggregateQry.sum !== avgColumn) {
                                delete datas[index]["sum(" + avgColumn + ")"];
                            }
                            else if (aggregateQry.sum.indexOf(avgColumn) === -1) {
                                delete datas[index]["sum(" + avgColumn + ")"];
                            }
                        }
                    }
                }
            }
        }
        this.results = datas;
    };

    // CONCATENATED MODULE: ./src/worker/executors/select/where.ts

    var executeWhereLogic = function (column, value, op, dir) {
        var _this = this;
        value = op ? value[op] : value;
        var cursorRequest = this.objectStore.index(column).openCursor(this.util.keyRange(value, op), dir);
        var onSuccess = (function () {
            if (_this.shouldEvaluateLimitAtEnd === false && _this.shouldEvaluateSkipAtEnd === false) {
                if (_this.skipRecord && _this.limitRecord) {
                    return executeSkipAndLimitForWhere_;
                }
                else if (_this.skipRecord) {
                    return executeSkipForWhere_;
                }
                else if (_this.limitRecord) {
                    return executeLimitForWhere_;
                }
            }
            return executeSimpleForWhere_;
        })();
        return promise(function (res, rej) {
            cursorRequest.onerror = rej;
            cursorRequest.onsuccess = onSuccess.call(_this, res);
        });
    };
    var executeSkipAndLimitForWhere_ = function (onFinish) {
        var _this = this;
        var recordSkipped = false;
        return function (e) {
            var cursor = e.target.result;
            if (cursor) {
                if (recordSkipped && _this.results.length !== _this.limitRecord) {
                    var value = cursor.value;
                    if (_this.shouldAddValue(value)) {
                        _this.pushResult(value);
                    }
                    cursor.continue();
                }
                else {
                    recordSkipped = true;
                    cursor.advance(_this.skipRecord);
                }
            }
            else {
                onFinish();
            }
        };
    };
    var executeSkipForWhere_ = function (onFinish) {
        var _this = this;
        var recordSkipped = false;
        return function (e) {
            var cursor = e.target.result;
            if (cursor) {
                if (recordSkipped) {
                    var value = cursor.value;
                    if (_this.shouldAddValue(value)) {
                        _this.pushResult(value);
                    }
                    cursor.continue();
                }
                else {
                    recordSkipped = true;
                    cursor.advance(_this.skipRecord);
                }
            }
            else {
                onFinish();
            }
        };
    };
    var executeLimitForWhere_ = function (onFinish) {
        var _this = this;
        return function (e) {
            var cursor = e.target.result;
            if (cursor && _this.results.length !== _this.limitRecord) {
                var value = cursor.value;
                if (_this.shouldAddValue(value)) {
                    _this.pushResult(value);
                }
                cursor.continue();
            }
            else {
                onFinish();
            }
        };
    };
    var executeSimpleForWhere_ = function (onFinish) {
        var _this = this;
        return function (e) {
            var cursor = e.target.result;
            if (cursor) {
                var value = cursor.value;
                if (_this.shouldAddValue(value)) {
                    _this.pushResult(value);
                }
                cursor.continue();
            }
            else {
                onFinish();
            }
        };
    };

    // CONCATENATED MODULE: ./src/worker/utils/get_regex_from_like.ts

    var getRegexFromLikeExpression = function (likeExpression) {
        var filterValues = likeExpression.split('%');
        var filterValue;
        var occurence;
        if (filterValues[1]) {
            filterValue = filterValues[1];
            occurence = filterValues.length > 2 ? OCCURENCE.Any : OCCURENCE.Last;
        }
        else {
            filterValue = filterValues[0];
            occurence = OCCURENCE.First;
        }
        switch (occurence) {
            case OCCURENCE.First:
                return new RegExp("^" + filterValue, 'i');
            case OCCURENCE.Last:
                return new RegExp(filterValue + "$", 'i');
            default:
                return new RegExp("" + filterValue, 'i');
        }
    };

    // CONCATENATED MODULE: ./src/worker/utils/clone.ts

    var clone_isObject = function (value) {
        return getDataType(value) === 'object' && !(value instanceof RegExp);
    };
    var clone = function (obj) {
        if (clone_isObject(obj)) {
            var copy = {};
            for (var i in obj) {
                copy[i] = obj[i] != null && clone_isObject(obj[i]) ? clone(obj[i]) : obj[i];
            }
            return copy;
        }
        return obj;
    };

    // CONCATENATED MODULE: ./src/worker/utils/compare.ts


    var compare = function (value, compareValue, symbol) {
        var type1 = getDataType(value);
        var type2 = getDataType(compareValue);
        if (type1 !== type2)
            return false;
        if (type1 === DATA_TYPE.DateTime) {
            value = value.getTime();
            compareValue = compareValue.getTime();
        }
        switch (symbol) {
            // greater than
            case QUERY_OPTION.GreaterThan:
                return value > compareValue;
            // less than
            case QUERY_OPTION.LessThan:
                return value < compareValue;
            // less than equal
            case QUERY_OPTION.LessThanEqualTo:
                return value <= compareValue;
            // greather than equal
            case QUERY_OPTION.GreaterThanEqualTo:
                return value >= compareValue;
            // Not equal to
            case QUERY_OPTION.NotEqualTo:
                return value !== compareValue;
            default:
                return value === compareValue;
        }
    };

    // CONCATENATED MODULE: ./src/worker/executors/where_checker.ts


    /**
     * For matching the different column value existance for where option
     *
     * @export
     * @class WhereChecker
     */
    var where_checker_WhereChecker = /** @class */ (function () {
        function WhereChecker(where, checkFlag) {
            this.where = clone(where);
            this.checkFlag = checkFlag;
        }
        WhereChecker.prototype.remove = function (props) {
            var last = props.pop();
            var value = props.reduce(function (prev, curr) { return prev && prev[curr]; }, this.where);
            delete value[last];
        };
        WhereChecker.prototype.check = function (rowValue) {
            var status = true;
            if (!this.checkFlag)
                return status;
            for (var columnName in this.where) {
                if (!status) {
                    return status;
                }
                var whereColumnValue = this.where[columnName];
                var columnValue = rowValue[columnName];
                if (getDataType(whereColumnValue) === "object") {
                    for (var key in whereColumnValue) {
                        if (!status) {
                            return status;
                        }
                        switch (key) {
                            case QUERY_OPTION.In:
                                status = this.checkIn(columnName, columnValue);
                                break;
                            case QUERY_OPTION.Like:
                                status = this.checkLike_(columnName, columnValue);
                                break;
                            case QUERY_OPTION.Regex:
                                status = this.checkRegex(columnName, columnValue);
                                break;
                            case QUERY_OPTION.Between:
                            case QUERY_OPTION.GreaterThan:
                            case QUERY_OPTION.LessThan:
                            case QUERY_OPTION.GreaterThanEqualTo:
                            case QUERY_OPTION.LessThanEqualTo:
                            case QUERY_OPTION.NotEqualTo:
                                status = this.checkComparisionOp_(columnName, columnValue, key);
                                break;
                            default:
                                status = false;
                        }
                    }
                }
                else {
                    status = compare(whereColumnValue, columnValue);
                }
            }
            return status;
        };
        WhereChecker.prototype.checkIn = function (column, value) {
            return this.where[column][QUERY_OPTION.In].find(function (q) { return compare(q, value); }) != null;
        };
        WhereChecker.prototype.checkLike_ = function (column, value) {
            return getRegexFromLikeExpression(this.where[column][QUERY_OPTION.Like]).test(value);
        };
        WhereChecker.prototype.checkRegex = function (column, value) {
            return this.where[column][QUERY_OPTION.Regex].test(value);
        };
        WhereChecker.prototype.checkComparisionOp_ = function (column, value, symbol) {
            var compareValue = this.where[column][symbol];
            if (symbol != QUERY_OPTION.Between) {
                return compare(value, compareValue, symbol);
            }
            return compare(value, compareValue.low, '>=') &&
                compare(value, compareValue.high, '<=');
        };
        return WhereChecker;
    }());


    // CONCATENATED MODULE: ./src/worker/executors/base_fetch.ts
    var base_fetch_extends = (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();





    var base_fetch_BaseFetch = /** @class */ (function (_super) {
        base_fetch_extends(BaseFetch, _super);
        function BaseFetch() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.shouldEvaluateLimitAtEnd = false;
            _this.shouldEvaluateSkipAtEnd = false;
            return _this;
        }
        BaseFetch.prototype.goToWhereLogic = function () {
            var query = this.query;
            var firstColumn = getObjectFirstKey(query.where);
            if (this.objectStore.indexNames.contains(firstColumn)) {
                var value = query.where[firstColumn];
                if (getDataType(value) === 'object') {
                    var checkFlag = getLength(value) > 1 ||
                        getLength(query.where) > 1;
                    this.whereCheckerInstance = new where_checker_WhereChecker(query.where, checkFlag);
                    var key = getObjectFirstKey(value);
                    this.whereCheckerInstance.remove([firstColumn, key]);
                    switch (key) {
                        case QUERY_OPTION.Like: {
                            var regexVal = getRegexFromLikeExpression(value[QUERY_OPTION.Like]);
                            return this.executeRegexLogic(firstColumn, regexVal);
                        }
                        case QUERY_OPTION.Regex:
                            return this.executeRegexLogic(firstColumn, value[QUERY_OPTION.Regex]);
                        case QUERY_OPTION.In:
                            return this.executeInLogic(firstColumn, value[QUERY_OPTION.In]);
                        case QUERY_OPTION.Between:
                        case QUERY_OPTION.GreaterThan:
                        case QUERY_OPTION.LessThan:
                        case QUERY_OPTION.GreaterThanEqualTo:
                        case QUERY_OPTION.LessThanEqualTo:
                            return this.executeWhereLogic(firstColumn, value, key, "next");
                        case QUERY_OPTION.Aggregate: break;
                        default:
                            return this.executeWhereLogic(firstColumn, value, null, "next");
                    }
                }
                else {
                    var checkFlag = getLength(query.where) > 1;
                    this.whereCheckerInstance = new where_checker_WhereChecker(query.where, checkFlag);
                    this.whereCheckerInstance.remove([firstColumn]);
                    return this.executeWhereLogic(firstColumn, value, null, "next");
                }
            }
            else {
                var column = this.getColumnInfo(firstColumn);
                var error = column == null ?
                    new log_helper_LogHelper(ERROR_TYPE.ColumnNotExist, { column: firstColumn }) :
                    new log_helper_LogHelper(ERROR_TYPE.EnableSearchOff, { column: firstColumn });
                return promiseReject(error);
            }
        };
        return BaseFetch;
    }(base_Base));


    // CONCATENATED MODULE: ./src/worker/executors/select/in.ts

    var executeInLogic = function (column, values) {
        var _this = this;
        var skip = this.skipRecord;
        var skipOrPush = function (val) {
            if (skip === 0) {
                _this.pushResult(val);
            }
            else {
                --skip;
            }
        };
        var onSuccess = (function () {
            if (_this.shouldEvaluateLimitAtEnd === false && _this.shouldEvaluateSkipAtEnd === false) {
                if (_this.skipRecord && _this.limitRecord) {
                    return executeSkipAndLimitForIn_;
                }
                else if (_this.skipRecord) {
                    return executeSkipForIn_;
                }
                else if (_this.limitRecord) ;
            }
            return executeSimpleForIn_;
        })();
        var columnStore = this.objectStore.index(column);
        var runInLogic = function (value) {
            return promise(function (res, rej) {
                var cursorRequest = columnStore.openCursor(_this.util.keyRange(value));
                cursorRequest.onsuccess = onSuccess.call(_this, res, skipOrPush);
                cursorRequest.onerror = rej;
            });
        };
        return promiseAll(values.map(function (val) {
            return runInLogic(val);
        }));
    };
    var executeSkipAndLimitForIn_ = function (onFinish, skipOrPush) {
        var _this = this;
        return function (e) {
            var cursor = e.target.result;
            if (_this.results.length !== _this.limitRecord && cursor) {
                var value = cursor.value;
                if (_this.shouldAddValue(value)) {
                    skipOrPush(value);
                }
                cursor.continue();
            }
            else {
                onFinish();
            }
        };
    };
    var executeSkipForIn_ = function (onFinish, skipOrPush) {
        var _this = this;
        return function (e) {
            var cursor = e.target.result;
            if (cursor) {
                var value = cursor.value;
                if (_this.shouldAddValue(value)) {
                    skipOrPush(value);
                }
                cursor.continue();
            }
            else {
                onFinish();
            }
        };
    };
    var executeSimpleForIn_ = function (onFinish) {
        var _this = this;
        return function (e) {
            var cursor = e.target.result;
            if (cursor) {
                var value = cursor.value;
                if (_this.shouldAddValue(value)) {
                    _this.pushResult(value);
                }
                cursor.continue();
            }
            else {
                onFinish();
            }
        };
    };

    // CONCATENATED MODULE: ./src/worker/executors/select/regex.ts

    var executeRegexLogic = function (column, exp) {
        var _this = this;
        var skip = this.skipRecord;
        var skipOrPush = function (val) {
            if (skip === 0) {
                _this.pushResult(val);
            }
            else {
                --skip;
            }
        };
        this.shouldAddValue = function (cursor) {
            return exp.test(cursor.key) &&
                _this.whereCheckerInstance.check(cursor.value);
        };
        var cursorRequest = this.objectStore.index(column).openCursor();
        var onSuccess = (function () {
            if (_this.shouldEvaluateLimitAtEnd === false && _this.shouldEvaluateSkipAtEnd === false) {
                if (_this.skipRecord && _this.limitRecord) {
                    return executeSkipAndLimitForRegex_;
                }
                else if (_this.skipRecord) {
                    return executeSkipForRegex_;
                }
                else if (_this.limitRecord) {
                    return executeLimitForRegex_;
                }
            }
            return executeSimpleForRegex_;
        })();
        return promise(function (res, rej) {
            cursorRequest.onerror = rej;
            cursorRequest.onsuccess = onSuccess.call(_this, res, skipOrPush);
        });
    };
    var executeSkipAndLimitForRegex_ = function (onFinish, skipOrPush) {
        var _this = this;
        return function (e) {
            var cursor = e.target.result;
            if (_this.results.length !== _this.limitRecord && cursor) {
                if (_this.shouldAddValue(cursor)) {
                    skipOrPush(cursor.value);
                }
                cursor.continue();
            }
            else {
                onFinish();
            }
        };
    };
    var executeSkipForRegex_ = function (onFinish, skipOrPush) {
        var _this = this;
        return function (e) {
            var cursor = e.target.result;
            if (cursor) {
                if (_this.shouldAddValue(cursor)) {
                    skipOrPush((cursor.value));
                }
                cursor.continue();
            }
            else {
                onFinish();
            }
        };
    };
    var executeLimitForRegex_ = function (onFinish) {
        var _this = this;
        return function (e) {
            var cursor = e.target.result;
            if (_this.results.length !== _this.limitRecord && cursor) {
                if (_this.shouldAddValue(cursor)) {
                    _this.pushResult(cursor.value);
                }
                cursor.continue();
            }
            else {
                onFinish();
            }
        };
    };
    var executeSimpleForRegex_ = function (onFinish) {
        var _this = this;
        return function (e) {
            var cursor = e.target.result;
            if (cursor) {
                if (_this.shouldAddValue(cursor)) {
                    _this.pushResult(cursor.value);
                }
                cursor.continue();
            }
            else {
                onFinish();
            }
        };
    };

    // CONCATENATED MODULE: ./src/worker/executors/select/join.ts
    var __assign = function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };



    var executeJoinQuery = function () {
        return new join_Join(this).execute();
    };
    var join_Join = /** @class */ (function () {
        function Join(select) {
            this.joinQueryStack_ = [];
            this.currentQueryStackIndex_ = 0;
            this.tablesFetched = [];
            this.results = [];
            this.select = select;
        }
        Object.defineProperty(Join.prototype, "query", {
            get: function () {
                return this.select.query;
            },
            enumerable: false,
            configurable: true
        });
        Join.prototype.getTable = function (name) {
            return this.select.table(name);
        };
        Join.prototype.executeSelect = function (query) {
            // this.select.util.emptyTx();
            return new select_Select(query, this.select.util).
                execute(this.select.db);
        };
        Join.prototype.execute = function () {
            var _this = this;
            var query = this.query;
            this.joinQueryStack_ = getDataType(query.join) === DATA_TYPE.Object ?
                [query.join] : query.join;
            // get the data for first table
            var tableName = query.from;
            var tablesToFetch = [tableName];
            for (var i = 0, length_1 = this.joinQueryStack_.length; i < length_1; i++) {
                var item = this.joinQueryStack_[i];
                var jointblInfo = this.getJoinTableInfo_(item.on);
                // table 1 is fetched & table2 needs to be fetched for join
                if (item.with === jointblInfo.table1.table) {
                    jointblInfo = {
                        table1: jointblInfo.table2,
                        table2: jointblInfo.table1
                    };
                }
                var err = this.checkJoinQuery_(jointblInfo, item);
                if (err) {
                    return promiseReject(err);
                }
                this.joinQueryStack_[i].joinTableInfo = jointblInfo;
                tablesToFetch.push(item.with);
            }
            if (!this.select.isTxQuery) {
                this.select.util.createTransaction(tablesToFetch);
            }
            return this.executeSelect({
                from: tableName,
                where: query.where,
                case: query.case,
                flatten: query.flatten
            }).then(function (results) {
                _this.results = results.map(function (item) {
                    var _a;
                    return _a = {},
                        _a[_this.currentQueryStackIndex_] = item,
                        _a;
                });
                _this.tablesFetched.push(tableName);
                return _this.startExecutingJoinLogic_();
            });
        };
        Join.prototype.onJoinQueryFinished_ = function () {
            var _this = this;
            // const query = this.query;
            if (this.results.length > 0) {
                try {
                    var results_1 = [];
                    var tables = Object.keys(this.results[0]);
                    var tablesLength_1 = tables.length;
                    var mapWithAlias_1 = function (query, value) {
                        if (query.as != null) {
                            for (var key in query.as) {
                                if (value[query.as[key]] === undefined) {
                                    value[query.as[key]] = value[key];
                                    delete value[key];
                                }
                            }
                        }
                        return value;
                    };
                    this.results.forEach(function (result) {
                        var data = result["0"]; // first table data
                        for (var i = 1; i < tablesLength_1; i++) {
                            var query = _this.joinQueryStack_[i - 1];
                            data = __assign(__assign({}, data), mapWithAlias_1(query, result[i]));
                        }
                        results_1.push(data);
                    });
                    this.select['results'] = results_1;
                    this.select.setLimitAndSkipEvaluationAtEnd_();
                    this.select.query.flatten = null;
                    if (true) {
                        try {
                            this.select.processOrderBy();
                        }
                        catch (ex) {
                            return promiseReject(new log_helper_LogHelper(ERROR_TYPE.InvalidOrderQuery, ex.message));
                        }
                    }
                    if (true) {
                        try {
                            this.select.processGroupDistinctAggr();
                        }
                        catch (ex) {
                            return promiseReject(new log_helper_LogHelper(ERROR_TYPE.InvalidGroupQuery, ex.message));
                        }
                    }
                }
                catch (ex) {
                    return promiseReject(new log_helper_LogHelper(ERROR_TYPE.InvalidJoinQuery, ex.message));
                }
            }
            return;
        };
        Join.prototype.startExecutingJoinLogic_ = function () {
            var _this = this;
            var joinQuery = this.joinQueryStack_[this.currentQueryStackIndex_];
            if (joinQuery) {
                try {
                    var jointblInfo_1 = joinQuery.joinTableInfo;
                    return this.executeSelect({
                        from: joinQuery.with,
                        where: joinQuery.where,
                        case: joinQuery.case,
                        flatten: joinQuery.flatten
                    }).then(function (results) {
                        _this.jointables(joinQuery.type, jointblInfo_1, results);
                        _this.tablesFetched.push(jointblInfo_1.table2.table);
                        ++_this.currentQueryStackIndex_;
                        return _this.startExecutingJoinLogic_();
                    });
                }
                catch (ex) {
                    return promiseReject(new log_helper_LogHelper(ERROR_TYPE.InvalidJoinQuery, ex.message));
                }
            }
            else {
                return this.onJoinQueryFinished_();
            }
        };
        Join.prototype.jointables = function (joinType, jointblInfo, secondtableData) {
            var _this = this;
            var results = [];
            var column1 = jointblInfo.table1.column;
            var column2 = jointblInfo.table2.column;
            var table1Index = this.tablesFetched.indexOf(jointblInfo.table1.table);
            var table2Index = this.currentQueryStackIndex_ + 1;
            var performInnerJoin = function () {
                var index = 0;
                _this.results.forEach(function (valueFromFirstTable) {
                    secondtableData.forEach(function (valueFromSecondTable) {
                        if (valueFromFirstTable[table1Index][column1] === valueFromSecondTable[column2]) {
                            results[index] = __assign({}, valueFromFirstTable);
                            results[index++][table2Index] = valueFromSecondTable;
                        }
                    });
                });
            };
            var performleftJoin = function () {
                var index = 0;
                var valueMatchedFromSecondTable;
                var callBack;
                var columnDefaultValue = {};
                _this.getTable(jointblInfo.table2.table).columns.forEach(function (col) {
                    columnDefaultValue[col.name] = null;
                });
                _this.results.forEach(function (valueFromFirstTable) {
                    valueMatchedFromSecondTable = [];
                    if (table2Index === 1) {
                        callBack = function (valueFromSecondTable) {
                            if (valueFromFirstTable[table1Index][column1] === valueFromSecondTable[column2]) {
                                valueMatchedFromSecondTable.push(valueFromSecondTable);
                            }
                        };
                    }
                    else {
                        callBack = function (valueFromSecondTable) {
                            var value = valueFromFirstTable[table1Index];
                            if (value != null && value[column1] === valueFromSecondTable[column2]) {
                                valueMatchedFromSecondTable.push(valueFromSecondTable);
                            }
                        };
                    }
                    secondtableData.forEach(callBack);
                    if (valueMatchedFromSecondTable.length === 0) {
                        valueMatchedFromSecondTable = [columnDefaultValue];
                    }
                    valueMatchedFromSecondTable.forEach(function (value) {
                        results[index] = __assign({}, valueFromFirstTable);
                        results[index++][table2Index] = value;
                    });
                });
            };
            switch (joinType) {
                case "left":
                    performleftJoin();
                    break;
                default:
                    performInnerJoin();
            }
            this.results = results;
        };
        Join.prototype.getJoinTableInfo_ = function (joinOn) {
            joinOn = removeSpace(joinOn);
            var splittedjoinOn = joinOn.split("=");
            var splittedjoinOnbydotFirst = splittedjoinOn[0].split(".");
            var splittedjoinOnbydotSecond = splittedjoinOn[1].split(".");
            var info = {
                table1: {
                    table: splittedjoinOnbydotFirst[0],
                    column: splittedjoinOnbydotFirst[1]
                },
                table2: {
                    table: splittedjoinOnbydotSecond[0],
                    column: splittedjoinOnbydotSecond[1]
                }
            };
            return info;
        };
        Join.prototype.checkJoinQuery_ = function (jointblInfo, qry) {
            var table1 = jointblInfo.table1;
            var table2 = jointblInfo.table2;
            var tableSchemaOf1stTable = this.getTable(table1.table);
            var tableSchemaOf2ndTable = this.getTable(table2.table);
            var err;
            // check on info & with info 
            if (qry.with !== table2.table) {
                err = new log_helper_LogHelper(ERROR_TYPE.InvalidJoinQuery, "on value should contains value of with");
            }
            // check for column existance
            if (tableSchemaOf1stTable.columns.find(function (q) { return q.name === table1.column; }) == null) {
                err = new log_helper_LogHelper(ERROR_TYPE.InvalidJoinQuery, "column " + table1.column + " does not exist in table " + table1.table);
            }
            else if (tableSchemaOf2ndTable.columns.find(function (q) { return q.name === table2.column; }) == null) {
                err = new log_helper_LogHelper(ERROR_TYPE.InvalidJoinQuery, "column " + table2.column + " does not exist in table " + table2.table);
            }
            // check for column match in both table
            if (qry.as == null) {
                qry.as = {};
            }
            tableSchemaOf1stTable.columns.every(function (column) {
                var columnFound = tableSchemaOf2ndTable.columns.find(function (q) { return q.name === column.name && q.name !== table1.column; });
                if (columnFound != null && qry.as[columnFound.name] == null) {
                    err = new log_helper_LogHelper(ERROR_TYPE.InvalidJoinQuery, "column " + column.name + " exist in both table " + table1.table + " & " + table2.table);
                    return false;
                }
                return true;
            });
            return err;
        };
        return Join;
    }());


    // CONCATENATED MODULE: ./src/worker/executors/select/index.ts
    var select_extends = (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var select_assign = function () {
        select_assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return select_assign.apply(this, arguments);
    };
    var __spreadArray = function (to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    };













    var select_Select = /** @class */ (function (_super) {
        select_extends(Select, _super);
        function Select(query, util) {
            var _this = _super.call(this) || this;
            _this.sorted = false;
            _this.isSubQuery = false;
            _this.thenEvaluator = new then_evaluator_ThenEvaluator();
            _this.returnResult_ = function () {
                if (_this.results.length > 0) {
                    if (_this.query.flatten) {
                        var flattendData_1 = [];
                        var indexToDelete_1 = {};
                        _this.query.flatten.forEach(function (column) {
                            _this.results.forEach(function (data, i) {
                                data[column].forEach(function (item) {
                                    var _a;
                                    flattendData_1.push(select_assign(select_assign({}, data), (_a = {}, _a[column] = item, _a)));
                                });
                                indexToDelete_1[i] = true;
                            });
                        });
                        var itemsDeleted_1 = 0;
                        getKeys(indexToDelete_1).forEach(function (key) {
                            _this.results.splice(Number(key) - itemsDeleted_1, 1);
                            ++itemsDeleted_1;
                        });
                        _this.results = _this.results.concat(flattendData_1);
                    }
                    _this.processGroupDistinctAggr();
                    _this.processOrderBy();
                    if (_this.shouldEvaluateSkipAtEnd) {
                        _this.results.splice(0, _this.query.skip);
                    }
                    if (_this.shouldEvaluateLimitAtEnd) {
                        _this.results = _this.results.slice(0, _this.query.limit);
                    }
                }
                return _this.results;
            };
            _this.query = query;
            _this.util = util;
            _this.tableName = query.from;
            _this.setPushResult();
            if (isArray(_this.query.where)) {
                _this.isArrayQry = true;
                _this.setLimitAndSkipEvaluationAtEnd_();
            }
            else {
                _this.skipRecord = query.skip;
                _this.limitRecord = query.limit;
            }
            if (query.order) {
                if (isArray(query.order) || query.order.case || isObject(query.order.by)) {
                    _this.query.order.idbSorting = false;
                }
                _this.setLimitAndSkipEvaluationAtEnd_();
            }
            else if (query.groupBy) {
                _this.setLimitAndSkipEvaluationAtEnd_();
            }
            return _this;
        }
        Select.prototype.execute = function (db) {
            this.db = db;
            var pResult;
            try {
                var err = new query_helper_QueryHelper(db).validate(API.Select, this.query);
                if (err)
                    return promiseReject(err);
                this.initTransaction_();
                if (this.query.join == null) {
                    if (this.query.where != null) {
                        if (isArray(this.query.where)) {
                            pResult = this.processWhereArrayQry();
                        }
                        else {
                            pResult = this.processWhere_();
                        }
                    }
                    else {
                        pResult = this.executeWhereUndefinedLogic();
                    }
                }
                else {
                    pResult = this.executeJoinQuery();
                }
                return pResult.then(this.returnResult_.bind(this));
            }
            catch (ex) {
                return this.onException(ex);
            }
        };
        Select.prototype.processWhereArrayQry = function () {
            var _this = this;
            this.isArrayQry = true;
            var whereQuery = this.query.where;
            var pKey = this.primaryKey();
            var isFirstWhere = true, output = [], operation;
            var isItemExist = function (keyValue) {
                return output.findIndex(function (item) { return item[pKey] === keyValue; }) >= 0;
            };
            var onSuccess = function () {
                if (operation === QUERY_OPTION.And) {
                    var doAnd = function () {
                        var andResults = [];
                        _this.results.forEach(function (item) {
                            if (isItemExist(item[pKey])) {
                                andResults.push(item);
                            }
                        });
                        output = andResults;
                        andResults = null;
                    };
                    if (isFirstWhere === true) {
                        output = _this.results;
                    }
                    else if (output.length > 0) {
                        doAnd();
                    }
                }
                else {
                    if (output.length > 0) {
                        _this.results = __spreadArray(__spreadArray([], output), _this.results);
                        _this.removeDuplicates();
                        output = _this.results;
                    }
                    else {
                        output = _this.results;
                    }
                }
                isFirstWhere = false;
                if (whereQuery.length > 0) {
                    _this.results = [];
                    return processFirstQry();
                }
                else {
                    _this.results = output;
                }
            };
            var processFirstQry = function () {
                _this.query.where = whereQuery.shift();
                if (_this.query.where[QUERY_OPTION.Or]) {
                    if (getLength(_this.query.where) === 1) {
                        operation = QUERY_OPTION.Or;
                        _this.query.where = _this.query.where[QUERY_OPTION.Or];
                    }
                    else {
                        operation = QUERY_OPTION.And;
                    }
                }
                else {
                    operation = QUERY_OPTION.And;
                }
                return _this.processWhere_().then(onSuccess);
            };
            return processFirstQry();
        };
        Select.prototype.initTransaction_ = function () {
            if (!this.isTxQuery) {
                this.util.createTransactionIfNotExist([this.tableName], IDB_MODE.ReadOnly);
            }
            this.objectStore = this.util.objectStore(this.tableName);
        };
        Select.prototype.processWhere_ = function () {
            var _this = this;
            this.shouldAddValue = function (value) {
                return _this.whereCheckerInstance.check(value);
            };
            if (this.query.where.or) {
                this.processOrLogic_();
            }
            return this.goToWhereLogic().then(function () {
                return _this.onWhereEvaluated();
            });
        };
        Select.prototype.onWhereEvaluated = function () {
            if (this.isOr) {
                return this.orQuerySuccess_();
            }
        };
        Select.prototype.orQueryFinish_ = function () {
            this.isOr = false;
            this.results = this.orInfo.results;
            // free or info memory
            this.orInfo = null;
            this.removeDuplicates();
            // this.onQueryFinished();
        };
        Select.prototype.orQuerySuccess_ = function () {
            this.orInfo.results = __spreadArray(__spreadArray([], this.orInfo.results), this.results);
            if (!this.query.limit || (this.query.limit > this.orInfo.results.length)) {
                this.results = [];
                var key = getObjectFirstKey(this.orInfo.orQuery);
                if (key != null) {
                    var where = {};
                    where[key] = this.orInfo.orQuery[key];
                    delete this.orInfo.orQuery[key];
                    this.query.where = where;
                    return this.goToWhereLogic().then(this.onWhereEvaluated.bind(this));
                }
            }
            return this.orQueryFinish_();
        };
        Select.prototype.processOrLogic_ = function () {
            this.isOr = true;
            var where = this.query.where;
            this.orInfo = {
                orQuery: where.or,
                results: []
            };
            // free or memory
            delete where.or;
        };
        return Select;
    }(base_fetch_BaseFetch));

    select_Select.prototype.executeInLogic = executeInLogic;
    select_Select.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;
    select_Select.prototype.executeWhereLogic = executeWhereLogic;
    select_Select.prototype.executeRegexLogic = executeRegexLogic;
    select_Select.prototype.setLimitAndSkipEvaluationAtEnd_ = setLimitAndSkipEvaluationAtEnd;
    select_Select.prototype.setPushResult = setPushResult;
    select_Select.prototype.removeDuplicates = removeDuplicates;
    select_Select.prototype.executeJoinQuery = executeJoinQuery;
    select_Select.prototype.processGroupDistinctAggr = processGroupDistinctAggr;
    select_Select.prototype.processOrderBy = processOrderBy;
    select_Select.prototype.processAggregateQry = processAggregateQry;
    select_Select.prototype.executeAggregateGroupBy = executeAggregateGroupBy;
    select_Select.prototype.processGroupBy = processGroupBy;

    // CONCATENATED MODULE: ./src/worker/executors/count/not_where.ts

    var not_where_executeWhereUndefinedLogic = function () {
        var _this = this;
        var countRequest;
        var onSuccess = (function () {
            if (_this.objectStore.count) {
                countRequest = _this.objectStore.count();
                return function (onFinish) {
                    return function () {
                        _this.resultCount = countRequest.result;
                        onFinish();
                    };
                };
            }
            else {
                var cursor_1;
                countRequest = _this.objectStore.openCursor();
                return function (onFinish) {
                    return function (e) {
                        cursor_1 = e.target.result;
                        if (cursor_1) {
                            ++_this.resultCount;
                            cursor_1.continue();
                        }
                        else {
                            onFinish();
                        }
                    };
                };
            }
        })();
        return promise(function (res, rej) {
            countRequest.onerror = rej;
            countRequest.onsuccess = onSuccess(res);
        });
    };

    // CONCATENATED MODULE: ./src/worker/executors/count/where.ts


    var where_executeWhereLogic = function (column, value, op) {
        var _this = this;
        value = op ? value[op] : value;
        var cursorRequest;
        var cursor;
        return promise(function (res, rej) {
            if (getLength(_this.query.where) === 1 && _this.objectStore.count) {
                cursorRequest = _this.objectStore.index(column).count(_this.util.keyRange(value, op));
                cursorRequest.onsuccess = function () {
                    _this.resultCount = cursorRequest.result;
                    res();
                };
            }
            else {
                cursorRequest = _this.objectStore.index(column).openCursor(_this.util.keyRange(value, op));
                cursorRequest.onsuccess = function (e) {
                    cursor = e.target.result;
                    if (cursor) {
                        if (_this.whereCheckerInstance.check(cursor.value)) {
                            ++_this.resultCount;
                        }
                        cursor.continue();
                    }
                    else {
                        res();
                    }
                };
            }
            cursorRequest.onerror = rej;
        });
    };

    // CONCATENATED MODULE: ./src/worker/executors/count/regex.ts

    var regex_executeRegexLogic = function (column, exp) {
        var _this = this;
        var cursor;
        var cursorRequest = this.objectStore.index(column).openCursor();
        this.shouldAddValue = function (cursor) {
            return exp.test(cursor.key) &&
                _this.whereCheckerInstance.check(cursor.value);
        };
        return promise(function (res, rej) {
            cursorRequest.onerror = rej;
            cursorRequest.onsuccess = function (e) {
                cursor = e.target.result;
                if (cursor) {
                    if (_this.shouldAddValue(cursor)) {
                        ++_this.resultCount;
                    }
                    cursor.continue();
                }
                else {
                    res();
                }
            };
        });
    };

    // CONCATENATED MODULE: ./src/worker/executors/count/in.ts

    var in_executeInLogic = function (column, values) {
        var _this = this;
        var cursor;
        var columnStore = this.objectStore.index(column);
        var runInLogic = function (value) {
            var keyRange = _this.util.keyRange(value);
            if (_this.objectStore.count) {
                return promise(function (res, rej) {
                    var cursorRequest = columnStore.count(keyRange);
                    cursorRequest.onsuccess = function (e) {
                        _this.resultCount += e.target.result;
                        res();
                    };
                    cursorRequest.onerror = rej;
                });
            }
            return promise(function (res, rej) {
                var cursorRequest = columnStore.openCursor(keyRange);
                cursorRequest.onsuccess = function (e) {
                    cursor = e.target.result;
                    if (cursor) {
                        if (_this.whereCheckerInstance.check(cursor.value)) {
                            ++_this.resultCount;
                        }
                        cursor.continue();
                    }
                    else {
                        res();
                    }
                };
                cursorRequest.onerror = rej;
            });
        };
        return promiseAll(values.map(function (val) {
            return runInLogic(val);
        }));
    };

    // CONCATENATED MODULE: ./src/worker/executors/count/index.ts
    var count_extends = (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();









    var count_Count = /** @class */ (function (_super) {
        count_extends(Count, _super);
        function Count(query, util) {
            var _this = _super.call(this) || this;
            _this.resultCount = 0;
            _this.query = query;
            _this.util = util;
            _this.tableName = query.from;
            return _this;
        }
        Count.prototype.execute = function (db) {
            var _this = this;
            this.db = db;
            var queryHelper = new query_helper_QueryHelper(db);
            var query = this.query;
            var err = queryHelper.validate(API.Count, query);
            if (err) {
                return promiseReject(err);
            }
            try {
                var result = void 0;
                var getDataFromSelect = function () {
                    var selectInstance = new select_Select(_this.query, _this.util);
                    selectInstance.isTxQuery = _this.isTxQuery;
                    return selectInstance.execute(db).then(function (results) {
                        _this.resultCount = results.length;
                    });
                };
                this.initTransaction_();
                if (query.join == null) {
                    if (query.where != null) {
                        if (query.where.or || isArray(this.query.where)) {
                            result = getDataFromSelect();
                        }
                        else {
                            result = this.goToWhereLogic();
                        }
                    }
                    else {
                        result = this.executeWhereUndefinedLogic();
                    }
                }
                else {
                    result = getDataFromSelect();
                }
                return result.then(function (_) {
                    return _this.resultCount;
                });
            }
            catch (ex) {
                this.onException(ex);
            }
        };
        Count.prototype.initTransaction_ = function () {
            if (!this.isTxQuery) {
                this.util.createTransaction([this.query.from], IDB_MODE.ReadOnly);
            }
            this.objectStore = this.util.objectStore(this.query.from);
        };
        return Count;
    }(base_fetch_BaseFetch));

    count_Count.prototype.executeWhereUndefinedLogic = not_where_executeWhereUndefinedLogic;
    count_Count.prototype.executeWhereLogic = where_executeWhereLogic;
    count_Count.prototype.executeRegexLogic = regex_executeRegexLogic;
    count_Count.prototype.executeInLogic = in_executeInLogic;

    // CONCATENATED MODULE: ./src/worker/executors/update/update_value.ts


    var updateValue = function (suppliedValue, storedValue) {
        for (var key in suppliedValue) {
            if (getDataType(suppliedValue[key]) !== DATA_TYPE.Object) {
                storedValue[key] = suppliedValue[key];
            }
            else {
                for (var op in suppliedValue[key]) {
                    switch (op) {
                        case '+':
                            storedValue[key] += suppliedValue[key][op];
                            break;
                        case '-':
                            storedValue[key] -= suppliedValue[key][op];
                            break;
                        case '*':
                            storedValue[key] *= suppliedValue[key][op];
                            break;
                        case '/':
                            storedValue[key] /= suppliedValue[key][op];
                            break;
                        case '{push}':
                            storedValue[key].push(suppliedValue[key][op]);
                            break;
                        default: storedValue[key] = suppliedValue[key];
                    }
                    break;
                }
            }
        }
        return storedValue;
    };

    // CONCATENATED MODULE: ./src/worker/executors/update/not_where.ts


    var update_not_where_executeWhereUndefinedLogic = function () {
        var _this = this;
        var cursorRequest = this.objectStore.openCursor();
        var setValue = this.query.set;
        return promise(function (res, rej) {
            cursorRequest.onsuccess = function (e) {
                var cursor = e.target.result;
                if (cursor) {
                    try {
                        var cursorUpdateRequest = cursor.update(updateValue(setValue, cursor.value));
                        cursorUpdateRequest.onsuccess = function () {
                            ++_this.rowAffected;
                            cursor.continue();
                        };
                        cursorUpdateRequest.onerror = rej;
                    }
                    catch (ex) {
                        rej(ex);
                    }
                }
                else {
                    res();
                }
            };
            cursorRequest.onerror = rej;
        });
    };

    // CONCATENATED MODULE: ./src/worker/executors/update/in.ts


    var update_in_executeInLogic = function (column, values) {
        var _this = this;
        var columnStore = this.objectStore.index(column);
        var query = this.query;
        var runInLogic = function (value) {
            return promise(function (res, rej) {
                var cursorRequest = columnStore.openCursor(_this.util.keyRange(value));
                cursorRequest.onsuccess = function (e) {
                    var cursor = e.target.result;
                    if (cursor) {
                        var value_1 = cursor.value;
                        if (_this.whereCheckerInstance.check(value_1)) {
                            try {
                                var cursorUpdateRequest = cursor.update(updateValue(query.set, value_1));
                                cursorUpdateRequest.onsuccess = function () {
                                    ++_this.rowAffected;
                                    cursor.continue();
                                };
                                cursorUpdateRequest.onerror = rej;
                            }
                            catch (ex) {
                                rej(ex);
                            }
                        }
                        else {
                            cursor.continue();
                        }
                    }
                    else {
                        res();
                    }
                };
                cursorRequest.onerror = rej;
            });
        };
        return promiseAll(values.map(function (val) {
            return runInLogic(val);
        }));
    };

    // CONCATENATED MODULE: ./src/worker/executors/update/regex.ts


    var update_regex_executeRegexLogic = function (column, exp) {
        var _this = this;
        var cursor;
        var cursorOpenRequest = this.objectStore.index(column).openCursor();
        this.shouldAddValue = function (cursor) {
            return exp.test(cursor.key) &&
                _this.whereCheckerInstance.check(cursor.value);
        };
        var setValue = this.query.set;
        return promise(function (res, rej) {
            cursorOpenRequest.onsuccess = function (e) {
                cursor = e.target.result;
                if (cursor) {
                    if (_this.shouldAddValue(cursor)) {
                        try {
                            var cursorUpdateRequest = cursor.update(updateValue(setValue, cursor.value));
                            cursorUpdateRequest.onsuccess = function () {
                                ++_this.rowAffected;
                                cursor.continue();
                            };
                            cursorUpdateRequest.onerror = rej;
                        }
                        catch (ex) {
                            rej(ex);
                        }
                    }
                    else {
                        cursor.continue();
                    }
                }
                else {
                    res();
                }
            };
            cursorOpenRequest.onerror = rej;
        });
    };

    // CONCATENATED MODULE: ./src/worker/executors/update/where.ts


    var update_where_executeWhereLogic = function (column, value, op) {
        var _this = this;
        value = op ? value[op] : value;
        var cursorRequest = this.objectStore.index(column).openCursor(this.util.keyRange(value, op));
        var setValue = this.query.set;
        return promise(function (res, rej) {
            cursorRequest.onsuccess = function (e) {
                var cursor = e.target.result;
                if (cursor) {
                    if (_this.whereCheckerInstance.check(cursor.value)) {
                        try {
                            var cursorUpdateRequest = cursor.update(updateValue(setValue, cursor.value));
                            cursorUpdateRequest.onsuccess = function () {
                                ++_this.rowAffected;
                                cursor.continue();
                            };
                            cursorUpdateRequest.onerror = rej;
                        }
                        catch (ex) {
                            rej(ex);
                        }
                    }
                    else {
                        cursor.continue();
                    }
                }
                else {
                    res();
                }
            };
            cursorRequest.onerror = rej;
        });
    };

    // CONCATENATED MODULE: ./src/worker/executors/update/index.ts
    var update_extends = (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();









    var update_Update = /** @class */ (function (_super) {
        update_extends(Update, _super);
        function Update(query, util) {
            var _this = _super.call(this) || this;
            _this.query = query;
            _this.util = util;
            _this.tableName = query.in;
            return _this;
        }
        Update.prototype.execute = function (db) {
            var _this = this;
            this.db = db;
            var query = this.query;
            try {
                var queryHelper = new query_helper_QueryHelper(db);
                var err = queryHelper.validate(API.Update, query);
                if (err)
                    return promiseReject(err);
                this.initTransaction();
                var pResult = void 0;
                if (query.where != null) {
                    if (query.where.or || isArray(query.where)) {
                        pResult = this.executeComplexLogic_();
                    }
                    else {
                        pResult = this.goToWhereLogic();
                    }
                }
                else {
                    pResult = this.executeWhereUndefinedLogic();
                }
                return pResult.then(function () {
                    return _this.rowAffected;
                });
            }
            catch (ex) {
                return this.onException(ex);
            }
        };
        Update.prototype.executeComplexLogic_ = function () {
            var _this = this;
            var query = this.query;
            var selectObject = new select_Select({
                from: query.in,
                where: query.where,
                ignoreCase: query.ignoreCase
            }, this.util);
            selectObject.isTxQuery = this.isTxQuery;
            return selectObject.execute(this.db).then(function (results) {
                var _a, _b;
                var key = _this.primaryKey(query.in);
                var inQuery = [];
                results.forEach(function (value) {
                    inQuery.push(value[key]);
                });
                results = null;
                var whereQry = (_a = {}, _a[key] = (_b = {}, _b[QUERY_OPTION.In] = inQuery, _b), _a);
                _this.query.where = whereQry;
                _this.initTransaction();
                return _this.goToWhereLogic();
            });
        };
        Update.prototype.initTransaction = function () {
            var tableName = this.query.in;
            if (!this.isTxQuery) {
                this.util.createTransaction([tableName]);
            }
            this.objectStore = this.util.objectStore(tableName);
        };
        return Update;
    }(base_fetch_BaseFetch));

    update_Update.prototype.executeWhereUndefinedLogic = update_not_where_executeWhereUndefinedLogic;
    update_Update.prototype.executeWhereLogic = update_where_executeWhereLogic;
    update_Update.prototype.executeRegexLogic = update_regex_executeRegexLogic;
    update_Update.prototype.executeInLogic = update_in_executeInLogic;

    // CONCATENATED MODULE: ./src/worker/intersect/index.ts
    var intersect_extends = (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var intersect_assign = function () {
        intersect_assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return intersect_assign.apply(this, arguments);
    };


    var intersect_Intersect = /** @class */ (function (_super) {
        intersect_extends(Intersect, _super);
        function Intersect(intersectQry, util) {
            var _this = _super.call(this) || this;
            _this.query = intersectQry;
            _this.util = util;
            return _this;
        }
        Intersect.prototype.execute = function (db) {
            var _this = this;
            this.db = db;
            var intersectQry = this.query;
            var index = 0;
            var hashMap = {};
            var hashMapTemp = {};
            var isQueryForSameTable = true;
            var queries = intersectQry.queries;
            var queryLength = queries.length;
            queries.every(function (qry, i) {
                if (i + 1 < queryLength && qry.from !== queries[i + 1].from) {
                    isQueryForSameTable = false;
                    return false;
                }
                return true;
            });
            var getHashKey;
            if (isQueryForSameTable) {
                var pKey_1 = this.primaryKey(queries[0].from);
                getHashKey = function (val) {
                    return val[pKey_1];
                };
            }
            else {
                getHashKey = function (val) {
                    var columnValKey = "";
                    for (var key in val) {
                        columnValKey += val[key];
                    }
                    return columnValKey;
                };
            }
            var select;
            var fetchData = function () {
                if (index < queryLength) {
                    select = new select_Select(queries[index], _this.util);
                    return select.execute(_this.db).then(function (selectResult) {
                        hashMap = {};
                        selectResult.forEach(function (val) {
                            var columnValKey = getHashKey(val);
                            if (index === 0) {
                                hashMapTemp[columnValKey] = val;
                            }
                            else if (hashMapTemp[columnValKey] != null) {
                                hashMap[columnValKey] = val;
                            }
                        });
                        if (index > 0) {
                            hashMapTemp = intersect_assign({}, hashMap);
                        }
                        ++index;
                        return fetchData();
                    });
                }
                else {
                    var results_1 = [];
                    var resultPusher = void 0;
                    var skip_1 = intersectQry.skip;
                    var limit_1 = intersectQry.limit;
                    var onFinished = function () {
                        select['results'] = results_1;
                        Object.assign(select.query, {
                            order: intersectQry.order,
                            join: {}
                        });
                        select.processOrderBy();
                        select.processGroupDistinctAggr();
                        return (select['results']);
                    };
                    var shouldStopLoop_1 = false;
                    var key_1;
                    var pushResult_1 = function () {
                        results_1.push(hashMap[key_1]);
                    };
                    var checkLimitAndPush_1 = function () {
                        if (results_1.length < limit_1) {
                            pushResult_1();
                        }
                        else {
                            shouldStopLoop_1 = true;
                        }
                    };
                    var skipChecker_1 = function (callBack) {
                        if (skip_1 === 0) {
                            callBack();
                        }
                        else {
                            --skip_1;
                        }
                    };
                    if (intersectQry.skip && intersectQry.limit) {
                        resultPusher = function () {
                            skipChecker_1(function () {
                                checkLimitAndPush_1();
                            });
                        };
                    }
                    else if (intersectQry.limit) {
                        resultPusher = checkLimitAndPush_1;
                    }
                    else if (intersectQry.skip) {
                        resultPusher = function () {
                            skipChecker_1(function () {
                                pushResult_1();
                            });
                        };
                    }
                    else {
                        resultPusher = function () {
                            pushResult_1();
                        };
                    }
                    if (limit_1) {
                        for (key_1 in hashMap) {
                            resultPusher(key_1);
                            if (shouldStopLoop_1) {
                                break;
                            }
                        }
                    }
                    else {
                        for (key_1 in hashMap) {
                            resultPusher(key_1);
                        }
                    }
                    return onFinished();
                }
            };
            return fetchData();
        };
        return Intersect;
    }(base_Base));


    // CONCATENATED MODULE: ./src/worker/executors/drop_db.ts


    var drop_db_DropDb = /** @class */ (function () {
        function DropDb() {
        }
        DropDb.prototype.execute = function (dbName) {
            return promise(function (res, rej) {
                var dropDbRequest = indexedDB.deleteDatabase(dbName);
                dropDbRequest.onblocked = function () {
                    var err = new log_helper_LogHelper(ERROR_TYPE.DbBlocked);
                    return rej(getError(err));
                };
                dropDbRequest.onerror = function (e) {
                    return rej(getError(e));
                };
                dropDbRequest.onsuccess = function () {
                    res();
                };
            });
        };
        return DropDb;
    }());


    // CONCATENATED MODULE: ./src/worker/union/index.ts
    var union_extends = (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();


    var union_Union = /** @class */ (function (_super) {
        union_extends(Union, _super);
        function Union(query, util) {
            var _this = _super.call(this) || this;
            _this.query = query;
            _this.util = util;
            return _this;
        }
        Union.prototype.execute = function (db) {
            var _this = this;
            this.db = db;
            var query = this.query;
            var index = 0;
            var hashMap = {};
            var isQueryForSameTable = true;
            var queryLength = query.length;
            query.every(function (qry, i) {
                if (i + 1 < queryLength && qry.from !== query[i + 1].from) {
                    isQueryForSameTable = false;
                    return false;
                }
                return true;
            });
            var getHashKey;
            if (isQueryForSameTable) {
                var pKey_1 = this.primaryKey(query[0].from);
                getHashKey = function (val) {
                    return val[pKey_1];
                };
            }
            else {
                getHashKey = function (val) {
                    var columnValKey = "";
                    for (var key in val) {
                        columnValKey += val[key];
                    }
                    return columnValKey;
                };
            }
            var select;
            var fetchData = function () {
                if (index < query.length) {
                    select = new select_Select(query[index++], _this.util);
                    return select.execute(db).then(function (selectResult) {
                        selectResult.forEach(function (val) {
                            hashMap[getHashKey(val)] = val;
                        });
                        return fetchData();
                    });
                }
                else {
                    var results = [];
                    for (var key in hashMap) {
                        results.push(hashMap[key]);
                    }
                    return results;
                }
            };
            return fetchData();
        };
        return Union;
    }(base_Base));


    // CONCATENATED MODULE: ./src/worker/executors/remove/not_where.ts

    var remove_not_where_executeWhereUndefinedLogic = function () {
        var _this = this;
        var cursor;
        var cursorRequest = this.objectStore.openCursor();
        return promise(function (res, rej) {
            cursorRequest.onsuccess = function (e) {
                cursor = e.target.result;
                if (cursor) {
                    cursor.delete();
                    ++_this.rowAffected;
                    cursor.continue();
                }
                else {
                    res();
                }
            };
            cursorRequest.onerror = rej;
        });
    };

    // CONCATENATED MODULE: ./src/worker/executors/remove/in.ts

    var remove_in_executeInLogic = function (column, values) {
        var _this = this;
        var columnIndex = this.objectStore.index(column);
        var runInLogic = function (value) {
            return promise(function (res, rej) {
                var cursorRequest = columnIndex.openCursor(_this.util.keyRange(value));
                cursorRequest.onsuccess = function (e) {
                    var cursor = e.target.result;
                    if (cursor) {
                        if (_this.whereCheckerInstance.check(cursor.value)) {
                            cursor.delete();
                            ++_this.rowAffected;
                        }
                        cursor.continue();
                    }
                    else {
                        res();
                    }
                };
                cursorRequest.onerror = rej;
            });
        };
        return promiseAll(values.map(function (val) {
            return runInLogic(val);
        }));
    };

    // CONCATENATED MODULE: ./src/worker/executors/remove/where.ts

    var remove_where_executeWhereLogic = function (column, value, op) {
        var _this = this;
        var cursor, cursorRequest;
        value = op ? value[op] : value;
        cursorRequest = this.objectStore.index(column).openCursor(this.util.keyRange(value, op));
        return promise(function (res, rej) {
            cursorRequest.onsuccess = function (e) {
                cursor = e.target.result;
                if (cursor) {
                    if (_this.whereCheckerInstance.check(cursor.value)) {
                        cursor.delete();
                        ++_this.rowAffected;
                    }
                    cursor.continue();
                }
                else {
                    res();
                }
            };
            cursorRequest.onerror = rej;
        });
    };

    // CONCATENATED MODULE: ./src/worker/executors/remove/regex.ts

    var remove_regex_executeRegexLogic = function (column, exp) {
        var _this = this;
        var cursor;
        var cursorRequest = this.objectStore.index(column).openCursor();
        this.shouldAddValue = function (cursor) {
            return exp.test(cursor.key) &&
                _this.whereCheckerInstance.check(cursor.value);
        };
        return promise(function (res, rej) {
            cursorRequest.onsuccess = function (e) {
                cursor = e.target.result;
                if (cursor) {
                    if (_this.shouldAddValue(cursor)) {
                        cursor.delete();
                        ++_this.rowAffected;
                    }
                    cursor.continue();
                }
                else {
                    res();
                }
            };
            cursorRequest.onerror = rej;
        });
    };

    // CONCATENATED MODULE: ./src/worker/executors/remove/index.ts
    var remove_extends = (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();









    var remove_Remove = /** @class */ (function (_super) {
        remove_extends(Remove, _super);
        function Remove(query, util) {
            var _this = _super.call(this) || this;
            _this.query = query;
            _this.util = util;
            _this.tableName = query.from;
            return _this;
        }
        Remove.prototype.execute = function (db) {
            var _this = this;
            this.db = db;
            var queryHelper = new query_helper_QueryHelper(db);
            var query = this.query;
            var err = queryHelper.validate(API.Remove, query);
            if (err)
                return promiseReject(err);
            try {
                this.initTransaction_();
                var pResult = void 0;
                if (query.where != null) {
                    if (isArray(query.where)) {
                        pResult = this.processWhereArrayQry();
                    }
                    else {
                        pResult = this.processWhere_();
                    }
                }
                else {
                    pResult = this.executeWhereUndefinedLogic();
                }
                return pResult.then(function () {
                    return _this.rowAffected;
                });
            }
            catch (ex) {
                return this.onException(ex);
            }
        };
        Remove.prototype.processWhereArrayQry = function () {
            var _this = this;
            var selectObject = new select_Select(this.query, this.util);
            selectObject.isTxQuery = this.isTxQuery;
            return selectObject.execute(this.db).then(function (results) {
                var _a, _b;
                var keyList = [];
                var pkey = _this.primaryKey(_this.query.from);
                results.forEach(function (item) {
                    keyList.push(item[pkey]);
                });
                results = null;
                var whereQry = (_a = {}, _a[pkey] = (_b = {}, _b[QUERY_OPTION.In] = keyList, _b), _a);
                _this.query[QUERY_OPTION.Where] = whereQry;
                return _this.processWhere_();
            });
        };
        Remove.prototype.processWhere_ = function () {
            var _this = this;
            if (this.query.where.or) {
                this.processOrLogic();
            }
            return this.goToWhereLogic().then(function () {
                return _this.onWhereEvaluated();
            });
        };
        Remove.prototype.initTransaction_ = function () {
            if (!this.isTxQuery) {
                this.util.createTransaction([this.query.from]);
            }
            this.objectStore = this.util.objectStore(this.query.from);
        };
        Remove.prototype.onWhereEvaluated = function () {
            if (this.isOr) {
                return this.orQuerySuccess_();
            }
        };
        Remove.prototype.orQuerySuccess_ = function () {
            var _this = this;
            var key = getObjectFirstKey(this._orInfo.OrQuery);
            if (key != null) {
                var where = {};
                where[key] = this._orInfo.OrQuery[key];
                delete this._orInfo.OrQuery[key];
                this.query.where = where;
                return this.goToWhereLogic().then(function () {
                    return _this.onWhereEvaluated();
                });
            }
            else {
                this.isOr = true;
            }
        };
        Remove.prototype.processOrLogic = function () {
            this.isOr = true;
            var where = this.query.where;
            this._orInfo = {
                OrQuery: where.or
            };
            // free or memory
            delete where.or;
        };
        return Remove;
    }(base_fetch_BaseFetch));

    remove_Remove.prototype.executeInLogic = remove_in_executeInLogic;
    remove_Remove.prototype.executeWhereUndefinedLogic = remove_not_where_executeWhereUndefinedLogic;
    remove_Remove.prototype.executeWhereLogic = remove_where_executeWhereLogic;
    remove_Remove.prototype.executeRegexLogic = remove_regex_executeRegexLogic;

    // CONCATENATED MODULE: ./src/worker/executors/clear/index.ts
    var clear_extends = (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();



    var clear_Clear = /** @class */ (function (_super) {
        clear_extends(Clear, _super);
        function Clear(tableName, util) {
            var _this = _super.call(this) || this;
            _this.query = tableName;
            _this.util = util;
            _this.tableName = tableName;
            return _this;
        }
        Clear.prototype.execute = function (db) {
            var _this = this;
            this.db = db;
            var tableName = this.query;
            if (!this.isTxQuery) {
                this.util.createTransaction([tableName, meta_helper_MetaHelper.tableName]);
            }
            var clearRequest = this.util.objectStore(tableName).clear();
            try {
                return promise(function (res, rej) {
                    clearRequest.onsuccess = function (e) {
                        var currentTable = _this.table(tableName);
                        for (var columnName in currentTable.autoIncColumnValue) {
                            currentTable.autoIncColumnValue[columnName] = 0;
                        }
                        meta_helper_MetaHelper.set(meta_helper_MetaHelper.dbSchema, db, _this.util).then(function () {
                            res();
                        }).catch(rej);
                    };
                    clearRequest.onerror = rej;
                });
            }
            catch (ex) {
                return this.onException(ex);
            }
        };
        return Clear;
    }(base_Base));


    // CONCATENATED MODULE: ./src/worker/utils/resolve.ts

    var variableFromPath = function (path) {
        var properties = isArray(path) ? path : path.split(".");
        return properties.reduce(function (prev, curr) { return prev && prev[curr]; }, self);
    };

    // CONCATENATED MODULE: ./src/worker/executors/transaction/index.ts
    var transaction_extends = (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();









    var transaction_Transaction = /** @class */ (function (_super) {
        transaction_extends(Transaction, _super);
        function Transaction(qry, util) {
            var _this = _super.call(this) || this;
            _this.results = {};
            _this.reqQueue = [];
            _this.isQueryExecuting = false;
            _this.isTxStarted_ = false;
            _this.query = qry;
            _this.util = util;
            return _this;
        }
        Transaction.prototype.execute = function (db) {
            var _this = this;
            this.db = db;
            var err = this.validate();
            if (err)
                return promiseReject(err);
            this.startExecution_();
            return promise(function (res, rej) {
                _this.onSuccess = res;
                _this.onError = rej;
            }).then(function (result) {
                _this.log("transaction finished");
                return result;
            });
        };
        Transaction.prototype.validate = function () {
            var query = this.query;
            var notExistingTable = this.notExistingTable_(query.tables);
            if (notExistingTable) {
                return new log_helper_LogHelper(ERROR_TYPE.TableNotExist, { tableName: notExistingTable });
            }
            var methodName = query.method;
            var txLogic = variableFromPath(methodName);
            if (!txLogic) {
                return new log_helper_LogHelper(ERROR_TYPE.MethodNotExist, methodName);
            }
        };
        Transaction.prototype.startExecution_ = function () {
            var _this = this;
            var query = this.query;
            var select = function (qry) {
                return _this.pushReq_({
                    name: API.Select,
                    query: qry
                });
            };
            var insert = function (qry) {
                return _this.pushReq_({
                    name: API.Insert,
                    query: qry
                });
            };
            var update = function (qry) {
                return _this.pushReq_({
                    name: API.Update,
                    query: qry
                });
            };
            var remove = function (qry) {
                return _this.pushReq_({
                    name: API.Remove,
                    query: qry
                });
            };
            var count = function (qry) {
                return _this.pushReq_({
                    name: API.Count,
                    query: qry
                });
            };
            var setResult = function (key, value) {
                _this.results[key] = value;
            };
            var getResult = function (key) {
                return _this.results[key];
            };
            var abort = function (msg) {
                _this.abortTx_(msg);
            };
            var start = function () {
                _this.startTx_();
            };
            var methodName = query.method;
            var txLogic = variableFromPath(methodName);
            this.log("transaction query started");
            return txLogic.call(this, {
                data: query.data,
                insert: insert, select: select,
                update: update, remove: remove,
                count: count, setResult: setResult,
                getResult: getResult, abort: abort,
                start: start
            });
        };
        Transaction.prototype.log = function (message) {
            this.util.logger.log(message);
        };
        Transaction.prototype.startTx_ = function () {
            var _this = this;
            try {
                this.isTxStarted_ = true;
                var tableNames = this.query.tables;
                tableNames = tableNames.concat(meta_helper_MetaHelper.tableName);
                this.util.createTransaction(tableNames).then(function (_) {
                    _this.onSuccess(_this.results);
                }).catch(function (err) {
                    _this.onError(err);
                });
                return this.processExecutionOfQry_();
            }
            catch (ex) {
                this.onError(this.onException(ex));
            }
        };
        Transaction.prototype.onReqFinished_ = function (result) {
            var finisehdRequest = this.reqQueue.shift();
            this.log("finished request : " + finisehdRequest.name + " ");
            if (finisehdRequest) {
                if (result.error) {
                    this.abortTx_("automatic abort of transaction due to error occured");
                    this.log("transaction aborted due to error occured");
                    this.onError(result.error);
                }
                else {
                    this.isQueryExecuting = false;
                    if (finisehdRequest.onSuccess) {
                        finisehdRequest.onSuccess(result);
                    }
                    this.processExecutionOfQry_();
                }
            }
        };
        Transaction.prototype.abortTx_ = function (msg) {
            this.reqQueue = [];
            this.util.abortTransaction();
            this.log("transaction aborted. Msg : " + msg);
        };
        Transaction.prototype.executeRequest_ = function (request) {
            this.isQueryExecuting = true;
            var requestObj;
            this.log("executing request : " + request.name + " ");
            var onReqFinished = this.onReqFinished_.bind(this);
            var query = request.query;
            switch (request.name) {
                case API.Select:
                    requestObj = new select_Select(query, this.util);
                    break;
                case API.Insert:
                    requestObj = new insert_Insert(query, this.util);
                    break;
                case API.Update:
                    requestObj = new update_Update(query, this.util);
                    break;
                case API.Remove:
                    requestObj = new remove_Remove(query, this.util);
                    break;
                case API.Count:
                    requestObj = new count_Count(query, this.util);
                    break;
            }
            requestObj.isTxQuery = true;
            requestObj.execute(this.db).then(onReqFinished).catch(function (err) {
                var result = {
                    error: err
                };
                onReqFinished(result);
            });
        };
        Transaction.prototype.pushReq_ = function (request) {
            var _this = this;
            var push = function () {
                _this.reqQueue.push(request);
            };
            var promiseObj = promise(function (resolve, reject) {
                request.onSuccess = function (result) {
                    resolve(result);
                };
                request.onError = function (error) {
                    reject(error);
                };
            });
            if (this.isTxStarted_ === true) {
                push();
                this.processExecutionOfQry_();
            }
            else {
                push();
            }
            this.log("request pushed : " + request.name);
            return promiseObj;
        };
        Transaction.prototype.processExecutionOfQry_ = function () {
            if (this.isQueryExecuting === false) {
                if (this.reqQueue.length > 0) {
                    this.executeRequest_(this.reqQueue[0]);
                }
            }
        };
        Transaction.prototype.notExistingTable_ = function (tables) {
            var _this = this;
            var invalidTable = null;
            tables.every(function (tableName) {
                var table = _this.table(tableName);
                if (table == null) {
                    invalidTable = tableName;
                    return false;
                }
                return true;
            });
            return invalidTable;
        };
        return Transaction;
    }(base_Base));


    // CONCATENATED MODULE: ./src/worker/utils/db_schema.ts
    var userDbSchema = function (db) {
        var database = {
            name: db.name,
            version: db.version,
            tables: []
        };
        db.tables.forEach(function (table) {
            var tableAsObj = {
                name: table.name,
                columns: {}
            };
            table.columns.forEach(function (column) {
                tableAsObj.columns[column.name] = column;
            });
            database.tables.push(tableAsObj);
        });
        return database;
    };

    // CONCATENATED MODULE: ./src/worker/query_manager.ts
















    var query_manager_QueryManager = /** @class */ (function () {
        function QueryManager(fn) {
            this.middlewares = [];
            this.util = new idbutil_IDBUtil();
            this.onQryFinished = IS_WORKER ? function (result) {
                self.postMessage(result);
            } : fn;
        }
        Object.defineProperty(QueryManager.prototype, "logger", {
            get: function () {
                return this.util.logger;
            },
            enumerable: false,
            configurable: true
        });
        QueryManager.prototype.executeMiddleware_ = function (request) {
            var _this = this;
            var lastIndex = getLength(this.middlewares) - 1;
            if (lastIndex < 0) {
                return promiseResolve();
            }
            var middlewareContext = {};
            var db = this.db;
            Object.defineProperty(middlewareContext, 'database', {
                get: function () {
                    return userDbSchema(db);
                }
            });
            return promise(function (res) {
                var index = 0;
                var callNextMiddleware = function () {
                    if (index <= lastIndex) {
                        var promiseResult = variableFromPath(_this.middlewares[index++])(request, middlewareContext);
                        if (!promiseResult || !promiseResult.then) {
                            promiseResult = Promise.resolve(promiseResult);
                        }
                        promiseResult.then(function (_) {
                            callNextMiddleware();
                        });
                    }
                    else {
                        res();
                    }
                };
                callNextMiddleware();
            });
        };
        QueryManager.prototype.executeQuery = function (request) {
            var queryResult;
            var query = request.query;
            switch (request.name) {
                case API.OpenDb:
                    queryResult = this.openDb(query);
                    break;
                case API.InitDb:
                    queryResult = this.initDb(query);
                    break;
                case API.CloseDb:
                    queryResult = this.closeDb();
                    break;
                case API.Insert:
                    queryResult = new insert_Insert(query, this.util).
                        execute(this.db);
                    break;
                case API.Select:
                    queryResult = new select_Select(query, this.util).
                        execute(this.db);
                    break;
                case API.Count:
                    queryResult = new count_Count(query, this.util).execute(this.db);
                    break;
                case API.Update:
                    queryResult = new update_Update(query, this.util).execute(this.db);
                    break;
                case API.Intersect:
                    queryResult = new intersect_Intersect(query, this.util).execute(this.db);
                    break;
                case API.DropDb:
                    queryResult = this.dropDb();
                    break;
                case API.Terminate:
                    queryResult = this.terminate();
                    break;
                case API.Union:
                    queryResult = new union_Union(query, this.util).execute(this.db);
                    break;
                case API.Remove:
                    queryResult = new remove_Remove(query, this.util).execute(this.db);
                    break;
                case API.Clear:
                    queryResult = new clear_Clear(query, this.util).execute(this.db);
                    break;
                case API.Transaction:
                    queryResult = new transaction_Transaction(query, this.util).execute(this.db);
                    break;
                case API.Get:
                    queryResult = meta_helper_MetaHelper.get(query, this.util);
                    break;
                case API.Set:
                    queryResult = meta_helper_MetaHelper.set(query.key, query.value, this.util);
                    break;
                case API.ImportScripts:
                    queryResult = this.importScripts_(request);
                    break;
                case API.ChangeLogStatus:
                    this.logger.status = query;
                    queryResult = Promise.resolve();
                    break;
                case API.Middleware:
                    var value = variableFromPath(query);
                    if (!value) {
                        return promiseReject(new log_helper_LogHelper(ERROR_TYPE.InvalidMiddleware, query));
                    }
                    this.middlewares.push(query);
                    return promiseResolve();
                default:
                    {
                        console.error('The Api:-' + request.name + ' does not support.');
                    }
                    queryResult = promiseResolve();
            }
            this.logger.log("Executing query " + request.name + " in web worker");
            return queryResult;
        };
        QueryManager.prototype.callResultMiddleware = function (middlewares, result) {
            return promise(function (res) {
                var index = 0;
                var lastIndex = getLength(middlewares) - 1;
                var callNextMiddleware = function () {
                    if (index <= lastIndex) {
                        var promiseResult = middlewares[index++](result);
                        if (!promiseResult.then) {
                            promiseResult = promiseResolve(promiseResult);
                        }
                        promiseResult.then(function (modifiedResult) {
                            result = modifiedResult;
                            callNextMiddleware();
                        });
                    }
                    else {
                        res(result);
                    }
                };
                callNextMiddleware();
            });
        };
        QueryManager.prototype.run = function (request) {
            var _this = this;
            var middlewares = [];
            request.onResult = function (cb) {
                middlewares.push(function (result) {
                    return cb(result);
                });
            };
            this.executeMiddleware_(request).then(function (_) {
                return _this.executeQuery(request).then(function (result) {
                    return _this.callResultMiddleware(middlewares, result).then(function (modifiedResult) {
                        _this.returnResult_({
                            result: modifiedResult
                        });
                    });
                });
            }).catch(function (ex) {
                middlewares = [];
                var err = getError(ex);
                var result = {
                    error: err
                };
                _this.returnResult_(result);
            });
        };
        QueryManager.prototype.importScripts_ = function (request) {
            return promise(function (res, rej) {
                try {
                    importScripts.apply(void 0, request.query);
                    res();
                }
                catch (e) {
                    var err = new log_helper_LogHelper(ERROR_TYPE.ImportScriptsFailed, e.message);
                    rej(err);
                }
            });
        };
        QueryManager.prototype.returnResult_ = function (result) {
            this.logger.log("Query finished inside web worker");
            if (this.util) {
                this.util.emptyTx();
            }
            this.onQryFinished(result);
        };
        QueryManager.prototype.dropDb = function () {
            var dbName = this.db.name;
            return this.terminate().then(function () {
                return new drop_db_DropDb().execute(dbName);
            });
        };
        QueryManager.prototype.closeDb = function () {
            return this.util.close();
        };
        QueryManager.prototype.terminate = function () {
            var _this = this;
            return this.closeDb().then(function () {
                _this.db = null;
            });
        };
        QueryManager.prototype.openDb = function (query) {
            var _this = this;
            var pResult;
            if (this.db && query.name === this.db.name) {
                pResult = this.initDb();
            }
            else {
                pResult = this.initDb({
                    name: query.name,
                    tables: [],
                    version: query.version
                });
            }
            return this.closeDb().then(function (_) {
                return pResult.then(function () {
                    return _this.db;
                });
            });
        };
        QueryManager.prototype.initDb = function (dataBase) {
            var _this = this;
            if (!IS_IDB_SUPPORTED) {
                return promiseReject(new log_helper_LogHelper(ERROR_TYPE.IndexedDbNotSupported));
            }
            var dbMeta = dataBase ? new db_meta_DbMeta(dataBase) : this.db;
            this.util = new idbutil_IDBUtil();
            return promise(function (res, rej) {
                _this.util.initDb(dbMeta).then(function (dbInfo) {
                    if (dbInfo.isCreated) {
                        meta_helper_MetaHelper.get(meta_helper_MetaHelper.dbSchema, _this.util).then(function (value) {
                            if (value) {
                                value.tables.forEach(function (table, index) {
                                    dbMeta.tables[index].autoIncColumnValue =
                                        table.autoIncColumnValue;
                                });
                            }
                            _this.db = dbMeta;
                            dbInfo.database = userDbSchema(_this.db);
                            meta_helper_MetaHelper.set(meta_helper_MetaHelper.dbSchema, dbMeta, _this.util).then(function () {
                                res(dbInfo);
                            });
                        });
                    }
                    else {
                        meta_helper_MetaHelper.get(meta_helper_MetaHelper.dbSchema, _this.util).then(function (value) {
                            _this.db = value;
                            dbInfo.database = userDbSchema(_this.db);
                            res(dbInfo);
                        });
                    }
                }).catch(rej);
            });
        };
        return QueryManager;
    }());


    // CONCATENATED MODULE: ./src/worker/index.ts



    if (IS_WORKER) {
        var manager_1 = new query_manager_QueryManager();
        self.onmessage = function (e) {
            manager_1.run(e.data);
        };
    }


    /***/ })

    /******/ });

    });

    var worker_injector = {
        setup(connection, param) {
            connection['$worker'] = (() => {
                {
                    return jsstore_worker_commonjs2;
                }
            })();
            connection.initQueryManager_();
        }
    };

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    function arrayRemove(arr, value) { 

    	return arr.filter(function(ele){ 
    		return ele != value; 
    	});
    }

    function createLimit() {
    	const { subscribe, set, update } = writable(20);
    	
    	return {
    		subscribe,
    		increment: () => update(x => x + 20),
    		reset: () => set (20)
    	}
    }

    function createList() {
    	const { subscribe, set, update } = writable([]);

    	return {
    		subscribe,
    		set,
    		refresh: () => update(li => li)
    	}
    }

    function createLastTouchedByUpdate() {
    	const { subscribe, set } = writable(false);

    	return {
    		subscribe,
    		yes: () => set(true),
    		no: () => set(false)
    	}
    }

    function createFilterCriteria() {
    	const { subscribe, update } = writable({ playlists : {}, users : {} });

    	return {
    		subscribe,
    		update_criteria : (u, p) => update(criteria => {
    			const users = [];
    			u.forEach(entry => {
    				users.push({ id : entry.subm_id, name : entry.subm_name, type : 0 });
    			});
    			const playlists = [];
    			p.forEach(entry => {
    				playlists.push({ id : entry.playlist_id, name : entry.playlist_name, type : 1 });
    			});
    			return [...users, ...playlists]
    		})
    	}
    }

    function createPlaylistFilters() {
    	const { subscribe, set, update } = writable([]);

    	return { 
    		subscribe,
    		add: (pl) => update(li => { 
    			if ( !li.includes(pl) ) { return [...li, pl] } else { return li }
    		}),
    		delete: (pl) => update(li => { if ( li.includes(pl) ) { return arrayRemove(li, pl) } else { return li }
    		}),
    		toggle: (pl) => update(li => {
    			if ( li.includes(pl) ) { return arrayRemove(li, pl) } else { return [...li, pl] }
    		}),
    		reset: () => set([])
    	};
    }

    function createUserFilters() {
    	const { subscribe, set, update } = writable([]);

    	return { 
    		subscribe,
    		add: (u) => update(li => { 
    			if ( !li.includes(u) ) { return [...li, u] } else { return li }
    		}),
    		delete: (u) => update(li => {
    			if ( li.includes(u) ) { return arrayRemove(li, u) } else { return li }
    		}),
    		toggle: (u) => update(li => {
    			if ( li.includes(u) ) { return arrayRemove(li, u) } else { return [...li, u] }
    		}),
    		reset: () => set([])
    	};
    }

    const limit = createLimit();
    const list = createList();
    const lastTouchedByUpdate = createLastTouchedByUpdate();
    const filterCriteria = createFilterCriteria();
    const playlistFilters = createPlaylistFilters();
    const userFilters = createUserFilters();
    const flyDelay = writable(0);

    //function exports
    async function updateData () {
    	await createConnection();
    	await initDatabase();
    	const playlists = await updatePlaylists();
    	const allSongs = await updateSongs(playlists);
    	const fC = await getFilterCriteria();
    	filterCriteria.update_criteria(fC.users, fC.playlists);
    	updateFilterOptions(get_store_value(filterCriteria));
    	return allSongs['songs'].length != 0
    }

    async function readData (limit) {
    	const result = await getSongs(limit);
    	return result
    }


    function deleteData () {
    	indexedDB.deleteDatabase('sctdb');
    }

    function updateFilterOptions (data) {
    		data = data.filter( el => !get_store_value(userFilters).includes( el ) );
    		data = data.filter( el => !get_store_value(playlistFilters).includes( el ) );
    		return data
    }



    //global vars
    let connection;
    let playlistsTable;
    let songsTable;
    let db;


    //internal functions
    async function createConnection() {
    	connection = new npm_export.Connection();
    	connection.addPlugin(worker_injector);
    }

    async function initDatabase() {
    	playlistsTable = {
    		name: 'playlists',
    		columns: {
    			id : { primaryKey: true, notNull: true, dataType: 'string' },
    			snapshot : { notNull: true, dataType: 'string' }
    		}
    	};
    	
    	songsTable = {
    		name: 'songs',
    		columns: {
    			uid : { primaryKey: true, notNull: true, dataType: 'string' },
    			unix : { notNull: true, dataType: 'number' },
    			subm_name : { notNull: true, dataType: 'string' },
    			subm_id : { notNull: true, dataType: 'string' },
    			subm_link : { dataType: 'string' },
    			subm_images : { dataType: 'object' },
    			song_title : { notNull: true, dataType: 'string' },
    			song_link : { dataType: 'string' },
    			song_popularity : { dataType: 'number' },
    			song_duration : { dataType: 'number' },
    			song_islocal : { dataType: 'boolean' },
    			song_id : { dataType: 'string' },
    			album_name : { dataType: 'string' },
    			album_link : { dataType: 'string' },
    			artists : { notNull: true, dataType: 'array' },
    			playlist_name : { notNull: true, dataType: 'string' },
    			playlist_link : { notNull: true, dataType: 'string' },
    			playlist_id : { notNull: true, dataType: 'string' }
    		}
    	};

    	db = {
    		name : 'sctdb',
    		tables : [ playlistsTable, songsTable ]
    	};

    	await connection.initDb(db);
    }

    //updateFunctions
    async function updatePlaylists () {
    	//connect to database and grab all playlists
    	//SQL: SELECT * FROM playlists
    	const playlistsData = await connection.select({
    		from: 'playlists'
    	});
    	let playlists = {};
    	playlistsData.forEach(obj => {
    		playlists[obj.id] = obj.snapshot;
    	});
    	//send request to api with current playlist dict
    	const json = await playlistRequests(token$1, playlists);

    	//update playlist table with new information
    	Object.keys(json['remove']).forEach((key) => {
    		//remove playlists from playlist table
    		//SQL: DELETE FROM playlists WHERE id=key
    		connection.remove({
    			from : 'playlists',
    			where : {
    				id : key
    			}
    		});
    		//remove songs of those playlists from songs table
    		//SQL: DELETE FROM songs WHERE playlist_id=key
    		connection.remove({
    			from : 'songs',
    			where : {
    				playlist_id : key
    			}
    		});
    	});

    	Object.entries(json['update']).forEach((entry) => {
    		//add and update new and existing playlists respectively
    		const [key, value] = entry;
    		const row = {
    			'id' : key,
    			'snapshot' : value
    		};
    		//SQL: INSERT INTO playlists (id, snapshot) VALUES (key, value)
    		connection.insert({
    			into : 'playlists',
    			values : [ row ],
    			upsert : 'true'
    		});
    		//SQL: DELETE FROM songs WHERE playlist_id=key
    		connection.remove({
    			from : 'songs',
    			where : {
    				playlist_id : key
    			}
    		});
    	});
    	//return playlists object from API call for further usage
    	return json
    }
    async function updateSongs (playlists) {
    	//use playlists object from updatePlaylists to fetch 
    	const json = await songRequests(token$1, playlists.update);
    	//update songs table; API response is designed in a manner
    	//such that the songs key holds an array of songs,
    	//all of which are objects that match the table row schema
    	await connection.insert({
    		into : 'songs',
    		values: json.songs,
    		upsert : 'true' //theoretically not necessary but better safe than sorry!
    		});
    	return json
    }

    async function getSongs (l) {
    	//base query
    	let query = {
    		from : 'songs',
    		order : {
    			by : 'unix',
    			type: 'desc'
    		},
    		limit : l,
    		where : {}
    	};
    	//add filters
    	let temp = [];
    	get_store_value(playlistFilters).forEach(element => {temp.push(element.id);});
    	const playlist_re = new RegExp(temp.join('|'));
    	if (playlist_re != '') { query.where.playlist_id = { regex : playlist_re }; }

    	temp = [];
    	get_store_value(userFilters).forEach(element => {temp.push(element.id);});
    	const user_re = new RegExp(temp.join('|'));
    	if (user_re != '') { query.where.subm_id = { regex : user_re }; }

    	if ( query.where === {} ) { delete query.where; }	//SQL: SELECT * FROM songs ORDER BY unix DESC LIMIT l
    	const result = await connection.select(query);
    	return result
    }


    async function getFilterCriteria () {
    	const users = await connection.select({
    		from : 'songs',
    		groupBy : 'subm_name'
    	});

    	const playlists = await connection.select({
    		from : 'songs',
    		groupBy : 'playlist_name'
    	});

    	return { users, playlists }
    }

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }
    function quadOut(t) {
        return -t * (t - 2.0);
    }
    function quintOut(t) {
        return --t * t * t * t * t + 1;
    }

    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }

    function flip(node, animation, params = {}) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        const scaleX = animation.from.width / node.clientWidth;
        const scaleY = animation.from.height / node.clientHeight;
        const dx = (animation.from.left - animation.to.left) / scaleX;
        const dy = (animation.from.top - animation.to.top) / scaleY;
        const d = Math.sqrt(dx * dx + dy * dy);
        const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
        return {
            delay,
            duration: is_function(duration) ? duration(d) : duration,
            easing,
            css: (_t, u) => `transform: ${transform} translate(${u * dx}px, ${u * dy}px);`
        };
    }

    const createToast = () => {
      const { subscribe, update } = writable([]);
      let count = 0;
      let defaults = {};
      const push = (msg, opts = {}) => {
        const entry = { id: ++count, msg: msg, ...defaults, ...opts, theme: { ...defaults.theme, ...opts.theme } };
        update(n => entry.reversed ? [...n, entry] : [entry, ...n]);
        return count
      };
      const pop = id => {
        update(n => id ? n.filter(i => i.id !== id) : n.splice(1));
      };
      const set = (id, obj) => {
        update(n => {
          const idx = n.findIndex(i => i.id === id);
          if (idx > -1) {
            n[idx] = { ...n[idx], ...obj };
          }
          return n
        });
      };
      const _opts = (obj = {}) => {
        defaults = { ...defaults, ...obj, theme: { ...defaults.theme, ...obj.theme } };
        return defaults
      };
      return { subscribe, push, pop, set, _opts }
    };

    const toast = createToast();

    function is_date(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }

    function get_interpolator(a, b) {
        if (a === b || a !== a)
            return () => a;
        const type = typeof a;
        if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
            throw new Error('Cannot interpolate values of different type');
        }
        if (Array.isArray(a)) {
            const arr = b.map((bi, i) => {
                return get_interpolator(a[i], bi);
            });
            return t => arr.map(fn => fn(t));
        }
        if (type === 'object') {
            if (!a || !b)
                throw new Error('Object cannot be null');
            if (is_date(a) && is_date(b)) {
                a = a.getTime();
                b = b.getTime();
                const delta = b - a;
                return t => new Date(a + t * delta);
            }
            const keys = Object.keys(b);
            const interpolators = {};
            keys.forEach(key => {
                interpolators[key] = get_interpolator(a[key], b[key]);
            });
            return t => {
                const result = {};
                keys.forEach(key => {
                    result[key] = interpolators[key](t);
                });
                return result;
            };
        }
        if (type === 'number') {
            const delta = b - a;
            return t => a + t * delta;
        }
        throw new Error(`Cannot interpolate ${type} values`);
    }
    function tweened(value, defaults = {}) {
        const store = writable(value);
        let task;
        let target_value = value;
        function set(new_value, opts) {
            if (value == null) {
                store.set(value = new_value);
                return Promise.resolve();
            }
            target_value = new_value;
            let previous_task = task;
            let started = false;
            let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign$1(assign$1({}, defaults), opts);
            if (duration === 0) {
                if (previous_task) {
                    previous_task.abort();
                    previous_task = null;
                }
                store.set(value = target_value);
                return Promise.resolve();
            }
            const start = now() + delay;
            let fn;
            task = loop(now => {
                if (now < start)
                    return true;
                if (!started) {
                    fn = interpolate(value, new_value);
                    if (typeof duration === 'function')
                        duration = duration(value, new_value);
                    started = true;
                }
                if (previous_task) {
                    previous_task.abort();
                    previous_task = null;
                }
                const elapsed = now - start;
                if (elapsed > duration) {
                    store.set(value = new_value);
                    return false;
                }
                // @ts-ignore
                store.set(value = fn(easing(elapsed / duration)));
                return true;
            });
            return task.promise;
        }
        return {
            set,
            update: (fn, opts) => set(fn(target_value, value), opts),
            subscribe: store.subscribe
        };
    }

    /* node_modules/@zerodevx/svelte-toast/src/ToastItem.svelte generated by Svelte v3.37.0 */
    const file$d = "node_modules/@zerodevx/svelte-toast/src/ToastItem.svelte";

    // (85:2) {#if item.dismissable}
    function create_if_block$3(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "â";
    			attr_dev(div, "class", "_toastBtn svelte-1r0vvz1");
    			attr_dev(div, "role", "button");
    			attr_dev(div, "tabindex", "-1");
    			add_location(div, file$d, 85, 2, 2027);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(85:2) {#if item.dismissable}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let div1;
    	let div0;
    	let raw_value = /*item*/ ctx[0].msg + "";
    	let t0;
    	let t1;
    	let progress_1;
    	let if_block = /*item*/ ctx[0].dismissable && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			progress_1 = element("progress");
    			attr_dev(div0, "class", "_toastMsg svelte-1r0vvz1");
    			add_location(div0, file$d, 80, 2, 1945);
    			attr_dev(progress_1, "class", "_toastBar svelte-1r0vvz1");
    			progress_1.value = /*$progress*/ ctx[1];
    			add_location(progress_1, file$d, 88, 2, 2133);
    			attr_dev(div1, "class", "_toastItem svelte-1r0vvz1");
    			add_location(div1, file$d, 79, 0, 1918);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			append_dev(div1, t0);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, progress_1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*item*/ 1 && raw_value !== (raw_value = /*item*/ ctx[0].msg + "")) div0.innerHTML = raw_value;
    			if (/*item*/ ctx[0].dismissable) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(div1, t1);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*$progress*/ 2) {
    				prop_dev(progress_1, "value", /*$progress*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $progress;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ToastItem", slots, []);
    	let { item } = $$props;
    	const progress = tweened(item.initial, { duration: item.duration, easing: identity });
    	validate_store(progress, "progress");
    	component_subscribe($$self, progress, value => $$invalidate(1, $progress = value));
    	let prevProgress = item.initial;
    	const writable_props = ["item"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ToastItem> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => toast.pop(item.id);

    	$$self.$$set = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    	};

    	$$self.$capture_state = () => ({
    		tweened,
    		linear: identity,
    		toast,
    		item,
    		progress,
    		prevProgress,
    		$progress
    	});

    	$$self.$inject_state = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("prevProgress" in $$props) $$invalidate(3, prevProgress = $$props.prevProgress);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*prevProgress, item*/ 9) {
    			if (prevProgress !== item.progress) {
    				if (item.progress === 1 || item.progress === 0) {
    					progress.set(item.progress).then(() => toast.pop(item.id));
    				} else {
    					progress.set(item.progress);
    				}

    				$$invalidate(3, prevProgress = item.progress);
    			}
    		}
    	};

    	return [item, $progress, progress, prevProgress, click_handler];
    }

    class ToastItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { item: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ToastItem",
    			options,
    			id: create_fragment$d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*item*/ ctx[0] === undefined && !("item" in props)) {
    			console.warn("<ToastItem> was created without expected prop 'item'");
    		}
    	}

    	get item() {
    		throw new Error("<ToastItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<ToastItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/@zerodevx/svelte-toast/src/SvelteToast.svelte generated by Svelte v3.37.0 */

    const { Object: Object_1$1 } = globals;
    const file$c = "node_modules/@zerodevx/svelte-toast/src/SvelteToast.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (39:2) {#each $toast as item (item.id)}
    function create_each_block$4(key_1, ctx) {
    	let li;
    	let toastitem;
    	let t;
    	let li_style_value;
    	let li_intro;
    	let li_outro;
    	let rect;
    	let stop_animation = noop;
    	let current;

    	toastitem = new ToastItem({
    			props: { item: /*item*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			li = element("li");
    			create_component(toastitem.$$.fragment);
    			t = space();
    			attr_dev(li, "style", li_style_value = /*getCss*/ ctx[1](/*item*/ ctx[4].theme));
    			add_location(li, file$c, 39, 2, 830);
    			this.first = li;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(toastitem, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const toastitem_changes = {};
    			if (dirty & /*$toast*/ 1) toastitem_changes.item = /*item*/ ctx[4];
    			toastitem.$set(toastitem_changes);

    			if (!current || dirty & /*$toast*/ 1 && li_style_value !== (li_style_value = /*getCss*/ ctx[1](/*item*/ ctx[4].theme))) {
    				attr_dev(li, "style", li_style_value);
    			}
    		},
    		r: function measure() {
    			rect = li.getBoundingClientRect();
    		},
    		f: function fix() {
    			fix_position(li);
    			stop_animation();
    			add_transform(li, rect);
    		},
    		a: function animate() {
    			stop_animation();
    			stop_animation = create_animation(li, rect, flip, { duration: 200 });
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toastitem.$$.fragment, local);

    			add_render_callback(() => {
    				if (li_outro) li_outro.end(1);
    				if (!li_intro) li_intro = create_in_transition(li, fly, /*item*/ ctx[4].intro);
    				li_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toastitem.$$.fragment, local);
    			if (li_intro) li_intro.invalidate();
    			li_outro = create_out_transition(li, fade, {});
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(toastitem);
    			if (detaching && li_outro) li_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(39:2) {#each $toast as item (item.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let ul;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*$toast*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*item*/ ctx[4].id;
    	validate_each_keys(ctx, each_value, get_each_context$4, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$4(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$4(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "svelte-1wt6bln");
    			add_location(ul, file$c, 37, 0, 788);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*getCss, $toast*/ 3) {
    				each_value = /*$toast*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
    				validate_each_keys(ctx, each_value, get_each_context$4, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, fix_and_outro_and_destroy_block, create_each_block$4, null, get_each_context$4);
    				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $toast;
    	validate_store(toast, "toast");
    	component_subscribe($$self, toast, $$value => $$invalidate(0, $toast = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SvelteToast", slots, []);
    	let { options = {} } = $$props;

    	const defaults = {
    		duration: 4000,
    		dismissable: true,
    		initial: 1,
    		progress: 0,
    		reversed: false,
    		intro: { x: 256 },
    		theme: {}
    	};

    	toast._opts(defaults);
    	const getCss = theme => Object.keys(theme).reduce((a, c) => `${a}${c}:${theme[c]};`, "");
    	const writable_props = ["options"];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SvelteToast> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("options" in $$props) $$invalidate(2, options = $$props.options);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		fly,
    		flip,
    		toast,
    		ToastItem,
    		options,
    		defaults,
    		getCss,
    		$toast
    	});

    	$$self.$inject_state = $$props => {
    		if ("options" in $$props) $$invalidate(2, options = $$props.options);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*options*/ 4) {
    			toast._opts(options);
    		}
    	};

    	return [$toast, getCss, options];
    }

    class SvelteToast extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { options: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SvelteToast",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get options() {
    		throw new Error("<SvelteToast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<SvelteToast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*
     * Fuzzy
     * https://github.com/myork/fuzzy
     *
     * Copyright (c) 2012 Matt York
     * Licensed under the MIT license.
     */

    var fuzzy = createCommonjsModule(function (module, exports) {
    (function() {

    var fuzzy = {};

    // Use in node or in browser
    {
      module.exports = fuzzy;
    }

    // Return all elements of `array` that have a fuzzy
    // match against `pattern`.
    fuzzy.simpleFilter = function(pattern, array) {
      return array.filter(function(str) {
        return fuzzy.test(pattern, str);
      });
    };

    // Does `pattern` fuzzy match `str`?
    fuzzy.test = function(pattern, str) {
      return fuzzy.match(pattern, str) !== null;
    };

    // If `pattern` matches `str`, wrap each matching character
    // in `opts.pre` and `opts.post`. If no match, return null
    fuzzy.match = function(pattern, str, opts) {
      opts = opts || {};
      var patternIdx = 0
        , result = []
        , len = str.length
        , totalScore = 0
        , currScore = 0
        // prefix
        , pre = opts.pre || ''
        // suffix
        , post = opts.post || ''
        // String to compare against. This might be a lowercase version of the
        // raw string
        , compareString =  opts.caseSensitive && str || str.toLowerCase()
        , ch;

      pattern = opts.caseSensitive && pattern || pattern.toLowerCase();

      // For each character in the string, either add it to the result
      // or wrap in template if it's the next string in the pattern
      for(var idx = 0; idx < len; idx++) {
        ch = str[idx];
        if(compareString[idx] === pattern[patternIdx]) {
          ch = pre + ch + post;
          patternIdx += 1;

          // consecutive characters should increase the score more than linearly
          currScore += 1 + currScore;
        } else {
          currScore = 0;
        }
        totalScore += currScore;
        result[result.length] = ch;
      }

      // return rendered string if we have a match for every char
      if(patternIdx === pattern.length) {
        // if the string is an exact match with pattern, totalScore should be maxed
        totalScore = (compareString === pattern) ? Infinity : totalScore;
        return {rendered: result.join(''), score: totalScore};
      }

      return null;
    };

    // The normal entry point. Filters `arr` for matches against `pattern`.
    // It returns an array with matching values of the type:
    //
    //     [{
    //         string:   '<b>lah' // The rendered string
    //       , index:    2        // The index of the element in `arr`
    //       , original: 'blah'   // The original element in `arr`
    //     }]
    //
    // `opts` is an optional argument bag. Details:
    //
    //    opts = {
    //        // string to put before a matching character
    //        pre:     '<b>'
    //
    //        // string to put after matching character
    //      , post:    '</b>'
    //
    //        // Optional function. Input is an entry in the given arr`,
    //        // output should be the string to test `pattern` against.
    //        // In this example, if `arr = [{crying: 'koala'}]` we would return
    //        // 'koala'.
    //      , extract: function(arg) { return arg.crying; }
    //    }
    fuzzy.filter = function(pattern, arr, opts) {
      if(!arr || arr.length === 0) {
        return [];
      }
      if (typeof pattern !== 'string') {
        return arr;
      }
      opts = opts || {};
      return arr
        .reduce(function(prev, element, idx, arr) {
          var str = element;
          if(opts.extract) {
            str = opts.extract(element);
          }
          var rendered = fuzzy.match(pattern, str, opts);
          if(rendered != null) {
            prev[prev.length] = {
                string: rendered.rendered
              , score: rendered.score
              , index: idx
              , original: element
            };
          }
          return prev;
        }, [])

        // Sort by score. Browsers are inconsistent wrt stable/unstable
        // sorting, so force stable by using the index in the case of tie.
        // See http://ofb.net/~sethml/is-sort-stable.html
        .sort(function(a,b) {
          var compare = b.score - a.score;
          if(compare) return compare;
          return a.index - b.index;
        });
    };


    }());
    });

    /* node_modules/svelte-search/src/Search.svelte generated by Svelte v3.37.0 */
    const file$b = "node_modules/svelte-search/src/Search.svelte";
    const get_label_slot_changes = dirty => ({});
    const get_label_slot_context = ctx => ({});

    // (60:23) {label}
    function fallback_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*label*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 4) set_data_dev(t, /*label*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(60:23) {label}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let form;
    	let label_1;
    	let label_1_id_value;
    	let t;
    	let input;
    	let form_role_value;
    	let form_aria_labelledby_value;
    	let current;
    	let mounted;
    	let dispose;
    	const label_slot_template = /*#slots*/ ctx[10].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[9], get_label_slot_context);
    	const label_slot_or_fallback = label_slot || fallback_block$1(ctx);

    	let input_levels = [
    		{ name: "search" },
    		{ type: "search" },
    		{ placeholder: "Search..." },
    		{ autocomplete: "off" },
    		{ spellcheck: "false" },
    		/*$$restProps*/ ctx[6],
    		{ id: /*id*/ ctx[4] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign$1(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			form = element("form");
    			label_1 = element("label");
    			if (label_slot_or_fallback) label_slot_or_fallback.c();
    			t = space();
    			input = element("input");
    			attr_dev(label_1, "id", label_1_id_value = "" + (/*id*/ ctx[4] + "-label"));
    			attr_dev(label_1, "for", /*id*/ ctx[4]);
    			attr_dev(label_1, "class", "svelte-5m0wg6");
    			toggle_class(label_1, "hide-label", /*hideLabel*/ ctx[3]);
    			add_location(label_1, file$b, 58, 2, 1329);
    			set_attributes(input, input_data);
    			toggle_class(input, "svelte-5m0wg6", true);
    			add_location(input, file$b, 61, 2, 1442);
    			attr_dev(form, "data-svelte-search", "");
    			attr_dev(form, "role", form_role_value = /*removeFormAriaAttributes*/ ctx[5] ? null : "search");

    			attr_dev(form, "aria-labelledby", form_aria_labelledby_value = /*removeFormAriaAttributes*/ ctx[5]
    			? null
    			: /*id*/ ctx[4]);

    			add_location(form, file$b, 52, 0, 1162);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, label_1);

    			if (label_slot_or_fallback) {
    				label_slot_or_fallback.m(label_1, null);
    			}

    			append_dev(form, t);
    			append_dev(form, input);
    			/*input_binding*/ ctx[17](input);
    			set_input_value(input, /*value*/ ctx[0]);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[18]),
    					listen_dev(input, "input", /*input_handler*/ ctx[12], false, false, false),
    					listen_dev(input, "change", /*change_handler*/ ctx[13], false, false, false),
    					listen_dev(input, "focus", /*focus_handler*/ ctx[14], false, false, false),
    					listen_dev(input, "blur", /*blur_handler*/ ctx[15], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler*/ ctx[16], false, false, false),
    					listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[11]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (label_slot) {
    				if (label_slot.p && dirty & /*$$scope*/ 512) {
    					update_slot(label_slot, label_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_label_slot_changes, get_label_slot_context);
    				}
    			} else {
    				if (label_slot_or_fallback && label_slot_or_fallback.p && dirty & /*label*/ 4) {
    					label_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (!current || dirty & /*id*/ 16 && label_1_id_value !== (label_1_id_value = "" + (/*id*/ ctx[4] + "-label"))) {
    				attr_dev(label_1, "id", label_1_id_value);
    			}

    			if (!current || dirty & /*id*/ 16) {
    				attr_dev(label_1, "for", /*id*/ ctx[4]);
    			}

    			if (dirty & /*hideLabel*/ 8) {
    				toggle_class(label_1, "hide-label", /*hideLabel*/ ctx[3]);
    			}

    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				{ name: "search" },
    				{ type: "search" },
    				{ placeholder: "Search..." },
    				{ autocomplete: "off" },
    				{ spellcheck: "false" },
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				(!current || dirty & /*id*/ 16) && { id: /*id*/ ctx[4] }
    			]));

    			if (dirty & /*value*/ 1) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}

    			toggle_class(input, "svelte-5m0wg6", true);

    			if (!current || dirty & /*removeFormAriaAttributes*/ 32 && form_role_value !== (form_role_value = /*removeFormAriaAttributes*/ ctx[5] ? null : "search")) {
    				attr_dev(form, "role", form_role_value);
    			}

    			if (!current || dirty & /*removeFormAriaAttributes, id*/ 48 && form_aria_labelledby_value !== (form_aria_labelledby_value = /*removeFormAriaAttributes*/ ctx[5]
    			? null
    			: /*id*/ ctx[4])) {
    				attr_dev(form, "aria-labelledby", form_aria_labelledby_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			if (label_slot_or_fallback) label_slot_or_fallback.d(detaching);
    			/*input_binding*/ ctx[17](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"value","autofocus","debounce","label","hideLabel","id","ref","removeFormAriaAttributes"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Search", slots, ['label']);
    	let { value = "" } = $$props;
    	let { autofocus = false } = $$props;
    	let { debounce = 0 } = $$props;
    	let { label = "Label" } = $$props;
    	let { hideLabel = false } = $$props;
    	let { id = "search" + Math.random().toString(36) } = $$props;
    	let { ref = null } = $$props;
    	let { removeFormAriaAttributes = false } = $$props;
    	const dispatch = createEventDispatcher();
    	let prevValue = value;
    	let timeout = undefined;
    	let calling = false;

    	function debounced(cb) {
    		if (calling) return;
    		calling = true;

    		timeout = setTimeout(
    			() => {
    				cb();
    				calling = false;
    			},
    			debounce
    		);
    	}

    	onMount(() => {
    		if (autofocus) window.requestAnimationFrame(() => ref.focus());
    		return () => clearTimeout(timeout);
    	});

    	afterUpdate(() => {
    		if (value.length > 0 && value !== prevValue) {
    			if (debounce > 0) {
    				debounced(() => dispatch("type", value));
    			} else {
    				dispatch("type", value);
    			}
    		}

    		if (value.length === 0 && prevValue.length > 0) dispatch("clear");
    		prevValue = value;
    	});

    	function submit_handler(event) {
    		bubble($$self, event);
    	}

    	function input_handler(event) {
    		bubble($$self, event);
    	}

    	function change_handler(event) {
    		bubble($$self, event);
    	}

    	function focus_handler(event) {
    		bubble($$self, event);
    	}

    	function blur_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			ref = $$value;
    			$$invalidate(1, ref);
    		});
    	}

    	function input_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ("autofocus" in $$new_props) $$invalidate(7, autofocus = $$new_props.autofocus);
    		if ("debounce" in $$new_props) $$invalidate(8, debounce = $$new_props.debounce);
    		if ("label" in $$new_props) $$invalidate(2, label = $$new_props.label);
    		if ("hideLabel" in $$new_props) $$invalidate(3, hideLabel = $$new_props.hideLabel);
    		if ("id" in $$new_props) $$invalidate(4, id = $$new_props.id);
    		if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    		if ("removeFormAriaAttributes" in $$new_props) $$invalidate(5, removeFormAriaAttributes = $$new_props.removeFormAriaAttributes);
    		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		value,
    		autofocus,
    		debounce,
    		label,
    		hideLabel,
    		id,
    		ref,
    		removeFormAriaAttributes,
    		createEventDispatcher,
    		onMount,
    		afterUpdate,
    		dispatch,
    		prevValue,
    		timeout,
    		calling,
    		debounced
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    		if ("autofocus" in $$props) $$invalidate(7, autofocus = $$new_props.autofocus);
    		if ("debounce" in $$props) $$invalidate(8, debounce = $$new_props.debounce);
    		if ("label" in $$props) $$invalidate(2, label = $$new_props.label);
    		if ("hideLabel" in $$props) $$invalidate(3, hideLabel = $$new_props.hideLabel);
    		if ("id" in $$props) $$invalidate(4, id = $$new_props.id);
    		if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    		if ("removeFormAriaAttributes" in $$props) $$invalidate(5, removeFormAriaAttributes = $$new_props.removeFormAriaAttributes);
    		if ("prevValue" in $$props) prevValue = $$new_props.prevValue;
    		if ("timeout" in $$props) timeout = $$new_props.timeout;
    		if ("calling" in $$props) calling = $$new_props.calling;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		value,
    		ref,
    		label,
    		hideLabel,
    		id,
    		removeFormAriaAttributes,
    		$$restProps,
    		autofocus,
    		debounce,
    		$$scope,
    		slots,
    		submit_handler,
    		input_handler,
    		change_handler,
    		focus_handler,
    		blur_handler,
    		keydown_handler,
    		input_binding,
    		input_input_handler
    	];
    }

    class Search extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
    			value: 0,
    			autofocus: 7,
    			debounce: 8,
    			label: 2,
    			hideLabel: 3,
    			id: 4,
    			ref: 1,
    			removeFormAriaAttributes: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Search",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get value() {
    		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autofocus() {
    		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autofocus(value) {
    		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get debounce() {
    		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set debounce(value) {
    		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideLabel() {
    		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideLabel(value) {
    		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ref() {
    		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ref(value) {
    		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get removeFormAriaAttributes() {
    		throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set removeFormAriaAttributes(value) {
    		throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-typeahead/src/Typeahead.svelte generated by Svelte v3.37.0 */
    const file$a = "node_modules/svelte-typeahead/src/Typeahead.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[38] = list[i];
    	child_ctx[40] = i;
    	return child_ctx;
    }

    const get_default_slot_changes = dirty => ({ result: dirty[0] & /*results*/ 2 });

    const get_default_slot_context = ctx => ({
    	result: /*result*/ ctx[38],
    	index: /*i*/ ctx[40]
    });

    // (187:4) {#if !hideDropdown && results.length > 0}
    function create_if_block$2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*results*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*id, selectedIndex, results, select, $$scope*/ 262342) {
    				each_value = /*results*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(187:4) {#if !hideDropdown && results.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (202:35)              
    function fallback_block(ctx) {
    	let html_tag;
    	let raw_value = /*result*/ ctx[38].string + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*results*/ 2 && raw_value !== (raw_value = /*result*/ ctx[38].string + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(202:35)              ",
    		ctx
    	});

    	return block;
    }

    // (188:6) {#each results as result, i}
    function create_each_block$3(ctx) {
    	let li;
    	let t;
    	let li_id_value;
    	let li_aria_selected_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[19].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], get_default_slot_context);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[33](/*result*/ ctx[38], /*i*/ ctx[40]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			t = space();
    			attr_dev(li, "role", "option");
    			attr_dev(li, "id", li_id_value = "" + (/*id*/ ctx[2] + "-result-" + /*i*/ ctx[40]));
    			attr_dev(li, "aria-selected", li_aria_selected_value = /*selectedIndex*/ ctx[6] === /*i*/ ctx[40]);
    			attr_dev(li, "class", "svelte-t0wd5r");
    			toggle_class(li, "selected", /*selectedIndex*/ ctx[6] === /*i*/ ctx[40]);
    			toggle_class(li, "disabled", /*result*/ ctx[38].disabled);
    			add_location(li, file$a, 188, 8, 4715);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(li, null);
    			}

    			append_dev(li, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(li, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && dirty[0] & /*$$scope, results*/ 262146) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[18], dirty, get_default_slot_changes, get_default_slot_context);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty[0] & /*results*/ 2) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (!current || dirty[0] & /*id*/ 4 && li_id_value !== (li_id_value = "" + (/*id*/ ctx[2] + "-result-" + /*i*/ ctx[40]))) {
    				attr_dev(li, "id", li_id_value);
    			}

    			if (!current || dirty[0] & /*selectedIndex*/ 64 && li_aria_selected_value !== (li_aria_selected_value = /*selectedIndex*/ ctx[6] === /*i*/ ctx[40])) {
    				attr_dev(li, "aria-selected", li_aria_selected_value);
    			}

    			if (dirty[0] & /*selectedIndex*/ 64) {
    				toggle_class(li, "selected", /*selectedIndex*/ ctx[6] === /*i*/ ctx[40]);
    			}

    			if (dirty[0] & /*results*/ 2) {
    				toggle_class(li, "disabled", /*result*/ ctx[38].disabled);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(188:6) {#each results as result, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div;
    	let search;
    	let updating_ref;
    	let updating_value;
    	let t;
    	let ul;
    	let ul_aria_labelledby_value;
    	let ul_id_value;
    	let div_aria_owns_value;
    	let div_aria_expanded_value;
    	let div_id_value;
    	let current;
    	let mounted;
    	let dispose;

    	const search_spread_levels = [
    		{ id: /*id*/ ctx[2] },
    		{ removeFormAriaAttributes: true },
    		/*$$restProps*/ ctx[8],
    		{ "aria-autocomplete": "list" },
    		{
    			"aria-controls": "" + (/*id*/ ctx[2] + "-listbox")
    		},
    		{
    			"aria-labelledby": "" + (/*id*/ ctx[2] + "-label")
    		},
    		{
    			"aria-activedescendant": /*selectedIndex*/ ctx[6] >= 0 && !/*hideDropdown*/ ctx[5] && /*results*/ ctx[1].length > 0
    			? `${/*id*/ ctx[2]}-result-${/*selectedIndex*/ ctx[6]}`
    			: null
    		}
    	];

    	function search_ref_binding(value) {
    		/*search_ref_binding*/ ctx[21](value);
    	}

    	function search_value_binding(value) {
    		/*search_value_binding*/ ctx[22](value);
    	}

    	let search_props = {};

    	for (let i = 0; i < search_spread_levels.length; i += 1) {
    		search_props = assign$1(search_props, search_spread_levels[i]);
    	}

    	if (/*searchRef*/ ctx[4] !== void 0) {
    		search_props.ref = /*searchRef*/ ctx[4];
    	}

    	if (/*value*/ ctx[0] !== void 0) {
    		search_props.value = /*value*/ ctx[0];
    	}

    	search = new Search({ props: search_props, $$inline: true });
    	binding_callbacks.push(() => bind$1(search, "ref", search_ref_binding));
    	binding_callbacks.push(() => bind$1(search, "value", search_value_binding));
    	search.$on("type", /*type_handler*/ ctx[23]);
    	search.$on("input", /*input_handler*/ ctx[24]);
    	search.$on("change", /*change_handler*/ ctx[25]);
    	search.$on("focus", /*focus_handler*/ ctx[26]);
    	search.$on("focus", /*focus_handler_1*/ ctx[27]);
    	search.$on("clear", /*clear_handler*/ ctx[28]);
    	search.$on("clear", /*clear_handler_1*/ ctx[29]);
    	search.$on("blur", /*blur_handler*/ ctx[30]);
    	search.$on("keydown", /*keydown_handler*/ ctx[31]);
    	search.$on("keydown", /*keydown_handler_1*/ ctx[32]);
    	let if_block = !/*hideDropdown*/ ctx[5] && /*results*/ ctx[1].length > 0 && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(search.$$.fragment);
    			t = space();
    			ul = element("ul");
    			if (if_block) if_block.c();
    			attr_dev(ul, "role", "listbox");
    			attr_dev(ul, "aria-labelledby", ul_aria_labelledby_value = "" + (/*id*/ ctx[2] + "-label"));
    			attr_dev(ul, "id", ul_id_value = "" + (/*id*/ ctx[2] + "-listbox"));
    			attr_dev(ul, "class", "svelte-t0wd5r");
    			toggle_class(ul, "svelte-typeahead-list", true);
    			add_location(ul, file$a, 180, 2, 4505);
    			attr_dev(div, "data-svelte-typeahead", "");
    			attr_dev(div, "role", "combobox");
    			attr_dev(div, "aria-haspopup", "listbox");
    			attr_dev(div, "aria-owns", div_aria_owns_value = "" + (/*id*/ ctx[2] + "-listbox"));
    			attr_dev(div, "aria-expanded", div_aria_expanded_value = !/*hideDropdown*/ ctx[5] && /*results*/ ctx[1].length > 0);
    			attr_dev(div, "id", div_id_value = "" + (/*id*/ ctx[2] + "-typeahead"));
    			attr_dev(div, "class", "svelte-t0wd5r");
    			toggle_class(div, "dropdown", /*results*/ ctx[1].length > 0);
    			add_location(div, file$a, 115, 0, 3026);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(search, div, null);
    			append_dev(div, t);
    			append_dev(div, ul);
    			if (if_block) if_block.m(ul, null);
    			/*div_binding*/ ctx[34](div);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "click", /*click_handler*/ ctx[20], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const search_changes = (dirty[0] & /*id, $$restProps, selectedIndex, hideDropdown, results*/ 358)
    			? get_spread_update(search_spread_levels, [
    					dirty[0] & /*id*/ 4 && { id: /*id*/ ctx[2] },
    					search_spread_levels[1],
    					dirty[0] & /*$$restProps*/ 256 && get_spread_object(/*$$restProps*/ ctx[8]),
    					search_spread_levels[3],
    					dirty[0] & /*id*/ 4 && {
    						"aria-controls": "" + (/*id*/ ctx[2] + "-listbox")
    					},
    					dirty[0] & /*id*/ 4 && {
    						"aria-labelledby": "" + (/*id*/ ctx[2] + "-label")
    					},
    					dirty[0] & /*selectedIndex, hideDropdown, results, id*/ 102 && {
    						"aria-activedescendant": /*selectedIndex*/ ctx[6] >= 0 && !/*hideDropdown*/ ctx[5] && /*results*/ ctx[1].length > 0
    						? `${/*id*/ ctx[2]}-result-${/*selectedIndex*/ ctx[6]}`
    						: null
    					}
    				])
    			: {};

    			if (!updating_ref && dirty[0] & /*searchRef*/ 16) {
    				updating_ref = true;
    				search_changes.ref = /*searchRef*/ ctx[4];
    				add_flush_callback(() => updating_ref = false);
    			}

    			if (!updating_value && dirty[0] & /*value*/ 1) {
    				updating_value = true;
    				search_changes.value = /*value*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			search.$set(search_changes);

    			if (!/*hideDropdown*/ ctx[5] && /*results*/ ctx[1].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*hideDropdown, results*/ 34) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(ul, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*id*/ 4 && ul_aria_labelledby_value !== (ul_aria_labelledby_value = "" + (/*id*/ ctx[2] + "-label"))) {
    				attr_dev(ul, "aria-labelledby", ul_aria_labelledby_value);
    			}

    			if (!current || dirty[0] & /*id*/ 4 && ul_id_value !== (ul_id_value = "" + (/*id*/ ctx[2] + "-listbox"))) {
    				attr_dev(ul, "id", ul_id_value);
    			}

    			if (!current || dirty[0] & /*id*/ 4 && div_aria_owns_value !== (div_aria_owns_value = "" + (/*id*/ ctx[2] + "-listbox"))) {
    				attr_dev(div, "aria-owns", div_aria_owns_value);
    			}

    			if (!current || dirty[0] & /*hideDropdown, results*/ 34 && div_aria_expanded_value !== (div_aria_expanded_value = !/*hideDropdown*/ ctx[5] && /*results*/ ctx[1].length > 0)) {
    				attr_dev(div, "aria-expanded", div_aria_expanded_value);
    			}

    			if (!current || dirty[0] & /*id*/ 4 && div_id_value !== (div_id_value = "" + (/*id*/ ctx[2] + "-typeahead"))) {
    				attr_dev(div, "id", div_id_value);
    			}

    			if (dirty[0] & /*results*/ 2) {
    				toggle_class(div, "dropdown", /*results*/ ctx[1].length > 0);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(search.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(search.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(search);
    			if (if_block) if_block.d();
    			/*div_binding*/ ctx[34](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let options;
    	let resultsId;

    	const omit_props_names = [
    		"id","value","data","extract","disable","filter","autoselect","inputAfterSelect","results","focusAfterSelect","limit"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Typeahead", slots, ['default']);
    	let { id = "typeahead-" + Math.random().toString(36) } = $$props;
    	let { value = "" } = $$props;
    	let { data = [] } = $$props;
    	let { extract = item => item } = $$props;
    	let { disable = item => false } = $$props;
    	let { filter = item => false } = $$props;
    	let { autoselect = true } = $$props;
    	let { inputAfterSelect = "update" } = $$props;
    	let { results = [] } = $$props;
    	let { focusAfterSelect = false } = $$props;
    	let { limit = Infinity } = $$props;
    	const dispatch = createEventDispatcher();
    	let comboboxRef = null;
    	let searchRef = null;
    	let hideDropdown = false;
    	let selectedIndex = -1;
    	let prevResults = "";

    	afterUpdate(() => {
    		if (prevResults !== resultsId && autoselect) {
    			$$invalidate(6, selectedIndex = 0);
    		}

    		if (prevResults !== resultsId) {
    			$$invalidate(5, hideDropdown = results.length === 0);
    		}

    		prevResults = resultsId;
    	});

    	async function select() {
    		const result = results[selectedIndex];
    		const selectedValue = extract(result.original);
    		const searchedValue = value;
    		if (inputAfterSelect == "clear") $$invalidate(0, value = "");
    		if (inputAfterSelect == "update") $$invalidate(0, value = selectedValue);

    		dispatch("select", {
    			selectedIndex,
    			searched: searchedValue,
    			selected: selectedValue,
    			original: result.original,
    			originalIndex: result.index
    		});

    		await tick();
    		if (focusAfterSelect) searchRef.focus();
    		$$invalidate(5, hideDropdown = true);
    	}

    	const click_handler = ({ target }) => {
    		if (!hideDropdown && results.length > 0 && comboboxRef && !comboboxRef.contains(target)) {
    			$$invalidate(5, hideDropdown = true);
    		}
    	};

    	function search_ref_binding(value) {
    		searchRef = value;
    		$$invalidate(4, searchRef);
    	}

    	function search_value_binding(value$1) {
    		value = value$1;
    		$$invalidate(0, value);
    	}

    	function type_handler(event) {
    		bubble($$self, event);
    	}

    	function input_handler(event) {
    		bubble($$self, event);
    	}

    	function change_handler(event) {
    		bubble($$self, event);
    	}

    	function focus_handler(event) {
    		bubble($$self, event);
    	}

    	const focus_handler_1 = () => {
    		$$invalidate(5, hideDropdown = false);
    	};

    	function clear_handler(event) {
    		bubble($$self, event);
    	}

    	const clear_handler_1 = () => {
    		$$invalidate(5, hideDropdown = false);
    	};

    	function blur_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	const keydown_handler_1 = e => {
    		switch (e.key) {
    			case "Enter":
    				select();
    				break;
    			case "ArrowDown":
    				e.preventDefault();
    				$$invalidate(6, selectedIndex += 1);
    				if (selectedIndex === results.length) {
    					$$invalidate(6, selectedIndex = 0);
    				}
    				break;
    			case "ArrowUp":
    				e.preventDefault();
    				$$invalidate(6, selectedIndex -= 1);
    				if (selectedIndex < 0) {
    					$$invalidate(6, selectedIndex = results.length - 1);
    				}
    				break;
    			case "Escape":
    				e.preventDefault();
    				$$invalidate(0, value = "");
    				searchRef.focus();
    				$$invalidate(5, hideDropdown = true);
    				break;
    		}
    	};

    	const click_handler_1 = (result, i) => {
    		if (!result.disabled) {
    			$$invalidate(6, selectedIndex = i);
    			select();
    		}
    	};

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			comboboxRef = $$value;
    			$$invalidate(3, comboboxRef);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("id" in $$new_props) $$invalidate(2, id = $$new_props.id);
    		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ("data" in $$new_props) $$invalidate(9, data = $$new_props.data);
    		if ("extract" in $$new_props) $$invalidate(10, extract = $$new_props.extract);
    		if ("disable" in $$new_props) $$invalidate(11, disable = $$new_props.disable);
    		if ("filter" in $$new_props) $$invalidate(12, filter = $$new_props.filter);
    		if ("autoselect" in $$new_props) $$invalidate(13, autoselect = $$new_props.autoselect);
    		if ("inputAfterSelect" in $$new_props) $$invalidate(14, inputAfterSelect = $$new_props.inputAfterSelect);
    		if ("results" in $$new_props) $$invalidate(1, results = $$new_props.results);
    		if ("focusAfterSelect" in $$new_props) $$invalidate(15, focusAfterSelect = $$new_props.focusAfterSelect);
    		if ("limit" in $$new_props) $$invalidate(16, limit = $$new_props.limit);
    		if ("$$scope" in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		id,
    		value,
    		data,
    		extract,
    		disable,
    		filter,
    		autoselect,
    		inputAfterSelect,
    		results,
    		focusAfterSelect,
    		limit,
    		fuzzy,
    		Search,
    		tick,
    		createEventDispatcher,
    		afterUpdate,
    		dispatch,
    		comboboxRef,
    		searchRef,
    		hideDropdown,
    		selectedIndex,
    		prevResults,
    		select,
    		resultsId,
    		options
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("id" in $$props) $$invalidate(2, id = $$new_props.id);
    		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    		if ("data" in $$props) $$invalidate(9, data = $$new_props.data);
    		if ("extract" in $$props) $$invalidate(10, extract = $$new_props.extract);
    		if ("disable" in $$props) $$invalidate(11, disable = $$new_props.disable);
    		if ("filter" in $$props) $$invalidate(12, filter = $$new_props.filter);
    		if ("autoselect" in $$props) $$invalidate(13, autoselect = $$new_props.autoselect);
    		if ("inputAfterSelect" in $$props) $$invalidate(14, inputAfterSelect = $$new_props.inputAfterSelect);
    		if ("results" in $$props) $$invalidate(1, results = $$new_props.results);
    		if ("focusAfterSelect" in $$props) $$invalidate(15, focusAfterSelect = $$new_props.focusAfterSelect);
    		if ("limit" in $$props) $$invalidate(16, limit = $$new_props.limit);
    		if ("comboboxRef" in $$props) $$invalidate(3, comboboxRef = $$new_props.comboboxRef);
    		if ("searchRef" in $$props) $$invalidate(4, searchRef = $$new_props.searchRef);
    		if ("hideDropdown" in $$props) $$invalidate(5, hideDropdown = $$new_props.hideDropdown);
    		if ("selectedIndex" in $$props) $$invalidate(6, selectedIndex = $$new_props.selectedIndex);
    		if ("prevResults" in $$props) prevResults = $$new_props.prevResults;
    		if ("resultsId" in $$props) resultsId = $$new_props.resultsId;
    		if ("options" in $$props) $$invalidate(17, options = $$new_props.options);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*extract*/ 1024) {
    			$$invalidate(17, options = { pre: "<mark>", post: "</mark>", extract });
    		}

    		if ($$self.$$.dirty[0] & /*value, data, options, limit, filter, disable*/ 203265) {
    			$$invalidate(1, results = fuzzy.filter(value, data, options).filter(({ score }) => score > 0).slice(0, limit).filter(result => !filter(result.original)).map(result => ({
    				...result,
    				disabled: disable(result.original)
    			})));
    		}

    		if ($$self.$$.dirty[0] & /*results, extract*/ 1026) {
    			resultsId = results.map(result => extract(result.original)).join("");
    		}
    	};

    	return [
    		value,
    		results,
    		id,
    		comboboxRef,
    		searchRef,
    		hideDropdown,
    		selectedIndex,
    		select,
    		$$restProps,
    		data,
    		extract,
    		disable,
    		filter,
    		autoselect,
    		inputAfterSelect,
    		focusAfterSelect,
    		limit,
    		options,
    		$$scope,
    		slots,
    		click_handler,
    		search_ref_binding,
    		search_value_binding,
    		type_handler,
    		input_handler,
    		change_handler,
    		focus_handler,
    		focus_handler_1,
    		clear_handler,
    		clear_handler_1,
    		blur_handler,
    		keydown_handler,
    		keydown_handler_1,
    		click_handler_1,
    		div_binding
    	];
    }

    class Typeahead extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$a,
    			create_fragment$a,
    			safe_not_equal,
    			{
    				id: 2,
    				value: 0,
    				data: 9,
    				extract: 10,
    				disable: 11,
    				filter: 12,
    				autoselect: 13,
    				inputAfterSelect: 14,
    				results: 1,
    				focusAfterSelect: 15,
    				limit: 16
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Typeahead",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get id() {
    		throw new Error("<Typeahead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Typeahead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Typeahead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Typeahead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<Typeahead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Typeahead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get extract() {
    		throw new Error("<Typeahead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set extract(value) {
    		throw new Error("<Typeahead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disable() {
    		throw new Error("<Typeahead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disable(value) {
    		throw new Error("<Typeahead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filter() {
    		throw new Error("<Typeahead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filter(value) {
    		throw new Error("<Typeahead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autoselect() {
    		throw new Error("<Typeahead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autoselect(value) {
    		throw new Error("<Typeahead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputAfterSelect() {
    		throw new Error("<Typeahead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputAfterSelect(value) {
    		throw new Error("<Typeahead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get results() {
    		throw new Error("<Typeahead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set results(value) {
    		throw new Error("<Typeahead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusAfterSelect() {
    		throw new Error("<Typeahead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusAfterSelect(value) {
    		throw new Error("<Typeahead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get limit() {
    		throw new Error("<Typeahead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set limit(value) {
    		throw new Error("<Typeahead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Filters.svelte generated by Svelte v3.37.0 */
    const file$9 = "src/components/Filters.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	return child_ctx;
    }

    // (53:0) <Typeahead   {data}  {extract}  limit=5  on:select={(e) => {addFilter(e.detail.original)}}  inputAfterSelect="clear"  placeholder="search for filters..."  hideLabel=true  autoselect=false  let:result>
    function create_default_slot$1(ctx) {
    	let html_tag;
    	let raw_value = /*result*/ ctx[18].string + "";
    	let t0;
    	let span;
    	let t1_value = decodeType(/*result*/ ctx[18].original.type) + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = space();
    			span = element("span");
    			t1 = text(t1_value);
    			html_tag = new HtmlTag(t0);
    			attr_dev(span, "class", "category-info svelte-1ere1q4");
    			add_location(span, file$9, 62, 23, 1242);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*result*/ 262144 && raw_value !== (raw_value = /*result*/ ctx[18].string + "")) html_tag.p(raw_value);
    			if (dirty & /*result*/ 262144 && t1_value !== (t1_value = decodeType(/*result*/ ctx[18].original.type) + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) html_tag.d();
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(53:0) <Typeahead   {data}  {extract}  limit=5  on:select={(e) => {addFilter(e.detail.original)}}  inputAfterSelect=\\\"clear\\\"  placeholder=\\\"search for filters...\\\"  hideLabel=true  autoselect=false  let:result>",
    		ctx
    	});

    	return block;
    }

    // (67:0) {#each $userFilters as u}
    function create_each_block_1(ctx) {
    	let button;
    	let t_value = /*u*/ ctx[15].name + "";
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[7](/*u*/ ctx[15]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "svelte-1ere1q4");
    			add_location(button, file$9, 67, 1, 1382);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$userFilters*/ 1 && t_value !== (t_value = /*u*/ ctx[15].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(67:0) {#each $userFilters as u}",
    		ctx
    	});

    	return block;
    }

    // (70:0) {#each $playlistFilters as p}
    function create_each_block$2(ctx) {
    	let button;
    	let t0_value = /*p*/ ctx[12].name + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[8](/*p*/ ctx[12]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(button, "class", "svelte-1ere1q4");
    			add_location(button, file$9, 70, 1, 1484);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t0);
    			append_dev(button, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$playlistFilters*/ 2 && t0_value !== (t0_value = /*p*/ ctx[12].name + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(70:0) {#each $playlistFilters as p}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let typeahead;
    	let t0;
    	let div;
    	let t1;
    	let current;

    	typeahead = new Typeahead({
    			props: {
    				data: /*data*/ ctx[3],
    				extract: /*extract*/ ctx[2],
    				limit: "5",
    				inputAfterSelect: "clear",
    				placeholder: "search for filters...",
    				hideLabel: "true",
    				autoselect: "false",
    				$$slots: {
    					default: [
    						create_default_slot$1,
    						({ result }) => ({ 18: result }),
    						({ result }) => result ? 262144 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	typeahead.$on("select", /*select_handler*/ ctx[6]);
    	let each_value_1 = /*$userFilters*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let each_value = /*$playlistFilters*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			create_component(typeahead.$$.fragment);
    			t0 = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "filter-buttons svelte-1ere1q4");
    			add_location(div, file$9, 65, 0, 1326);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(typeahead, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div, null);
    			}

    			append_dev(div, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const typeahead_changes = {};

    			if (dirty & /*$$scope, result*/ 786432) {
    				typeahead_changes.$$scope = { dirty, ctx };
    			}

    			typeahead.$set(typeahead_changes);

    			if (dirty & /*removeFilter, $userFilters*/ 33) {
    				each_value_1 = /*$userFilters*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div, t1);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*removeFilter, $playlistFilters*/ 34) {
    				each_value = /*$playlistFilters*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(typeahead.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(typeahead.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(typeahead, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function decodeType(type) {
    	switch (type) {
    		case 0:
    			return "in users";
    		case 1:
    			return "in playlists";
    	}
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $filterCriteria;
    	let $limit;
    	let $userFilters;
    	let $playlistFilters;
    	validate_store(filterCriteria, "filterCriteria");
    	component_subscribe($$self, filterCriteria, $$value => $$invalidate(9, $filterCriteria = $$value));
    	validate_store(limit, "limit");
    	component_subscribe($$self, limit, $$value => $$invalidate(10, $limit = $$value));
    	validate_store(userFilters, "userFilters");
    	component_subscribe($$self, userFilters, $$value => $$invalidate(0, $userFilters = $$value));
    	validate_store(playlistFilters, "playlistFilters");
    	component_subscribe($$self, playlistFilters, $$value => $$invalidate(1, $playlistFilters = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Filters", slots, []);
    	const extract = item => item.name;
    	let data = $filterCriteria;

    	function applyFilter() {
    		readData($limit).then(rows => {
    			flyDelay.set(1000);
    			list.set(rows);
    			lastTouchedByUpdate.yes();
    		});
    	}

    	function addFilter(item) {
    		if (item.type == 0) {
    			userFilters.add(item);
    		} else if (item.type == 1) {
    			playlistFilters.add(item);
    		}

    		applyFilter();
    		updateFilterOptions($filterCriteria);
    	}

    	function removeFilter(item) {
    		if (item.type == 0) {
    			userFilters.delete(item);
    		} else if (item.type == 1) {
    			playlistFilters.delete(item);
    		}

    		applyFilter();
    		updateFilterOptions($filterCriteria);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Filters> was created with unknown prop '${key}'`);
    	});

    	const select_handler = e => {
    		addFilter(e.detail.original);
    	};

    	const click_handler = u => {
    		removeFilter(u);
    	};

    	const click_handler_1 = p => {
    		removeFilter(p);
    	};

    	$$self.$capture_state = () => ({
    		readData,
    		updateFilterOptions,
    		filterCriteria,
    		playlistFilters,
    		userFilters,
    		limit,
    		list,
    		lastTouchedByUpdate,
    		flyDelay,
    		Typeahead,
    		extract,
    		data,
    		applyFilter,
    		addFilter,
    		removeFilter,
    		decodeType,
    		$filterCriteria,
    		$limit,
    		$userFilters,
    		$playlistFilters
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		$userFilters,
    		$playlistFilters,
    		extract,
    		data,
    		addFilter,
    		removeFilter,
    		select_handler,
    		click_handler,
    		click_handler_1
    	];
    }

    class Filters extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Filters",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    function requiredArgs(required, args) {
      if (args.length < required) {
        throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
      }
    }

    /**
     * @name toDate
     * @category Common Helpers
     * @summary Convert the given argument to an instance of Date.
     *
     * @description
     * Convert the given argument to an instance of Date.
     *
     * If the argument is an instance of Date, the function returns its clone.
     *
     * If the argument is a number, it is treated as a timestamp.
     *
     * If the argument is none of the above, the function returns Invalid Date.
     *
     * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
     *
     * @param {Date|Number} argument - the value to convert
     * @returns {Date} the parsed date in the local time zone
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Clone the date:
     * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
     * //=> Tue Feb 11 2014 11:30:30
     *
     * @example
     * // Convert the timestamp to date:
     * const result = toDate(1392098430000)
     * //=> Tue Feb 11 2014 11:30:30
     */

    function toDate(argument) {
      requiredArgs(1, arguments);
      var argStr = Object.prototype.toString.call(argument); // Clone the date

      if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
        // Prevent the date to lose the milliseconds when passed to new Date() in IE10
        return new Date(argument.getTime());
      } else if (typeof argument === 'number' || argStr === '[object Number]') {
        return new Date(argument);
      } else {
        if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
          // eslint-disable-next-line no-console
          console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

          console.warn(new Error().stack);
        }

        return new Date(NaN);
      }
    }

    /**
     * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
     * They usually appear for dates that denote time before the timezones were introduced
     * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
     * and GMT+01:00:00 after that date)
     *
     * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
     * which would lead to incorrect calculations.
     *
     * This function returns the timezone offset in milliseconds that takes seconds in account.
     */
    function getTimezoneOffsetInMilliseconds(date) {
      var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
      utcDate.setUTCFullYear(date.getFullYear());
      return date.getTime() - utcDate.getTime();
    }

    /**
     * @name compareAsc
     * @category Common Helpers
     * @summary Compare the two dates and return -1, 0 or 1.
     *
     * @description
     * Compare the two dates and return 1 if the first date is after the second,
     * -1 if the first date is before the second or 0 if dates are equal.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} dateLeft - the first date to compare
     * @param {Date|Number} dateRight - the second date to compare
     * @returns {Number} the result of the comparison
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Compare 11 February 1987 and 10 July 1989:
     * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
     * //=> -1
     *
     * @example
     * // Sort the array of dates:
     * const result = [
     *   new Date(1995, 6, 2),
     *   new Date(1987, 1, 11),
     *   new Date(1989, 6, 10)
     * ].sort(compareAsc)
     * //=> [
     * //   Wed Feb 11 1987 00:00:00,
     * //   Mon Jul 10 1989 00:00:00,
     * //   Sun Jul 02 1995 00:00:00
     * // ]
     */

    function compareAsc(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var diff = dateLeft.getTime() - dateRight.getTime();

      if (diff < 0) {
        return -1;
      } else if (diff > 0) {
        return 1; // Return 0 if diff is 0; return NaN if diff is NaN
      } else {
        return diff;
      }
    }

    /**
     * @name differenceInCalendarMonths
     * @category Month Helpers
     * @summary Get the number of calendar months between the given dates.
     *
     * @description
     * Get the number of calendar months between the given dates.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of calendar months
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many calendar months are between 31 January 2014 and 1 September 2014?
     * var result = differenceInCalendarMonths(
     *   new Date(2014, 8, 1),
     *   new Date(2014, 0, 31)
     * )
     * //=> 8
     */

    function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
      var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
      return yearDiff * 12 + monthDiff;
    }

    /**
     * @name differenceInMilliseconds
     * @category Millisecond Helpers
     * @summary Get the number of milliseconds between the given dates.
     *
     * @description
     * Get the number of milliseconds between the given dates.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of milliseconds
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many milliseconds are between
     * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
     * const result = differenceInMilliseconds(
     *   new Date(2014, 6, 2, 12, 30, 21, 700),
     *   new Date(2014, 6, 2, 12, 30, 20, 600)
     * )
     * //=> 1100
     */

    function differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      return dateLeft.getTime() - dateRight.getTime();
    }

    /**
     * @name endOfDay
     * @category Day Helpers
     * @summary Return the end of a day for the given date.
     *
     * @description
     * Return the end of a day for the given date.
     * The result will be in the local timezone.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the end of a day
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The end of a day for 2 September 2014 11:55:00:
     * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Tue Sep 02 2014 23:59:59.999
     */

    function endOfDay(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      date.setHours(23, 59, 59, 999);
      return date;
    }

    /**
     * @name endOfMonth
     * @category Month Helpers
     * @summary Return the end of a month for the given date.
     *
     * @description
     * Return the end of a month for the given date.
     * The result will be in the local timezone.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the end of a month
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The end of a month for 2 September 2014 11:55:00:
     * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Tue Sep 30 2014 23:59:59.999
     */

    function endOfMonth(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var month = date.getMonth();
      date.setFullYear(date.getFullYear(), month + 1, 0);
      date.setHours(23, 59, 59, 999);
      return date;
    }

    /**
     * @name isLastDayOfMonth
     * @category Month Helpers
     * @summary Is the given date the last day of a month?
     *
     * @description
     * Is the given date the last day of a month?
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} date - the date to check
     * @returns {Boolean} the date is the last day of a month
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Is 28 February 2014 the last day of a month?
     * var result = isLastDayOfMonth(new Date(2014, 1, 28))
     * //=> true
     */

    function isLastDayOfMonth(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      return endOfDay(date).getTime() === endOfMonth(date).getTime();
    }

    /**
     * @name differenceInMonths
     * @category Month Helpers
     * @summary Get the number of full months between the given dates.
     *
     * @description
     * Get the number of full months between the given dates.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of full months
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many full months are between 31 January 2014 and 1 September 2014?
     * var result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))
     * //=> 7
     */

    function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var sign = compareAsc(dateLeft, dateRight);
      var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
      var result; // Check for the difference of less than month

      if (difference < 1) {
        result = 0;
      } else {
        if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
          // This will check if the date is end of Feb and assign a higher end of month date
          // to compare it with Jan
          dateLeft.setDate(30);
        }

        dateLeft.setMonth(dateLeft.getMonth() - sign * difference); // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
        // If so, result must be decreased by 1 in absolute value

        var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign; // Check for cases of one full calendar month

        if (isLastDayOfMonth(toDate(dirtyDateLeft)) && difference === 1 && compareAsc(dirtyDateLeft, dateRight) === 1) {
          isLastMonthNotFull = false;
        }

        result = sign * (difference - Number(isLastMonthNotFull));
      } // Prevent negative zero


      return result === 0 ? 0 : result;
    }

    /**
     * @name differenceInSeconds
     * @category Second Helpers
     * @summary Get the number of seconds between the given dates.
     *
     * @description
     * Get the number of seconds between the given dates.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of seconds
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many seconds are between
     * // 2 July 2014 12:30:07.999 and 2 July 2014 12:30:20.000?
     * const result = differenceInSeconds(
     *   new Date(2014, 6, 2, 12, 30, 20, 0),
     *   new Date(2014, 6, 2, 12, 30, 7, 999)
     * )
     * //=> 12
     */

    function differenceInSeconds(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / 1000;
      return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
    }

    var formatDistanceLocale = {
      lessThanXSeconds: {
        one: 'less than a second',
        other: 'less than {{count}} seconds'
      },
      xSeconds: {
        one: '1 second',
        other: '{{count}} seconds'
      },
      halfAMinute: 'half a minute',
      lessThanXMinutes: {
        one: 'less than a minute',
        other: 'less than {{count}} minutes'
      },
      xMinutes: {
        one: '1 minute',
        other: '{{count}} minutes'
      },
      aboutXHours: {
        one: 'about 1 hour',
        other: 'about {{count}} hours'
      },
      xHours: {
        one: '1 hour',
        other: '{{count}} hours'
      },
      xDays: {
        one: '1 day',
        other: '{{count}} days'
      },
      aboutXWeeks: {
        one: 'about 1 week',
        other: 'about {{count}} weeks'
      },
      xWeeks: {
        one: '1 week',
        other: '{{count}} weeks'
      },
      aboutXMonths: {
        one: 'about 1 month',
        other: 'about {{count}} months'
      },
      xMonths: {
        one: '1 month',
        other: '{{count}} months'
      },
      aboutXYears: {
        one: 'about 1 year',
        other: 'about {{count}} years'
      },
      xYears: {
        one: '1 year',
        other: '{{count}} years'
      },
      overXYears: {
        one: 'over 1 year',
        other: 'over {{count}} years'
      },
      almostXYears: {
        one: 'almost 1 year',
        other: 'almost {{count}} years'
      }
    };
    function formatDistance$1(token, count, options) {
      options = options || {};
      var result;

      if (typeof formatDistanceLocale[token] === 'string') {
        result = formatDistanceLocale[token];
      } else if (count === 1) {
        result = formatDistanceLocale[token].one;
      } else {
        result = formatDistanceLocale[token].other.replace('{{count}}', count);
      }

      if (options.addSuffix) {
        if (options.comparison > 0) {
          return 'in ' + result;
        } else {
          return result + ' ago';
        }
      }

      return result;
    }

    function buildFormatLongFn(args) {
      return function (dirtyOptions) {
        var options = dirtyOptions || {};
        var width = options.width ? String(options.width) : args.defaultWidth;
        var format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
      };
    }

    var dateFormats = {
      full: 'EEEE, MMMM do, y',
      long: 'MMMM do, y',
      medium: 'MMM d, y',
      short: 'MM/dd/yyyy'
    };
    var timeFormats = {
      full: 'h:mm:ss a zzzz',
      long: 'h:mm:ss a z',
      medium: 'h:mm:ss a',
      short: 'h:mm a'
    };
    var dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: 'P'
    };
    function formatRelative(token, _date, _baseDate, _options) {
      return formatRelativeLocale[token];
    }

    function buildLocalizeFn(args) {
      return function (dirtyIndex, dirtyOptions) {
        var options = dirtyOptions || {};
        var context = options.context ? String(options.context) : 'standalone';
        var valuesArray;

        if (context === 'formatting' && args.formattingValues) {
          var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          var width = options.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          var _defaultWidth = args.defaultWidth;

          var _width = options.width ? String(options.width) : args.defaultWidth;

          valuesArray = args.values[_width] || args.values[_defaultWidth];
        }

        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
        return valuesArray[index];
      };
    }

    var eraValues = {
      narrow: ['B', 'A'],
      abbreviated: ['BC', 'AD'],
      wide: ['Before Christ', 'Anno Domini']
    };
    var quarterValues = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'] // Note: in English, the names of days of the week and months are capitalized.
      // If you are making a new locale based on this one, check if the same is true for the language you're working on.
      // Generally, formatted dates should look like they are in the middle of a sentence,
      // e.g. in Spanish language the weekdays and months should be in the lowercase.

    };
    var monthValues = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    };
    var dayValues = {
      narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
      short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
      abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    };
    var dayPeriodValues = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      }
    };

    function ordinalNumber(dirtyNumber, _dirtyOptions) {
      var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
      // if they are different for different grammatical genders,
      // use `options.unit`:
      //
      //   var options = dirtyOptions || {}
      //   var unit = String(options.unit)
      //
      // where `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
      // 'day', 'hour', 'minute', 'second'

      var rem100 = number % 100;

      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + 'st';

          case 2:
            return number + 'nd';

          case 3:
            return number + 'rd';
        }
      }

      return number + 'th';
    }

    var localize = {
      ordinalNumber: ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return Number(quarter) - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: 'wide'
      })
    };

    function buildMatchPatternFn(args) {
      return function (dirtyString, dirtyOptions) {
        var string = String(dirtyString);
        var options = dirtyOptions || {};
        var matchResult = string.match(args.matchPattern);

        if (!matchResult) {
          return null;
        }

        var matchedString = matchResult[0];
        var parseResult = string.match(args.parsePattern);

        if (!parseResult) {
          return null;
        }

        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        return {
          value: value,
          rest: string.slice(matchedString.length)
        };
      };
    }

    function buildMatchFn(args) {
      return function (dirtyString, dirtyOptions) {
        var string = String(dirtyString);
        var options = dirtyOptions || {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string.match(matchPattern);

        if (!matchResult) {
          return null;
        }

        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var value;

        if (Object.prototype.toString.call(parsePatterns) === '[object Array]') {
          value = findIndex(parsePatterns, function (pattern) {
            return pattern.test(matchedString);
          });
        } else {
          value = findKey(parsePatterns, function (pattern) {
            return pattern.test(matchedString);
          });
        }

        value = args.valueCallback ? args.valueCallback(value) : value;
        value = options.valueCallback ? options.valueCallback(value) : value;
        return {
          value: value,
          rest: string.slice(matchedString.length)
        };
      };
    }

    function findKey(object, predicate) {
      for (var key in object) {
        if (object.hasOwnProperty(key) && predicate(object[key])) {
          return key;
        }
      }
    }

    function findIndex(array, predicate) {
      for (var key = 0; key < array.length; key++) {
        if (predicate(array[key])) {
          return key;
        }
      }
    }

    var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary English locale (United States).
     * @language English
     * @iso-639-2 eng
     * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
     * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
     */

    var locale = {
      code: 'en-US',
      formatDistance: formatDistance$1,
      formatLong: formatLong,
      formatRelative: formatRelative,
      localize: localize,
      match: match,
      options: {
        weekStartsOn: 0
        /* Sunday */
        ,
        firstWeekContainsDate: 1
      }
    };

    function assign(target, dirtyObject) {
      if (target == null) {
        throw new TypeError('assign requires that input parameter not be null or undefined');
      }

      dirtyObject = dirtyObject || {};

      for (var property in dirtyObject) {
        if (dirtyObject.hasOwnProperty(property)) {
          target[property] = dirtyObject[property];
        }
      }

      return target;
    }

    function cloneObject(dirtyObject) {
      return assign({}, dirtyObject);
    }

    var MINUTES_IN_DAY = 1440;
    var MINUTES_IN_ALMOST_TWO_DAYS = 2520;
    var MINUTES_IN_MONTH = 43200;
    var MINUTES_IN_TWO_MONTHS = 86400;
    /**
     * @name formatDistance
     * @category Common Helpers
     * @summary Return the distance between the given dates in words.
     *
     * @description
     * Return the distance between the given dates in words.
     *
     * | Distance between dates                                            | Result              |
     * |-------------------------------------------------------------------|---------------------|
     * | 0 ... 30 secs                                                     | less than a minute  |
     * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
     * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
     * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
     * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
     * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
     * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
     * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
     * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
     * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
     * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
     * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
     * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
     * | N yrs ... N yrs 3 months                                          | about N years       |
     * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
     * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
     *
     * With `options.includeSeconds == true`:
     * | Distance between dates | Result               |
     * |------------------------|----------------------|
     * | 0 secs ... 5 secs      | less than 5 seconds  |
     * | 5 secs ... 10 secs     | less than 10 seconds |
     * | 10 secs ... 20 secs    | less than 20 seconds |
     * | 20 secs ... 40 secs    | half a minute        |
     * | 40 secs ... 60 secs    | less than a minute   |
     * | 60 secs ... 90 secs    | 1 minute             |
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * - The function was renamed from `distanceInWords ` to `formatDistance`
     *   to make its name consistent with `format` and `formatRelative`.
     *
     * - The order of arguments is swapped to make the function
     *   consistent with `differenceIn...` functions.
     *
     *   ```javascript
     *   // Before v2.0.0
     *
     *   distanceInWords(
     *     new Date(1986, 3, 4, 10, 32, 0),
     *     new Date(1986, 3, 4, 11, 32, 0),
     *     { addSuffix: true }
     *   ) //=> 'in about 1 hour'
     *
     *   // v2.0.0 onward
     *
     *   formatDistance(
     *     new Date(1986, 3, 4, 11, 32, 0),
     *     new Date(1986, 3, 4, 10, 32, 0),
     *     { addSuffix: true }
     *   ) //=> 'in about 1 hour'
     *   ```
     *
     * @param {Date|Number} date - the date
     * @param {Date|Number} baseDate - the date to compare with
     * @param {Object} [options] - an object with options.
     * @param {Boolean} [options.includeSeconds=false] - distances less than a minute are more detailed
     * @param {Boolean} [options.addSuffix=false] - result indicates if the second date is earlier or later than the first
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @returns {String} the distance in words
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `date` must not be Invalid Date
     * @throws {RangeError} `baseDate` must not be Invalid Date
     * @throws {RangeError} `options.locale` must contain `formatDistance` property
     *
     * @example
     * // What is the distance between 2 July 2014 and 1 January 2015?
     * const result = formatDistance(new Date(2014, 6, 2), new Date(2015, 0, 1))
     * //=> '6 months'
     *
     * @example
     * // What is the distance between 1 January 2015 00:00:15
     * // and 1 January 2015 00:00:00, including seconds?
     * const result = formatDistance(
     *   new Date(2015, 0, 1, 0, 0, 15),
     *   new Date(2015, 0, 1, 0, 0, 0),
     *   { includeSeconds: true }
     * )
     * //=> 'less than 20 seconds'
     *
     * @example
     * // What is the distance from 1 January 2016
     * // to 1 January 2015, with a suffix?
     * const result = formatDistance(new Date(2015, 0, 1), new Date(2016, 0, 1), {
     *   addSuffix: true
     * })
     * //=> 'about 1 year ago'
     *
     * @example
     * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
     * import { eoLocale } from 'date-fns/locale/eo'
     * const result = formatDistance(new Date(2016, 7, 1), new Date(2015, 0, 1), {
     *   locale: eoLocale
     * })
     * //=> 'pli ol 1 jaro'
     */

    function formatDistance(dirtyDate, dirtyBaseDate) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      requiredArgs(2, arguments);
      var locale$1 = options.locale || locale;

      if (!locale$1.formatDistance) {
        throw new RangeError('locale must contain formatDistance property');
      }

      var comparison = compareAsc(dirtyDate, dirtyBaseDate);

      if (isNaN(comparison)) {
        throw new RangeError('Invalid time value');
      }

      var localizeOptions = cloneObject(options);
      localizeOptions.addSuffix = Boolean(options.addSuffix);
      localizeOptions.comparison = comparison;
      var dateLeft;
      var dateRight;

      if (comparison > 0) {
        dateLeft = toDate(dirtyBaseDate);
        dateRight = toDate(dirtyDate);
      } else {
        dateLeft = toDate(dirtyDate);
        dateRight = toDate(dirtyBaseDate);
      }

      var seconds = differenceInSeconds(dateRight, dateLeft);
      var offsetInSeconds = (getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft)) / 1000;
      var minutes = Math.round((seconds - offsetInSeconds) / 60);
      var months; // 0 up to 2 mins

      if (minutes < 2) {
        if (options.includeSeconds) {
          if (seconds < 5) {
            return locale$1.formatDistance('lessThanXSeconds', 5, localizeOptions);
          } else if (seconds < 10) {
            return locale$1.formatDistance('lessThanXSeconds', 10, localizeOptions);
          } else if (seconds < 20) {
            return locale$1.formatDistance('lessThanXSeconds', 20, localizeOptions);
          } else if (seconds < 40) {
            return locale$1.formatDistance('halfAMinute', null, localizeOptions);
          } else if (seconds < 60) {
            return locale$1.formatDistance('lessThanXMinutes', 1, localizeOptions);
          } else {
            return locale$1.formatDistance('xMinutes', 1, localizeOptions);
          }
        } else {
          if (minutes === 0) {
            return locale$1.formatDistance('lessThanXMinutes', 1, localizeOptions);
          } else {
            return locale$1.formatDistance('xMinutes', minutes, localizeOptions);
          }
        } // 2 mins up to 0.75 hrs

      } else if (minutes < 45) {
        return locale$1.formatDistance('xMinutes', minutes, localizeOptions); // 0.75 hrs up to 1.5 hrs
      } else if (minutes < 90) {
        return locale$1.formatDistance('aboutXHours', 1, localizeOptions); // 1.5 hrs up to 24 hrs
      } else if (minutes < MINUTES_IN_DAY) {
        var hours = Math.round(minutes / 60);
        return locale$1.formatDistance('aboutXHours', hours, localizeOptions); // 1 day up to 1.75 days
      } else if (minutes < MINUTES_IN_ALMOST_TWO_DAYS) {
        return locale$1.formatDistance('xDays', 1, localizeOptions); // 1.75 days up to 30 days
      } else if (minutes < MINUTES_IN_MONTH) {
        var days = Math.round(minutes / MINUTES_IN_DAY);
        return locale$1.formatDistance('xDays', days, localizeOptions); // 1 month up to 2 months
      } else if (minutes < MINUTES_IN_TWO_MONTHS) {
        months = Math.round(minutes / MINUTES_IN_MONTH);
        return locale$1.formatDistance('aboutXMonths', months, localizeOptions);
      }

      months = differenceInMonths(dateRight, dateLeft); // 2 months up to 12 months

      if (months < 12) {
        var nearestMonth = Math.round(minutes / MINUTES_IN_MONTH);
        return locale$1.formatDistance('xMonths', nearestMonth, localizeOptions); // 1 year up to max Date
      } else {
        var monthsSinceStartOfYear = months % 12;
        var years = Math.floor(months / 12); // N years up to 1 years 3 months

        if (monthsSinceStartOfYear < 3) {
          return locale$1.formatDistance('aboutXYears', years, localizeOptions); // N years 3 months up to N years 9 months
        } else if (monthsSinceStartOfYear < 9) {
          return locale$1.formatDistance('overXYears', years, localizeOptions); // N years 9 months up to N year 12 months
        } else {
          return locale$1.formatDistance('almostXYears', years + 1, localizeOptions);
        }
      }
    }

    /* src/components/Song.svelte generated by Svelte v3.37.0 */
    const file$8 = "src/components/Song.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i].name;
    	child_ctx[10] = list[i].link;
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (30:2) {#each artists as {name, link}
    function create_each_block$1(ctx) {
    	let a;
    	let t0_value = /*name*/ ctx[9] + "";
    	let t0;
    	let a_href_value;
    	let t1_value = checkSeperator(/*artists*/ ctx[2], /*i*/ ctx[12]) + "";
    	let t1;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			attr_dev(a, "href", a_href_value = /*link*/ ctx[10]);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "class", "svelte-vbc8jy");
    			add_location(a, file$8, 30, 3, 643);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t0);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*artists*/ 4 && t0_value !== (t0_value = /*name*/ ctx[9] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*artists*/ 4 && a_href_value !== (a_href_value = /*link*/ ctx[10])) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (dirty & /*artists*/ 4 && t1_value !== (t1_value = checkSeperator(/*artists*/ ctx[2], /*i*/ ctx[12]) + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(30:2) {#each artists as {name, link}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let h1;
    	let a0;
    	let t0;
    	let t1;
    	let h2;
    	let t2;
    	let t3;
    	let h3;
    	let t4;
    	let a1;
    	let t5;
    	let t6;
    	let a2;
    	let b;
    	let t7;
    	let t8;
    	let t9_value = /*timeAgo*/ ctx[8](/*unix*/ ctx[7]) + "";
    	let t9;
    	let t10;
    	let br0;
    	let t11;
    	let br1;
    	let each_value = /*artists*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			a0 = element("a");
    			t0 = text(/*song_title*/ ctx[1]);
    			t1 = space();
    			h2 = element("h2");
    			t2 = text("by \n\t\t");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			h3 = element("h3");
    			t4 = text("added to ");
    			a1 = element("a");
    			t5 = text(/*playlist_name*/ ctx[3]);
    			t6 = text(" \n\t\tby ");
    			a2 = element("a");
    			b = element("b");
    			t7 = text(/*subm_name*/ ctx[6]);
    			t8 = space();
    			t9 = text(t9_value);
    			t10 = space();
    			br0 = element("br");
    			t11 = space();
    			br1 = element("br");
    			attr_dev(a0, "href", /*song_link*/ ctx[0]);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "class", "svelte-vbc8jy");
    			add_location(a0, file$8, 27, 4, 536);
    			attr_dev(h1, "class", "svelte-vbc8jy");
    			add_location(h1, file$8, 27, 0, 532);
    			attr_dev(h2, "class", "svelte-vbc8jy");
    			add_location(h2, file$8, 28, 1, 595);
    			attr_dev(a1, "href", /*playlist_link*/ ctx[4]);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "class", "svelte-vbc8jy");
    			add_location(a1, file$8, 33, 14, 744);
    			add_location(b, file$8, 34, 41, 846);
    			attr_dev(a2, "href", /*subm_link*/ ctx[5]);
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "class", "svelte-vbc8jy");
    			add_location(a2, file$8, 34, 5, 810);
    			attr_dev(h3, "class", "svelte-vbc8jy");
    			add_location(h3, file$8, 33, 1, 731);
    			add_location(br0, file$8, 36, 1, 893);
    			add_location(br1, file$8, 37, 1, 899);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			append_dev(h1, a0);
    			append_dev(a0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(h2, null);
    			}

    			insert_dev(target, t3, anchor);
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t4);
    			append_dev(h3, a1);
    			append_dev(a1, t5);
    			append_dev(h3, t6);
    			append_dev(h3, a2);
    			append_dev(a2, b);
    			append_dev(b, t7);
    			append_dev(h3, t8);
    			append_dev(h3, t9);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, br0, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, br1, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*song_title*/ 2) set_data_dev(t0, /*song_title*/ ctx[1]);

    			if (dirty & /*song_link*/ 1) {
    				attr_dev(a0, "href", /*song_link*/ ctx[0]);
    			}

    			if (dirty & /*checkSeperator, artists*/ 4) {
    				each_value = /*artists*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(h2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*playlist_name*/ 8) set_data_dev(t5, /*playlist_name*/ ctx[3]);

    			if (dirty & /*playlist_link*/ 16) {
    				attr_dev(a1, "href", /*playlist_link*/ ctx[4]);
    			}

    			if (dirty & /*subm_name*/ 64) set_data_dev(t7, /*subm_name*/ ctx[6]);

    			if (dirty & /*subm_link*/ 32) {
    				attr_dev(a2, "href", /*subm_link*/ ctx[5]);
    			}

    			if (dirty & /*unix*/ 128 && t9_value !== (t9_value = /*timeAgo*/ ctx[8](/*unix*/ ctx[7]) + "")) set_data_dev(t9, t9_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h2);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(br0);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(br1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function checkSeperator(artists, i) {
    	if (artists.length - 1 == i) {
    		return "";
    	} else if (artists.length - 2 == i) {
    		return " & ";
    	} else {
    		return ", ";
    	}
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Song", slots, []);
    	let { song_link } = $$props;
    	let { song_title } = $$props;
    	let { artists } = $$props;
    	let { playlist_name } = $$props;
    	let { playlist_link } = $$props;
    	let { subm_link } = $$props;
    	let { subm_name } = $$props;
    	let { unix } = $$props;

    	function timeAgo(unix) {
    		const time = formatDistance(new Date(unix), new Date(), { addSuffix: true });
    		return time;
    	}

    	const writable_props = [
    		"song_link",
    		"song_title",
    		"artists",
    		"playlist_name",
    		"playlist_link",
    		"subm_link",
    		"subm_name",
    		"unix"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Song> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("song_link" in $$props) $$invalidate(0, song_link = $$props.song_link);
    		if ("song_title" in $$props) $$invalidate(1, song_title = $$props.song_title);
    		if ("artists" in $$props) $$invalidate(2, artists = $$props.artists);
    		if ("playlist_name" in $$props) $$invalidate(3, playlist_name = $$props.playlist_name);
    		if ("playlist_link" in $$props) $$invalidate(4, playlist_link = $$props.playlist_link);
    		if ("subm_link" in $$props) $$invalidate(5, subm_link = $$props.subm_link);
    		if ("subm_name" in $$props) $$invalidate(6, subm_name = $$props.subm_name);
    		if ("unix" in $$props) $$invalidate(7, unix = $$props.unix);
    	};

    	$$self.$capture_state = () => ({
    		formatDistance,
    		song_link,
    		song_title,
    		artists,
    		playlist_name,
    		playlist_link,
    		subm_link,
    		subm_name,
    		unix,
    		timeAgo,
    		checkSeperator
    	});

    	$$self.$inject_state = $$props => {
    		if ("song_link" in $$props) $$invalidate(0, song_link = $$props.song_link);
    		if ("song_title" in $$props) $$invalidate(1, song_title = $$props.song_title);
    		if ("artists" in $$props) $$invalidate(2, artists = $$props.artists);
    		if ("playlist_name" in $$props) $$invalidate(3, playlist_name = $$props.playlist_name);
    		if ("playlist_link" in $$props) $$invalidate(4, playlist_link = $$props.playlist_link);
    		if ("subm_link" in $$props) $$invalidate(5, subm_link = $$props.subm_link);
    		if ("subm_name" in $$props) $$invalidate(6, subm_name = $$props.subm_name);
    		if ("unix" in $$props) $$invalidate(7, unix = $$props.unix);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		song_link,
    		song_title,
    		artists,
    		playlist_name,
    		playlist_link,
    		subm_link,
    		subm_name,
    		unix,
    		timeAgo
    	];
    }

    class Song extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
    			song_link: 0,
    			song_title: 1,
    			artists: 2,
    			playlist_name: 3,
    			playlist_link: 4,
    			subm_link: 5,
    			subm_name: 6,
    			unix: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Song",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*song_link*/ ctx[0] === undefined && !("song_link" in props)) {
    			console.warn("<Song> was created without expected prop 'song_link'");
    		}

    		if (/*song_title*/ ctx[1] === undefined && !("song_title" in props)) {
    			console.warn("<Song> was created without expected prop 'song_title'");
    		}

    		if (/*artists*/ ctx[2] === undefined && !("artists" in props)) {
    			console.warn("<Song> was created without expected prop 'artists'");
    		}

    		if (/*playlist_name*/ ctx[3] === undefined && !("playlist_name" in props)) {
    			console.warn("<Song> was created without expected prop 'playlist_name'");
    		}

    		if (/*playlist_link*/ ctx[4] === undefined && !("playlist_link" in props)) {
    			console.warn("<Song> was created without expected prop 'playlist_link'");
    		}

    		if (/*subm_link*/ ctx[5] === undefined && !("subm_link" in props)) {
    			console.warn("<Song> was created without expected prop 'subm_link'");
    		}

    		if (/*subm_name*/ ctx[6] === undefined && !("subm_name" in props)) {
    			console.warn("<Song> was created without expected prop 'subm_name'");
    		}

    		if (/*unix*/ ctx[7] === undefined && !("unix" in props)) {
    			console.warn("<Song> was created without expected prop 'unix'");
    		}
    	}

    	get song_link() {
    		throw new Error("<Song>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set song_link(value) {
    		throw new Error("<Song>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get song_title() {
    		throw new Error("<Song>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set song_title(value) {
    		throw new Error("<Song>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get artists() {
    		throw new Error("<Song>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set artists(value) {
    		throw new Error("<Song>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get playlist_name() {
    		throw new Error("<Song>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set playlist_name(value) {
    		throw new Error("<Song>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get playlist_link() {
    		throw new Error("<Song>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set playlist_link(value) {
    		throw new Error("<Song>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subm_link() {
    		throw new Error("<Song>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subm_link(value) {
    		throw new Error("<Song>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subm_name() {
    		throw new Error("<Song>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subm_name(value) {
    		throw new Error("<Song>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get unix() {
    		throw new Error("<Song>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set unix(value) {
    		throw new Error("<Song>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/BackToTop.svelte generated by Svelte v3.37.0 */

    const file$7 = "src/components/BackToTop.svelte";

    function create_fragment$7(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "to da top!";
    			attr_dev(div, "class", "top-button svelte-5txybq");
    			toggle_class(div, "hidden", /*hidden*/ ctx[0]);
    			add_location(div, file$7, 24, 0, 379);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "scroll", /*onScroll*/ ctx[1], false, false, false),
    					listen_dev(div, "click", goTop, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*hidden*/ 1) {
    				toggle_class(div, "hidden", /*hidden*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function goTop() {
    	document.body.scrollIntoView();
    }

    function scrollContainer() {
    	return document.documentElement || document.body;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("BackToTop", slots, []);
    	let { showOnPx = 250 } = $$props;
    	let hidden = true;

    	function onScroll() {
    		if (!scrollContainer()) {
    			return;
    		}

    		$$invalidate(0, hidden = !(scrollContainer().scrollTop > showOnPx));
    	}

    	const writable_props = ["showOnPx"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BackToTop> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("showOnPx" in $$props) $$invalidate(2, showOnPx = $$props.showOnPx);
    	};

    	$$self.$capture_state = () => ({
    		showOnPx,
    		hidden,
    		goTop,
    		scrollContainer,
    		onScroll
    	});

    	$$self.$inject_state = $$props => {
    		if ("showOnPx" in $$props) $$invalidate(2, showOnPx = $$props.showOnPx);
    		if ("hidden" in $$props) $$invalidate(0, hidden = $$props.hidden);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [hidden, onScroll, showOnPx];
    }

    class BackToTop extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { showOnPx: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BackToTop",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get showOnPx() {
    		throw new Error("<BackToTop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showOnPx(value) {
    		throw new Error("<BackToTop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Feed.svelte generated by Svelte v3.37.0 */

    const { console: console_1 } = globals;
    const file$6 = "src/components/Feed.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (1:0) <script>  import { onMount }
    function create_catch_block$2(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$2.name,
    		type: "catch",
    		source: "(1:0) <script>  import { onMount }",
    		ctx
    	});

    	return block;
    }

    // (63:1) {:then}
    function create_then_block$2(ctx) {
    	let filters;
    	let t0;
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let infiniteloading;
    	let current;
    	filters = new Filters({ $$inline: true });
    	let each_value = /*$list*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*s*/ ctx[5].uid;
    	validate_each_keys(ctx, each_value, get_each_context, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
    	}

    	infiniteloading = new InfiniteLoading({
    			props: {
    				spinner: "wavedots",
    				$$slots: {
    					noResults: [create_noResults_slot],
    					noMore: [create_noMore_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	infiniteloading.$on("infinite", /*infiniteHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(filters.$$.fragment);
    			t0 = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(infiniteloading.$$.fragment);
    			attr_dev(div, "class", "box svelte-n03c0i");
    			add_location(div, file$6, 64, 2, 1596);
    		},
    		m: function mount(target, anchor) {
    			mount_component(filters, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			insert_dev(target, t1, anchor);
    			mount_component(infiniteloading, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*quintOut, $list*/ 1) {
    				each_value = /*$list*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
    				validate_each_keys(ctx, each_value, get_each_context, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, fix_and_outro_and_destroy_block, create_each_block, null, get_each_context);
    				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
    				check_outros();
    			}

    			const infiniteloading_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				infiniteloading_changes.$$scope = { dirty, ctx };
    			}

    			infiniteloading.$set(infiniteloading_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(filters.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(infiniteloading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(filters.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(infiniteloading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(filters, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (detaching) detach_dev(t1);
    			destroy_component(infiniteloading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$2.name,
    		type: "then",
    		source: "(63:1) {:then}",
    		ctx
    	});

    	return block;
    }

    // (66:2) {#each $list as s (s.uid)}
    function create_each_block(key_1, ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let song;
    	let div0_outro;
    	let div1_intro;
    	let t;
    	let rect;
    	let stop_animation = noop;
    	let current;
    	const song_spread_levels = [/*s*/ ctx[5]];
    	let song_props = {};

    	for (let i = 0; i < song_spread_levels.length; i += 1) {
    		song_props = assign$1(song_props, song_spread_levels[i]);
    	}

    	song = new Song({ props: song_props, $$inline: true });

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(song.$$.fragment);
    			t = space();
    			add_location(div0, file$6, 68, 5, 1810);
    			add_location(div1, file$6, 67, 4, 1719);
    			add_location(div2, file$6, 66, 3, 1646);
    			this.first = div2;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			mount_component(song, div0, null);
    			append_dev(div2, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			const song_changes = (dirty & /*$list*/ 1)
    			? get_spread_update(song_spread_levels, [get_spread_object(/*s*/ ctx[5])])
    			: {};

    			song.$set(song_changes);
    		},
    		r: function measure() {
    			rect = div2.getBoundingClientRect();
    		},
    		f: function fix() {
    			fix_position(div2);
    			stop_animation();
    		},
    		a: function animate() {
    			stop_animation();

    			stop_animation = create_animation(div2, rect, flip, {
    				duration: 2000,
    				easing: quintOut,
    				delay: 150
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(song.$$.fragment, local);
    			if (div0_outro) div0_outro.end(1);

    			if (!div1_intro) {
    				add_render_callback(() => {
    					div1_intro = create_in_transition(div1, fly, {
    						duration: 3000,
    						x: -300,
    						opacity: 0,
    						easing: quintOut,
    						delay: /*$flyDelay*/ ctx[1]
    					});

    					div1_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(song.$$.fragment, local);
    			div0_outro = create_out_transition(div0, fly, { duration: 1000, x: 300, easing: quintOut });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(song);
    			if (detaching && div0_outro) div0_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(66:2) {#each $list as s (s.uid)}",
    		ctx
    	});

    	return block;
    }

    // (78:3) 
    function create_noMore_slot(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "that's all folks!";
    			attr_dev(span, "slot", "noMore");
    			add_location(span, file$6, 77, 3, 2014);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_noMore_slot.name,
    		type: "slot",
    		source: "(78:3) ",
    		ctx
    	});

    	return block;
    }

    // (81:3) 
    function create_noResults_slot(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "that's all folks!";
    			attr_dev(span, "slot", "noResults");
    			add_location(span, file$6, 80, 3, 2071);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_noResults_slot.name,
    		type: "slot",
    		source: "(81:3) ",
    		ctx
    	});

    	return block;
    }

    // (57:22)    <p>fetching your collaborative playlists from spotify.    <br>    <br>    if this is your first time launching this page, this might take a while.   </p>  {:then}
    function create_pending_block$2(ctx) {
    	let p;
    	let t0;
    	let br0;
    	let t1;
    	let br1;
    	let t2;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("fetching your collaborative playlists from spotify.\n\t\t\t");
    			br0 = element("br");
    			t1 = space();
    			br1 = element("br");
    			t2 = text("\n\t\t\tif this is your first time launching this page, this might take a while.");
    			add_location(br0, file$6, 58, 3, 1476);
    			add_location(br1, file$6, 59, 3, 1484);
    			add_location(p, file$6, 57, 2, 1418);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, br0);
    			append_dev(p, t1);
    			append_dev(p, br1);
    			append_dev(p, t2);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$2.name,
    		type: "pending",
    		source: "(57:22)    <p>fetching your collaborative playlists from spotify.    <br>    <br>    if this is your first time launching this page, this might take a while.   </p>  {:then}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let main;
    	let t;
    	let backtotop;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$2,
    		then: create_then_block$2,
    		catch: create_catch_block$2,
    		blocks: [,,,]
    	};

    	handle_promise(updateData(), info);
    	backtotop = new BackToTop({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			info.block.c();
    			t = space();
    			create_component(backtotop.$$.fragment);
    			add_location(main, file$6, 54, 0, 1385);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			info.block.m(main, info.anchor = null);
    			info.mount = () => main;
    			info.anchor = t;
    			append_dev(main, t);
    			mount_component(backtotop, main, null);
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			{
    				const child_ctx = ctx.slice();
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			transition_in(backtotop.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			transition_out(backtotop.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			info.block.d();
    			info.token = null;
    			info = null;
    			destroy_component(backtotop);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $limit;
    	let $list;
    	let $lastTouchedByUpdate;
    	let $flyDelay;
    	validate_store(limit, "limit");
    	component_subscribe($$self, limit, $$value => $$invalidate(3, $limit = $$value));
    	validate_store(list, "list");
    	component_subscribe($$self, list, $$value => $$invalidate(0, $list = $$value));
    	validate_store(lastTouchedByUpdate, "lastTouchedByUpdate");
    	component_subscribe($$self, lastTouchedByUpdate, $$value => $$invalidate(4, $lastTouchedByUpdate = $$value));
    	validate_store(flyDelay, "flyDelay");
    	component_subscribe($$self, flyDelay, $$value => $$invalidate(1, $flyDelay = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Feed", slots, []);
    	history.pushState({}, "feed", pushURL);

    	function infiniteHandler({ detail: { loaded, complete } }) {
    		readData($limit).then(rows => {
    			if (rows.length == $list.length && $lastTouchedByUpdate == false) {
    				complete();
    			} else {
    				limit.increment();
    				flyDelay.set(0);
    				list.set(rows);
    				lastTouchedByUpdate.no();
    				loaded();
    			}
    		});
    	}

    	onMount(() => {
    		setInterval(
    			() => {
    				console.log("Fetching new data...");

    				updateData().then(result => {
    					if (result) {
    						readData($limit).then(rows => {
    							flyDelay.set(400);
    							list.set(rows);
    							lastTouchedByUpdate.yes();
    						}).then(toast.push(`something happened!`));
    					}
    				});
    			},
    			120000
    		);

    		setInterval(
    			() => {
    				list.refresh();
    			},
    			60000
    		);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Feed> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		InfiniteLoading,
    		readData,
    		updateData,
    		toast,
    		flip,
    		fly,
    		quintOut,
    		pushURL,
    		limit,
    		list,
    		lastTouchedByUpdate,
    		flyDelay,
    		Filters,
    		Song,
    		BackToTop,
    		infiniteHandler,
    		$limit,
    		$list,
    		$lastTouchedByUpdate,
    		$flyDelay
    	});

    	return [$list, $flyDelay, infiniteHandler];
    }

    class Feed extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Feed",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src/modals/About.svelte generated by Svelte v3.37.0 */

    const file$5 = "src/modals/About.svelte";

    function create_fragment$5(ctx) {
    	let h1;
    	let t0;
    	let p0;
    	let t2;
    	let p1;
    	let t4;
    	let p2;
    	let t5;
    	let a;
    	let t7;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			t0 = text("what is this project?\n");
    			p0 = element("p");
    			p0.textContent = "this website can help you keep track of all the activity in your collaborative playlist.\nonce logged in, you will be able to see who added what song by what artist to which playlist how long ago. and it's all sorted chronologically! just keep scrolling to travel back in time. while you browse the page periodically checks if anything has happened and, if anything has, will automatically adjust your feed and tell you. no refreshing required.";
    			t2 = text("\nwhy is this project a thing?\n");
    			p1 = element("p");
    			p1.textContent = "there's a good chance this isn't something you want (or need). however if you and peers enjoy actively making use of the collaborative playlist feature then this is supposed to serve you as a fairly easy and comfortable way of keeping up with recently added songs across a large quantity of playlists.";
    			t4 = text("\nis this it?\n");
    			p2 = element("p");
    			t5 = text("this is a passion project i work on in my spare time. i am aware the current version is very basic but more features are planned and in development. if you want more information or are looking to contribute feel free to check out the ");
    			a = element("a");
    			a.textContent = "the github page";
    			t7 = text(".");
    			attr_dev(p0, "class", "svelte-1uxb3mi");
    			add_location(p0, file$5, 2, 0, 27);
    			attr_dev(p1, "class", "svelte-1uxb3mi");
    			add_location(p1, file$5, 7, 0, 509);
    			attr_dev(a, "href", "https://github.com/sebastian-stubenvoll/spotify-collab-tracker");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "class", "svelte-1uxb3mi");
    			add_location(a, file$5, 12, 234, 1070);
    			attr_dev(p2, "class", "svelte-1uxb3mi");
    			add_location(p2, file$5, 11, 0, 832);
    			attr_dev(h1, "class", "svelte-1uxb3mi");
    			add_location(h1, file$5, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			append_dev(h1, t0);
    			append_dev(h1, p0);
    			append_dev(h1, t2);
    			append_dev(h1, p1);
    			append_dev(h1, t4);
    			append_dev(h1, p2);
    			append_dev(p2, t5);
    			append_dev(p2, a);
    			append_dev(p2, t7);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("About", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<About> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class About extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "About",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src/modals/Privacy.svelte generated by Svelte v3.37.0 */
    const file$4 = "src/modals/Privacy.svelte";

    function create_fragment$4(ctx) {
    	let h1;
    	let t0;
    	let p0;
    	let t1;
    	let b0;
    	let t3;
    	let t4;
    	let p1;
    	let t5;
    	let b1;
    	let t7;
    	let button;
    	let b2;
    	let t9;
    	let t10;
    	let p2;
    	let t12;
    	let p3;
    	let t13;
    	let a;
    	let b3;
    	let t15;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			t0 = text("how is my data accessed?\n\t");
    			p0 = element("p");
    			t1 = text("once you've logged in via spotify and granted the required permissions all the requests are sent from ");
    			b0 = element("b");
    			b0.textContent = "your browser directly to spotify";
    			t3 = text(". this means none of your private spotify data is ever accessed by the server hosting this website.");
    			t4 = text("\nhow is my data stored?\n");
    			p1 = element("p");
    			t5 = text("all of your data is stored ");
    			b1 = element("b");
    			b1.textContent = "locally";
    			t7 = text(" inside your browser (indexedDB). this is only done to keep the number of requests as low as possible. you can delete the locally stored information at any point by via your browser or clicking ");
    			button = element("button");
    			b2 = element("b");
    			b2.textContent = "here";
    			t9 = text(".");
    			t10 = text("\ndoes this page store cookies?\n");
    			p2 = element("p");
    			p2.textContent = "no. this webapp only store the data that is necessary for functionality.";
    			t12 = text("\ni'm still not sure...\n");
    			p3 = element("p");
    			t13 = text("if you have any remaining concerns, feel free to check out the ");
    			a = element("a");
    			b3 = element("b");
    			b3.textContent = "source code";
    			t15 = text(".");
    			add_location(b0, file$4, 13, 104, 353);
    			attr_dev(p0, "class", "svelte-17vdl9c");
    			add_location(p0, file$4, 12, 1, 245);
    			add_location(b1, file$4, 17, 28, 553);
    			add_location(b2, file$4, 17, 265, 790);
    			attr_dev(button, "class", "svelte-17vdl9c");
    			add_location(button, file$4, 17, 236, 761);
    			attr_dev(p1, "class", "svelte-17vdl9c");
    			add_location(p1, file$4, 16, 0, 521);
    			attr_dev(p2, "class", "svelte-17vdl9c");
    			add_location(p2, file$4, 20, 0, 847);
    			add_location(b3, file$4, 23, 153, 1107);
    			attr_dev(a, "href", "https://github.com/sebastian-stubenvoll/spotify-collab-tracker");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "class", "svelte-17vdl9c");
    			add_location(a, file$4, 23, 64, 1018);
    			attr_dev(p3, "class", "svelte-17vdl9c");
    			add_location(p3, file$4, 22, 0, 950);
    			attr_dev(h1, "class", "svelte-17vdl9c");
    			add_location(h1, file$4, 10, 0, 213);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			append_dev(h1, t0);
    			append_dev(h1, p0);
    			append_dev(p0, t1);
    			append_dev(p0, b0);
    			append_dev(p0, t3);
    			append_dev(h1, t4);
    			append_dev(h1, p1);
    			append_dev(p1, t5);
    			append_dev(p1, b1);
    			append_dev(p1, t7);
    			append_dev(p1, button);
    			append_dev(button, b2);
    			append_dev(p1, t9);
    			append_dev(h1, t10);
    			append_dev(h1, p2);
    			append_dev(h1, t12);
    			append_dev(h1, p3);
    			append_dev(p3, t13);
    			append_dev(p3, a);
    			append_dev(a, b3);
    			append_dev(p3, t15);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*clearData*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Privacy", slots, []);

    	const clearData = () => {
    		deleteData();
    		toast.push("All your data has been deleted!");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Privacy> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ deleteData, toast, clearData });
    	return [clearData];
    }

    class Privacy extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Privacy",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src/modals/CloseButton.svelte generated by Svelte v3.37.0 */

    const file$3 = "src/modals/CloseButton.svelte";

    function create_fragment$3(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Ã";
    			attr_dev(button, "class", "svelte-x3sqgi");
    			add_location(button, file$3, 4, 0, 41);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*onClose*/ ctx[0])) /*onClose*/ ctx[0].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CloseButton", slots, []);
    	let { onClose } = $$props;
    	const writable_props = ["onClose"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CloseButton> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("onClose" in $$props) $$invalidate(0, onClose = $$props.onClose);
    	};

    	$$self.$capture_state = () => ({ onClose });

    	$$self.$inject_state = $$props => {
    		if ("onClose" in $$props) $$invalidate(0, onClose = $$props.onClose);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [onClose];
    }

    class CloseButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { onClose: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CloseButton",
    			options,
    			id: create_fragment$3.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onClose*/ ctx[0] === undefined && !("onClose" in props)) {
    			console.warn("<CloseButton> was created without expected prop 'onClose'");
    		}
    	}

    	get onClose() {
    		throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClose(value) {
    		throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Login.svelte generated by Svelte v3.37.0 */
    const file$2 = "src/components/Login.svelte";

    // (1:0) <script>  import { createAuthURL }
    function create_catch_block$1(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$1.name,
    		type: "catch",
    		source: "(1:0) <script>  import { createAuthURL }",
    		ctx
    	});

    	return block;
    }

    // (28:0) {:then url}
    function create_then_block$1(ctx) {
    	let h1;
    	let p;
    	let a;
    	let t0;
    	let t1;
    	let br;
    	let t2;
    	let button0;
    	let button1;
    	let p_intro;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			p = element("p");
    			a = element("a");
    			t0 = text("login with spotify");
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			button0 = element("button");
    			button0.textContent = "privacy";
    			button1 = element("button");
    			button1.textContent = "about";
    			attr_dev(a, "href", /*url*/ ctx[6]);
    			attr_dev(a, "class", "svelte-1qhf4fy");
    			add_location(a, file$2, 30, 3, 817);
    			add_location(br, file$2, 31, 3, 857);
    			attr_dev(button0, "class", "svelte-1qhf4fy");
    			add_location(button0, file$2, 32, 3, 865);
    			attr_dev(button1, "class", "svelte-1qhf4fy");
    			add_location(button1, file$2, 32, 50, 912);
    			add_location(p, file$2, 29, 2, 748);
    			attr_dev(h1, "class", "svelte-1qhf4fy");
    			add_location(h1, file$2, 28, 1, 741);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			append_dev(h1, p);
    			append_dev(p, a);
    			append_dev(a, t0);
    			append_dev(p, t1);
    			append_dev(p, br);
    			append_dev(p, t2);
    			append_dev(p, button0);
    			append_dev(p, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*showPrivacy*/ ctx[3], false, false, false),
    					listen_dev(button1, "click", /*showAbout*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (!p_intro) {
    				add_render_callback(() => {
    					p_intro = create_in_transition(p, fly, {
    						duration: 2000,
    						y: /*y*/ ctx[0] / 3,
    						opacity: 0,
    						easing: quadOut
    					});

    					p_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$1.name,
    		type: "then",
    		source: "(28:0) {:then url}",
    		ctx
    	});

    	return block;
    }

    // (26:16)   <h1> </h1> {:then url}
    function create_pending_block$1(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			attr_dev(h1, "class", "svelte-1qhf4fy");
    			add_location(h1, file$2, 26, 1, 717);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$1.name,
    		type: "pending",
    		source: "(26:16)   <h1> </h1> {:then url}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let link;
    	let t;
    	let await_block_anchor;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[4]);

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$1,
    		then: create_then_block$1,
    		catch: create_catch_block$1,
    		value: 6
    	};

    	handle_promise(/*authURL*/ ctx[1], info);

    	const block = {
    		c: function create() {
    			link = element("link");
    			t = space();
    			await_block_anchor = empty();
    			info.block.c();
    			attr_dev(link, "rel", "stylesheet");
    			attr_dev(link, "href", "login.css");
    			add_location(link, file$2, 20, 1, 603);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, link);
    			insert_dev(target, t, anchor);
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;

    			if (!mounted) {
    				dispose = listen_dev(window, "resize", /*onwindowresize*/ ctx[4]);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			{
    				const child_ctx = ctx.slice();
    				child_ctx[6] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			transition_in(info.block);
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			detach_dev(link);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Login", slots, []);
    	const authURL = createAuthURL();
    	let y;
    	const { open } = getContext("simple-modal");
    	const showAbout = () => open(About, {}, { closeButton: CloseButton });
    	const showPrivacy = () => open(Privacy, {}, { closeButton: CloseButton });
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Login> was created with unknown prop '${key}'`);
    	});

    	function onwindowresize() {
    		$$invalidate(0, y = window.innerHeight);
    	}

    	$$self.$capture_state = () => ({
    		createAuthURL,
    		fly,
    		quadOut,
    		getContext,
    		About,
    		Privacy,
    		CloseButton,
    		authURL,
    		y,
    		open,
    		showAbout,
    		showPrivacy
    	});

    	$$self.$inject_state = $$props => {
    		if ("y" in $$props) $$invalidate(0, y = $$props.y);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [y, authURL, showAbout, showPrivacy, onwindowresize];
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/components/Modal.svelte generated by Svelte v3.37.0 */

    const { Object: Object_1, window: window_1 } = globals;
    const file$1 = "src/components/Modal.svelte";

    // (316:0) {#if Component}
    function create_if_block$1(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let t;
    	let div0;
    	let switch_instance;
    	let div1_transition;
    	let div3_transition;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*state*/ ctx[0].closeButton && create_if_block_1(ctx);
    	var switch_value = /*Component*/ ctx[1];

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			div0 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div0, "class", "content svelte-2wx9ab");
    			attr_dev(div0, "style", /*cssContent*/ ctx[8]);
    			add_location(div0, file$1, 343, 8, 8237);
    			attr_dev(div1, "class", "window svelte-2wx9ab");
    			attr_dev(div1, "role", "dialog");
    			attr_dev(div1, "aria-modal", "true");
    			attr_dev(div1, "style", /*cssWindow*/ ctx[7]);
    			add_location(div1, file$1, 324, 6, 7612);
    			attr_dev(div2, "class", "window-wrap svelte-2wx9ab");
    			attr_dev(div2, "style", /*cssWindowWrap*/ ctx[6]);
    			add_location(div2, file$1, 323, 4, 7541);
    			attr_dev(div3, "class", "bg svelte-2wx9ab");
    			attr_dev(div3, "style", /*cssBg*/ ctx[5]);
    			add_location(div3, file$1, 316, 2, 7375);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);

    			if (switch_instance) {
    				mount_component(switch_instance, div0, null);
    			}

    			/*div1_binding*/ ctx[37](div1);
    			/*div2_binding*/ ctx[38](div2);
    			/*div3_binding*/ ctx[39](div3);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						div1,
    						"introstart",
    						function () {
    							if (is_function(/*onOpen*/ ctx[12])) /*onOpen*/ ctx[12].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div1,
    						"outrostart",
    						function () {
    							if (is_function(/*onClose*/ ctx[13])) /*onClose*/ ctx[13].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div1,
    						"introend",
    						function () {
    							if (is_function(/*onOpened*/ ctx[14])) /*onOpened*/ ctx[14].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div1,
    						"outroend",
    						function () {
    							if (is_function(/*onClosed*/ ctx[15])) /*onClosed*/ ctx[15].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(div3, "click", /*handleOuterClick*/ ctx[19], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*state*/ ctx[0].closeButton) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*state*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (switch_value !== (switch_value = /*Component*/ ctx[1])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div0, null);
    				} else {
    					switch_instance = null;
    				}
    			}

    			if (!current || dirty[0] & /*cssContent*/ 256) {
    				attr_dev(div0, "style", /*cssContent*/ ctx[8]);
    			}

    			if (!current || dirty[0] & /*cssWindow*/ 128) {
    				attr_dev(div1, "style", /*cssWindow*/ ctx[7]);
    			}

    			if (!current || dirty[0] & /*cssWindowWrap*/ 64) {
    				attr_dev(div2, "style", /*cssWindowWrap*/ ctx[6]);
    			}

    			if (!current || dirty[0] & /*cssBg*/ 32) {
    				attr_dev(div3, "style", /*cssBg*/ ctx[5]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, /*currentTransitionWindow*/ ctx[11], /*state*/ ctx[0].transitionWindowProps, true);
    				div1_transition.run(1);
    			});

    			add_render_callback(() => {
    				if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*currentTransitionBg*/ ctx[10], /*state*/ ctx[0].transitionBgProps, true);
    				div3_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, /*currentTransitionWindow*/ ctx[11], /*state*/ ctx[0].transitionWindowProps, false);
    			div1_transition.run(0);
    			if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*currentTransitionBg*/ ctx[10], /*state*/ ctx[0].transitionBgProps, false);
    			div3_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block) if_block.d();
    			if (switch_instance) destroy_component(switch_instance);
    			/*div1_binding*/ ctx[37](null);
    			if (detaching && div1_transition) div1_transition.end();
    			/*div2_binding*/ ctx[38](null);
    			/*div3_binding*/ ctx[39](null);
    			if (detaching && div3_transition) div3_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(316:0) {#if Component}",
    		ctx
    	});

    	return block;
    }

    // (337:8) {#if state.closeButton}
    function create_if_block_1(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty[0] & /*state*/ 1) show_if = !!/*isFunction*/ ctx[16](/*state*/ ctx[0].closeButton);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, [-1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(337:8) {#if state.closeButton}",
    		ctx
    	});

    	return block;
    }

    // (340:10) {:else}
    function create_else_block$1(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			attr_dev(button, "class", "close svelte-2wx9ab");
    			attr_dev(button, "style", /*cssCloseButton*/ ctx[9]);
    			add_location(button, file$1, 340, 12, 8134);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*close*/ ctx[17], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*cssCloseButton*/ 512) {
    				attr_dev(button, "style", /*cssCloseButton*/ ctx[9]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(340:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (338:10) {#if isFunction(state.closeButton)}
    function create_if_block_2(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*state*/ ctx[0].closeButton;

    	function switch_props(ctx) {
    		return {
    			props: { onClose: /*close*/ ctx[17] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*state*/ ctx[0].closeButton)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(338:10) {#if isFunction(state.closeButton)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*Component*/ ctx[1] && create_if_block$1(ctx);
    	const default_slot_template = /*#slots*/ ctx[36].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[35], null);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window_1, "keydown", /*handleKeydown*/ ctx[18], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*Component*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*Component*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty[1] & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[35], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function bind(Component, props = {}) {
    	return function ModalComponent(options) {
    		return new Component({
    				...options,
    				props: { ...props, ...options.props }
    			});
    	};
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Modal", slots, ['default']);
    	const dispatch = createEventDispatcher();
    	const baseSetContext = setContext;
    	let { show = null } = $$props;
    	let { key = "simple-modal" } = $$props;
    	let { closeButton = true } = $$props;
    	let { closeOnEsc = true } = $$props;
    	let { closeOnOuterClick = true } = $$props;
    	let { styleBg = {} } = $$props;
    	let { styleWindowWrap = {} } = $$props;
    	let { styleWindow = {} } = $$props;
    	let { styleContent = {} } = $$props;
    	let { styleCloseButton = {} } = $$props;
    	let { setContext: setContext$1 = baseSetContext } = $$props;
    	let { transitionBg = fade } = $$props;
    	let { transitionBgProps = { duration: 250 } } = $$props;
    	let { transitionWindow = transitionBg } = $$props;
    	let { transitionWindowProps = transitionBgProps } = $$props;

    	const defaultState = {
    		closeButton,
    		closeOnEsc,
    		closeOnOuterClick,
    		styleBg,
    		styleWindowWrap,
    		styleWindow,
    		styleContent,
    		styleCloseButton,
    		transitionBg,
    		transitionBgProps,
    		transitionWindow,
    		transitionWindowProps
    	};

    	let state = { ...defaultState };
    	let Component = null;
    	let background;
    	let wrap;
    	let modalWindow;
    	let scrollY;
    	let cssBg;
    	let cssWindowWrap;
    	let cssWindow;
    	let cssContent;
    	let cssCloseButton;
    	let currentTransitionBg;
    	let currentTransitionWindow;
    	let prevBodyPosition;
    	let prevBodyOverflow;
    	const camelCaseToDash = str => str.replace(/([a-zA-Z])(?=[A-Z])/g, "$1-").toLowerCase();
    	const toCssString = props => Object.keys(props).reduce((str, key) => `${str}; ${camelCaseToDash(key)}: ${props[key]}`, "");
    	const isFunction = f => !!(f && f.constructor && f.call && f.apply);

    	const updateStyleTransition = () => {
    		$$invalidate(5, cssBg = toCssString(state.styleBg));
    		$$invalidate(6, cssWindowWrap = toCssString(state.styleWindowWrap));
    		$$invalidate(7, cssWindow = toCssString(state.styleWindow));
    		$$invalidate(8, cssContent = toCssString(state.styleContent));
    		$$invalidate(9, cssCloseButton = toCssString(state.styleCloseButton));
    		$$invalidate(10, currentTransitionBg = state.transitionBg);
    		$$invalidate(11, currentTransitionWindow = state.transitionWindow);
    	};

    	const toVoid = () => {
    		
    	};

    	let onOpen = toVoid;
    	let onClose = toVoid;
    	let onOpened = toVoid;
    	let onClosed = toVoid;

    	const open = (NewComponent, newProps = {}, options = {}, callback = {}) => {
    		$$invalidate(1, Component = bind(NewComponent, newProps));
    		$$invalidate(0, state = { ...defaultState, ...options });
    		updateStyleTransition();
    		disableScroll();

    		($$invalidate(12, onOpen = event => {
    			if (callback.onOpen) callback.onOpen(event);
    			dispatch("open");
    			dispatch("opening"); // Deprecated. Do not use!
    		}), $$invalidate(13, onClose = event => {
    			if (callback.onClose) callback.onClose(event);
    			dispatch("close");
    			dispatch("closing"); // Deprecated. Do not use!
    		}), $$invalidate(14, onOpened = event => {
    			if (callback.onOpened) callback.onOpened(event);
    			dispatch("opened");
    		}));

    		$$invalidate(15, onClosed = event => {
    			if (callback.onClosed) callback.onClosed(event);
    			dispatch("closed");
    		});
    	};

    	const close = (callback = {}) => {
    		$$invalidate(13, onClose = callback.onClose || onClose);
    		$$invalidate(15, onClosed = callback.onClosed || onClosed);
    		$$invalidate(1, Component = null);
    		enableScroll();
    	};

    	const handleKeydown = event => {
    		if (state.closeOnEsc && Component && event.key === "Escape") {
    			event.preventDefault();
    			close();
    		}

    		if (Component && event.key === "Tab") {
    			// trap focus
    			const nodes = modalWindow.querySelectorAll("*");

    			const tabbable = Array.from(nodes).filter(node => node.tabIndex >= 0);
    			let index = tabbable.indexOf(document.activeElement);
    			if (index === -1 && event.shiftKey) index = 0;
    			index += tabbable.length + (event.shiftKey ? -1 : 1);
    			index %= tabbable.length;
    			tabbable[index].focus();
    			event.preventDefault();
    		}
    	};

    	const handleOuterClick = event => {
    		if (state.closeOnOuterClick && (event.target === background || event.target === wrap)) {
    			event.preventDefault();
    			close();
    		}
    	};

    	const disableScroll = () => {
    		scrollY = window.scrollY;
    		prevBodyPosition = document.body.style.position;
    		prevBodyOverflow = document.body.style.overflow;
    		document.body.style.position = "fixed";
    		document.body.style.top = `-${scrollY}px`;
    		document.body.style.overflow = "hidden";
    	};

    	const enableScroll = () => {
    		document.body.style.position = prevBodyPosition || "";
    		document.body.style.top = "";
    		document.body.style.overflow = prevBodyOverflow || "";
    		window.scrollTo(0, scrollY);
    	};

    	setContext$1(key, { open, close });

    	onDestroy(() => {
    		close();
    	});

    	const writable_props = [
    		"show",
    		"key",
    		"closeButton",
    		"closeOnEsc",
    		"closeOnOuterClick",
    		"styleBg",
    		"styleWindowWrap",
    		"styleWindow",
    		"styleContent",
    		"styleCloseButton",
    		"setContext",
    		"transitionBg",
    		"transitionBgProps",
    		"transitionWindow",
    		"transitionWindowProps"
    	];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Modal> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			modalWindow = $$value;
    			$$invalidate(4, modalWindow);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			wrap = $$value;
    			$$invalidate(3, wrap);
    		});
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			background = $$value;
    			$$invalidate(2, background);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("show" in $$props) $$invalidate(20, show = $$props.show);
    		if ("key" in $$props) $$invalidate(21, key = $$props.key);
    		if ("closeButton" in $$props) $$invalidate(22, closeButton = $$props.closeButton);
    		if ("closeOnEsc" in $$props) $$invalidate(23, closeOnEsc = $$props.closeOnEsc);
    		if ("closeOnOuterClick" in $$props) $$invalidate(24, closeOnOuterClick = $$props.closeOnOuterClick);
    		if ("styleBg" in $$props) $$invalidate(25, styleBg = $$props.styleBg);
    		if ("styleWindowWrap" in $$props) $$invalidate(26, styleWindowWrap = $$props.styleWindowWrap);
    		if ("styleWindow" in $$props) $$invalidate(27, styleWindow = $$props.styleWindow);
    		if ("styleContent" in $$props) $$invalidate(28, styleContent = $$props.styleContent);
    		if ("styleCloseButton" in $$props) $$invalidate(29, styleCloseButton = $$props.styleCloseButton);
    		if ("setContext" in $$props) $$invalidate(30, setContext$1 = $$props.setContext);
    		if ("transitionBg" in $$props) $$invalidate(31, transitionBg = $$props.transitionBg);
    		if ("transitionBgProps" in $$props) $$invalidate(32, transitionBgProps = $$props.transitionBgProps);
    		if ("transitionWindow" in $$props) $$invalidate(33, transitionWindow = $$props.transitionWindow);
    		if ("transitionWindowProps" in $$props) $$invalidate(34, transitionWindowProps = $$props.transitionWindowProps);
    		if ("$$scope" in $$props) $$invalidate(35, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		bind,
    		svelte,
    		fade,
    		createEventDispatcher,
    		dispatch,
    		baseSetContext,
    		show,
    		key,
    		closeButton,
    		closeOnEsc,
    		closeOnOuterClick,
    		styleBg,
    		styleWindowWrap,
    		styleWindow,
    		styleContent,
    		styleCloseButton,
    		setContext: setContext$1,
    		transitionBg,
    		transitionBgProps,
    		transitionWindow,
    		transitionWindowProps,
    		defaultState,
    		state,
    		Component,
    		background,
    		wrap,
    		modalWindow,
    		scrollY,
    		cssBg,
    		cssWindowWrap,
    		cssWindow,
    		cssContent,
    		cssCloseButton,
    		currentTransitionBg,
    		currentTransitionWindow,
    		prevBodyPosition,
    		prevBodyOverflow,
    		camelCaseToDash,
    		toCssString,
    		isFunction,
    		updateStyleTransition,
    		toVoid,
    		onOpen,
    		onClose,
    		onOpened,
    		onClosed,
    		open,
    		close,
    		handleKeydown,
    		handleOuterClick,
    		disableScroll,
    		enableScroll
    	});

    	$$self.$inject_state = $$props => {
    		if ("show" in $$props) $$invalidate(20, show = $$props.show);
    		if ("key" in $$props) $$invalidate(21, key = $$props.key);
    		if ("closeButton" in $$props) $$invalidate(22, closeButton = $$props.closeButton);
    		if ("closeOnEsc" in $$props) $$invalidate(23, closeOnEsc = $$props.closeOnEsc);
    		if ("closeOnOuterClick" in $$props) $$invalidate(24, closeOnOuterClick = $$props.closeOnOuterClick);
    		if ("styleBg" in $$props) $$invalidate(25, styleBg = $$props.styleBg);
    		if ("styleWindowWrap" in $$props) $$invalidate(26, styleWindowWrap = $$props.styleWindowWrap);
    		if ("styleWindow" in $$props) $$invalidate(27, styleWindow = $$props.styleWindow);
    		if ("styleContent" in $$props) $$invalidate(28, styleContent = $$props.styleContent);
    		if ("styleCloseButton" in $$props) $$invalidate(29, styleCloseButton = $$props.styleCloseButton);
    		if ("setContext" in $$props) $$invalidate(30, setContext$1 = $$props.setContext);
    		if ("transitionBg" in $$props) $$invalidate(31, transitionBg = $$props.transitionBg);
    		if ("transitionBgProps" in $$props) $$invalidate(32, transitionBgProps = $$props.transitionBgProps);
    		if ("transitionWindow" in $$props) $$invalidate(33, transitionWindow = $$props.transitionWindow);
    		if ("transitionWindowProps" in $$props) $$invalidate(34, transitionWindowProps = $$props.transitionWindowProps);
    		if ("state" in $$props) $$invalidate(0, state = $$props.state);
    		if ("Component" in $$props) $$invalidate(1, Component = $$props.Component);
    		if ("background" in $$props) $$invalidate(2, background = $$props.background);
    		if ("wrap" in $$props) $$invalidate(3, wrap = $$props.wrap);
    		if ("modalWindow" in $$props) $$invalidate(4, modalWindow = $$props.modalWindow);
    		if ("scrollY" in $$props) scrollY = $$props.scrollY;
    		if ("cssBg" in $$props) $$invalidate(5, cssBg = $$props.cssBg);
    		if ("cssWindowWrap" in $$props) $$invalidate(6, cssWindowWrap = $$props.cssWindowWrap);
    		if ("cssWindow" in $$props) $$invalidate(7, cssWindow = $$props.cssWindow);
    		if ("cssContent" in $$props) $$invalidate(8, cssContent = $$props.cssContent);
    		if ("cssCloseButton" in $$props) $$invalidate(9, cssCloseButton = $$props.cssCloseButton);
    		if ("currentTransitionBg" in $$props) $$invalidate(10, currentTransitionBg = $$props.currentTransitionBg);
    		if ("currentTransitionWindow" in $$props) $$invalidate(11, currentTransitionWindow = $$props.currentTransitionWindow);
    		if ("prevBodyPosition" in $$props) prevBodyPosition = $$props.prevBodyPosition;
    		if ("prevBodyOverflow" in $$props) prevBodyOverflow = $$props.prevBodyOverflow;
    		if ("onOpen" in $$props) $$invalidate(12, onOpen = $$props.onOpen);
    		if ("onClose" in $$props) $$invalidate(13, onClose = $$props.onClose);
    		if ("onOpened" in $$props) $$invalidate(14, onOpened = $$props.onOpened);
    		if ("onClosed" in $$props) $$invalidate(15, onClosed = $$props.onClosed);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*show*/ 1048576) {
    			{
    				if (isFunction(show)) {
    					open(show);
    				} else {
    					close();
    				}
    			}
    		}
    	};

    	return [
    		state,
    		Component,
    		background,
    		wrap,
    		modalWindow,
    		cssBg,
    		cssWindowWrap,
    		cssWindow,
    		cssContent,
    		cssCloseButton,
    		currentTransitionBg,
    		currentTransitionWindow,
    		onOpen,
    		onClose,
    		onOpened,
    		onClosed,
    		isFunction,
    		close,
    		handleKeydown,
    		handleOuterClick,
    		show,
    		key,
    		closeButton,
    		closeOnEsc,
    		closeOnOuterClick,
    		styleBg,
    		styleWindowWrap,
    		styleWindow,
    		styleContent,
    		styleCloseButton,
    		setContext$1,
    		transitionBg,
    		transitionBgProps,
    		transitionWindow,
    		transitionWindowProps,
    		$$scope,
    		slots,
    		div1_binding,
    		div2_binding,
    		div3_binding
    	];
    }

    class Modal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$1,
    			create_fragment$1,
    			safe_not_equal,
    			{
    				show: 20,
    				key: 21,
    				closeButton: 22,
    				closeOnEsc: 23,
    				closeOnOuterClick: 24,
    				styleBg: 25,
    				styleWindowWrap: 26,
    				styleWindow: 27,
    				styleContent: 28,
    				styleCloseButton: 29,
    				setContext: 30,
    				transitionBg: 31,
    				transitionBgProps: 32,
    				transitionWindow: 33,
    				transitionWindowProps: 34
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modal",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get show() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeButton() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeButton(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeOnEsc() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeOnEsc(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeOnOuterClick() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeOnOuterClick(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleBg() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleBg(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleWindowWrap() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleWindowWrap(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleWindow() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleWindow(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleContent() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleContent(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleCloseButton() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleCloseButton(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setContext() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set setContext(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionBg() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionBg(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionBgProps() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionBgProps(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionWindow() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionWindow(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionWindowProps() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionWindowProps(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var strictUriEncode = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

    var token = '%[a-f0-9]{2}';
    var singleMatcher = new RegExp(token, 'gi');
    var multiMatcher = new RegExp('(' + token + ')+', 'gi');

    function decodeComponents(components, split) {
    	try {
    		// Try to decode the entire string first
    		return decodeURIComponent(components.join(''));
    	} catch (err) {
    		// Do nothing
    	}

    	if (components.length === 1) {
    		return components;
    	}

    	split = split || 1;

    	// Split the array in 2 parts
    	var left = components.slice(0, split);
    	var right = components.slice(split);

    	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }

    function decode(input) {
    	try {
    		return decodeURIComponent(input);
    	} catch (err) {
    		var tokens = input.match(singleMatcher);

    		for (var i = 1; i < tokens.length; i++) {
    			input = decodeComponents(tokens, i).join('');

    			tokens = input.match(singleMatcher);
    		}

    		return input;
    	}
    }

    function customDecodeURIComponent(input) {
    	// Keep track of all the replacements and prefill the map with the `BOM`
    	var replaceMap = {
    		'%FE%FF': '\uFFFD\uFFFD',
    		'%FF%FE': '\uFFFD\uFFFD'
    	};

    	var match = multiMatcher.exec(input);
    	while (match) {
    		try {
    			// Decode as big chunks as possible
    			replaceMap[match[0]] = decodeURIComponent(match[0]);
    		} catch (err) {
    			var result = decode(match[0]);

    			if (result !== match[0]) {
    				replaceMap[match[0]] = result;
    			}
    		}

    		match = multiMatcher.exec(input);
    	}

    	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
    	replaceMap['%C2'] = '\uFFFD';

    	var entries = Object.keys(replaceMap);

    	for (var i = 0; i < entries.length; i++) {
    		// Replace all decoded components
    		var key = entries[i];
    		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    	}

    	return input;
    }

    var decodeUriComponent = function (encodedURI) {
    	if (typeof encodedURI !== 'string') {
    		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    	}

    	try {
    		encodedURI = encodedURI.replace(/\+/g, ' ');

    		// Try the built in decoder first
    		return decodeURIComponent(encodedURI);
    	} catch (err) {
    		// Fallback to a more advanced decoder
    		return customDecodeURIComponent(encodedURI);
    	}
    };

    var splitOnFirst = (string, separator) => {
    	if (!(typeof string === 'string' && typeof separator === 'string')) {
    		throw new TypeError('Expected the arguments to be of type `string`');
    	}

    	if (separator === '') {
    		return [string];
    	}

    	const separatorIndex = string.indexOf(separator);

    	if (separatorIndex === -1) {
    		return [string];
    	}

    	return [
    		string.slice(0, separatorIndex),
    		string.slice(separatorIndex + separator.length)
    	];
    };

    var filterObj = function (obj, predicate) {
    	var ret = {};
    	var keys = Object.keys(obj);
    	var isArr = Array.isArray(predicate);

    	for (var i = 0; i < keys.length; i++) {
    		var key = keys[i];
    		var val = obj[key];

    		if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
    			ret[key] = val;
    		}
    	}

    	return ret;
    };

    var queryString = createCommonjsModule(function (module, exports) {





    const isNullOrUndefined = value => value === null || value === undefined;

    function encoderForArrayFormat(options) {
    	switch (options.arrayFormat) {
    		case 'index':
    			return key => (result, value) => {
    				const index = result.length;

    				if (
    					value === undefined ||
    					(options.skipNull && value === null) ||
    					(options.skipEmptyString && value === '')
    				) {
    					return result;
    				}

    				if (value === null) {
    					return [...result, [encode(key, options), '[', index, ']'].join('')];
    				}

    				return [
    					...result,
    					[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
    				];
    			};

    		case 'bracket':
    			return key => (result, value) => {
    				if (
    					value === undefined ||
    					(options.skipNull && value === null) ||
    					(options.skipEmptyString && value === '')
    				) {
    					return result;
    				}

    				if (value === null) {
    					return [...result, [encode(key, options), '[]'].join('')];
    				}

    				return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
    			};

    		case 'comma':
    		case 'separator':
    		case 'bracket-separator': {
    			const keyValueSep = options.arrayFormat === 'bracket-separator' ?
    				'[]=' :
    				'=';

    			return key => (result, value) => {
    				if (
    					value === undefined ||
    					(options.skipNull && value === null) ||
    					(options.skipEmptyString && value === '')
    				) {
    					return result;
    				}

    				// Translate null to an empty string so that it doesn't serialize as 'null'
    				value = value === null ? '' : value;

    				if (result.length === 0) {
    					return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
    				}

    				return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
    			};
    		}

    		default:
    			return key => (result, value) => {
    				if (
    					value === undefined ||
    					(options.skipNull && value === null) ||
    					(options.skipEmptyString && value === '')
    				) {
    					return result;
    				}

    				if (value === null) {
    					return [...result, encode(key, options)];
    				}

    				return [...result, [encode(key, options), '=', encode(value, options)].join('')];
    			};
    	}
    }

    function parserForArrayFormat(options) {
    	let result;

    	switch (options.arrayFormat) {
    		case 'index':
    			return (key, value, accumulator) => {
    				result = /\[(\d*)\]$/.exec(key);

    				key = key.replace(/\[\d*\]$/, '');

    				if (!result) {
    					accumulator[key] = value;
    					return;
    				}

    				if (accumulator[key] === undefined) {
    					accumulator[key] = {};
    				}

    				accumulator[key][result[1]] = value;
    			};

    		case 'bracket':
    			return (key, value, accumulator) => {
    				result = /(\[\])$/.exec(key);
    				key = key.replace(/\[\]$/, '');

    				if (!result) {
    					accumulator[key] = value;
    					return;
    				}

    				if (accumulator[key] === undefined) {
    					accumulator[key] = [value];
    					return;
    				}

    				accumulator[key] = [].concat(accumulator[key], value);
    			};

    		case 'comma':
    		case 'separator':
    			return (key, value, accumulator) => {
    				const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
    				const isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
    				value = isEncodedArray ? decode(value, options) : value;
    				const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
    				accumulator[key] = newValue;
    			};

    		case 'bracket-separator':
    			return (key, value, accumulator) => {
    				const isArray = /(\[\])$/.test(key);
    				key = key.replace(/\[\]$/, '');

    				if (!isArray) {
    					accumulator[key] = value ? decode(value, options) : value;
    					return;
    				}

    				const arrayValue = value === null ?
    					[] :
    					value.split(options.arrayFormatSeparator).map(item => decode(item, options));

    				if (accumulator[key] === undefined) {
    					accumulator[key] = arrayValue;
    					return;
    				}

    				accumulator[key] = [].concat(accumulator[key], arrayValue);
    			};

    		default:
    			return (key, value, accumulator) => {
    				if (accumulator[key] === undefined) {
    					accumulator[key] = value;
    					return;
    				}

    				accumulator[key] = [].concat(accumulator[key], value);
    			};
    	}
    }

    function validateArrayFormatSeparator(value) {
    	if (typeof value !== 'string' || value.length !== 1) {
    		throw new TypeError('arrayFormatSeparator must be single character string');
    	}
    }

    function encode(value, options) {
    	if (options.encode) {
    		return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
    	}

    	return value;
    }

    function decode(value, options) {
    	if (options.decode) {
    		return decodeUriComponent(value);
    	}

    	return value;
    }

    function keysSorter(input) {
    	if (Array.isArray(input)) {
    		return input.sort();
    	}

    	if (typeof input === 'object') {
    		return keysSorter(Object.keys(input))
    			.sort((a, b) => Number(a) - Number(b))
    			.map(key => input[key]);
    	}

    	return input;
    }

    function removeHash(input) {
    	const hashStart = input.indexOf('#');
    	if (hashStart !== -1) {
    		input = input.slice(0, hashStart);
    	}

    	return input;
    }

    function getHash(url) {
    	let hash = '';
    	const hashStart = url.indexOf('#');
    	if (hashStart !== -1) {
    		hash = url.slice(hashStart);
    	}

    	return hash;
    }

    function extract(input) {
    	input = removeHash(input);
    	const queryStart = input.indexOf('?');
    	if (queryStart === -1) {
    		return '';
    	}

    	return input.slice(queryStart + 1);
    }

    function parseValue(value, options) {
    	if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
    		value = Number(value);
    	} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
    		value = value.toLowerCase() === 'true';
    	}

    	return value;
    }

    function parse(query, options) {
    	options = Object.assign({
    		decode: true,
    		sort: true,
    		arrayFormat: 'none',
    		arrayFormatSeparator: ',',
    		parseNumbers: false,
    		parseBooleans: false
    	}, options);

    	validateArrayFormatSeparator(options.arrayFormatSeparator);

    	const formatter = parserForArrayFormat(options);

    	// Create an object with no prototype
    	const ret = Object.create(null);

    	if (typeof query !== 'string') {
    		return ret;
    	}

    	query = query.trim().replace(/^[?#&]/, '');

    	if (!query) {
    		return ret;
    	}

    	for (const param of query.split('&')) {
    		if (param === '') {
    			continue;
    		}

    		let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

    		// Missing `=` should be `null`:
    		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
    		value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);
    		formatter(decode(key, options), value, ret);
    	}

    	for (const key of Object.keys(ret)) {
    		const value = ret[key];
    		if (typeof value === 'object' && value !== null) {
    			for (const k of Object.keys(value)) {
    				value[k] = parseValue(value[k], options);
    			}
    		} else {
    			ret[key] = parseValue(value, options);
    		}
    	}

    	if (options.sort === false) {
    		return ret;
    	}

    	return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
    		const value = ret[key];
    		if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
    			// Sort object keys, not values
    			result[key] = keysSorter(value);
    		} else {
    			result[key] = value;
    		}

    		return result;
    	}, Object.create(null));
    }

    exports.extract = extract;
    exports.parse = parse;

    exports.stringify = (object, options) => {
    	if (!object) {
    		return '';
    	}

    	options = Object.assign({
    		encode: true,
    		strict: true,
    		arrayFormat: 'none',
    		arrayFormatSeparator: ','
    	}, options);

    	validateArrayFormatSeparator(options.arrayFormatSeparator);

    	const shouldFilter = key => (
    		(options.skipNull && isNullOrUndefined(object[key])) ||
    		(options.skipEmptyString && object[key] === '')
    	);

    	const formatter = encoderForArrayFormat(options);

    	const objectCopy = {};

    	for (const key of Object.keys(object)) {
    		if (!shouldFilter(key)) {
    			objectCopy[key] = object[key];
    		}
    	}

    	const keys = Object.keys(objectCopy);

    	if (options.sort !== false) {
    		keys.sort(options.sort);
    	}

    	return keys.map(key => {
    		const value = object[key];

    		if (value === undefined) {
    			return '';
    		}

    		if (value === null) {
    			return encode(key, options);
    		}

    		if (Array.isArray(value)) {
    			if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
    				return encode(key, options) + '[]';
    			}

    			return value
    				.reduce(formatter(key), [])
    				.join('&');
    		}

    		return encode(key, options) + '=' + encode(value, options);
    	}).filter(x => x.length > 0).join('&');
    };

    exports.parseUrl = (url, options) => {
    	options = Object.assign({
    		decode: true
    	}, options);

    	const [url_, hash] = splitOnFirst(url, '#');

    	return Object.assign(
    		{
    			url: url_.split('?')[0] || '',
    			query: parse(extract(url), options)
    		},
    		options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
    	);
    };

    exports.stringifyUrl = (object, options) => {
    	options = Object.assign({
    		encode: true,
    		strict: true
    	}, options);

    	const url = removeHash(object.url).split('?')[0] || '';
    	const queryFromUrl = exports.extract(object.url);
    	const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

    	const query = Object.assign(parsedQueryFromUrl, object.query);
    	let queryString = exports.stringify(query, options);
    	if (queryString) {
    		queryString = `?${queryString}`;
    	}

    	let hash = getHash(object.url);
    	if (object.fragmentIdentifier) {
    		hash = `#${encode(object.fragmentIdentifier, options)}`;
    	}

    	return `${url}${queryString}${hash}`;
    };

    exports.pick = (input, filter, options) => {
    	options = Object.assign({
    		parseFragmentIdentifier: true
    	}, options);

    	const {url, query, fragmentIdentifier} = exports.parseUrl(input, options);
    	return exports.stringifyUrl({
    		url,
    		query: filterObj(query, filter),
    		fragmentIdentifier
    	}, options);
    };

    exports.exclude = (input, filter, options) => {
    	const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);

    	return exports.pick(input, exclusionFilter, options);
    };
    });

    /* src/App.svelte generated by Svelte v3.37.0 */
    const file = "src/App.svelte";

    // (1:0) <script>  import Feed from './components/Feed.svelte';  import Login from './components/Login.svelte';   import { SvelteToast }
    function create_catch_block(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(1:0) <script>  import Feed from './components/Feed.svelte';  import Login from './components/Login.svelte';   import { SvelteToast }",
    		ctx
    	});

    	return block;
    }

    // (44:2) {:then}
    function create_then_block(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*token_valid*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(44:2) {:then}",
    		ctx
    	});

    	return block;
    }

    // (47:3) {:else}
    function create_else_block(ctx) {
    	let feed;
    	let current;
    	feed = new Feed({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(feed.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(feed, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(feed.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(feed.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(feed, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(47:3) {:else}",
    		ctx
    	});

    	return block;
    }

    // (45:3) {#if !token_valid}
    function create_if_block(ctx) {
    	let login;
    	let current;
    	login = new Login({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(login.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(login, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(login.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(login.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(login, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(45:3) {#if !token_valid}",
    		ctx
    	});

    	return block;
    }

    // (42:19)     checking spotify access!   {:then}
    function create_pending_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("checking spotify access!");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(42:19)     checking spotify access!   {:then}",
    		ctx
    	});

    	return block;
    }

    // (40:1) <Modal>
    function create_default_slot(ctx) {
    	let main;
    	let t;
    	let sveltetoast;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		blocks: [,,,]
    	};

    	handle_promise(/*validity*/ ctx[2], info);

    	sveltetoast = new SvelteToast({
    			props: { options: /*options*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			info.block.c();
    			t = space();
    			create_component(sveltetoast.$$.fragment);
    			attr_dev(main, "class", "svelte-ocq6f6");
    			add_location(main, file, 40, 1, 853);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			info.block.m(main, info.anchor = null);
    			info.mount = () => main;
    			info.anchor = null;
    			insert_dev(target, t, anchor);
    			mount_component(sveltetoast, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			{
    				const child_ctx = ctx.slice();
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			transition_in(sveltetoast.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			transition_out(sveltetoast.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			info.block.d();
    			info.token = null;
    			info = null;
    			if (detaching) detach_dev(t);
    			destroy_component(sveltetoast, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(40:1) <Modal>",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let modal;
    	let current;

    	modal = new Modal({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const modal_changes = {};

    			if (dirty & /*$$scope, token_valid*/ 33) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);
    	const options = { duration: 10000 };
    	let token_valid;

    	async function checkToken() {
    		const paramCheck = await getParams();

    		if (!paramCheck) {
    			$$invalidate(0, token_valid = false);
    			return;
    		}

    		$$invalidate(0, token_valid = true);
    	}

    	async function getParams() {
    		if (typeof window !== "undefined") {
    			const parsed = queryString.parse(window.location.search);

    			if (parsed.code) {
    				const success = await getAccessToken(parsed);

    				if (success) {
    					return true;
    				}
    			}
    		}

    		return false;
    	}

    	const validity = checkToken();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Feed,
    		Login,
    		SvelteToast,
    		Modal,
    		getAccessToken,
    		queryString,
    		options,
    		token_valid,
    		checkToken,
    		getParams,
    		validity
    	});

    	$$self.$inject_state = $$props => {
    		if ("token_valid" in $$props) $$invalidate(0, token_valid = $$props.token_valid);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [token_valid, options, validity];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
    	target: document.body,
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
